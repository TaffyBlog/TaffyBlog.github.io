{"pages":[{"title":"","text":"6Z9zOFVMOQ","path":"baidu_verify_6Z9zOFVMOQ.html","date":"03-08","excerpt":""},{"title":"404","text":"404页面 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num 暂时未能找到您查找的页面 可能输入的网址错误或此页面不存在 秒后自动跳转到主页 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/assets/hibiki.model.json\"},\"display\":{\"superSample\":1.5,\"width\":150,\"height\":300,\"position\":\"right\",\"hOffset\":0,\"vOffset\":0},\"mobile\":{\"show\":true,\"scale\":0.1},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});","path":"404.html","date":"03-08","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"05-23","excerpt":""},{"title":"archives","text":"","path":"archives/index.html","date":"05-30","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"05-23","excerpt":""},{"title":"links","text":"测试","path":"links/index.html","date":"05-31","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"05-23","excerpt":""},{"title":"","text":"title: ��ǩtype: “tags”date: 2017-05-16 22:40:46 comments: false","path":"tags/index.html","date":"03-08","excerpt":""}],"posts":[{"title":"Centos7安装nginx","text":"原文链接mafly 安装所需环境Nginx 是 C语言 开发，建议在 Linux 上运行，当然，也可以安装 Windows 版本，本篇则使用 CentOS 7 作为安装环境。 一. gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装： yum install gcc-c++ 二. PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令： yum install -y pcre pcre-devel 三. zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。 yum install -y zlib zlib-devel 四. OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 yum install -y openssl openssl-devel 官网下载 直接下载.tar.gz安装包，地址：https://nginx.org/en/download.html 使用wget命令下载（推荐）。 wget -c https://nginx.org/download/nginx-1.10.1.tar.gz 我下载的是1.10.1版本，这个是目前的稳定版。 解压依然是直接命令： tar -zxvf nginx-1.10.1.tar.gz cd nginx-1.10.1 配置其实在 nginx-1.10.1 版本中你就不需要去配置相关东西，默认就可以了。当然，如果你要自己配置目录也是可以的。 使用默认配置./configure 自定义配置（不推荐） ./configure \\ --prefix=/usr/local/nginx \\ --conf-path=/usr/local/nginx/conf/nginx.conf \\ --pid-path=/usr/local/nginx/conf/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi 注：将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录 编译安装make make install 启动、停止nginx查找安装路径whereis nginx 停启cd /usr/local/nginx/sbin/ ./nginx ./nginx -s stop ./nginx -s quit ./nginx -s reload ./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。 ./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。 查询nginx进程ps aux|grep nginx 重启 nginx 先停止再启动（推荐）：对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下： ./nginx -s quit ./nginx 重新加载配置文件：当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload不用先停止 ngin x再启动 nginx 即可将配置信息在 nginx 中生效，如下： ./nginx -s reload 开机自启动即在rc.local增加启动代码就可以了。 vi /etc/rc.local 增加一行 /usr/local/nginx/sbin/nginx 设置执行权限： chmod 755 rc.local 到这里，nginx就安装完毕了，启动、停止、重启操作也都完成了，当然，你也可以添加为系统服务，我这里就不在演示了。","path":"2019/01/12/installNg/","date":"01-12","excerpt":""},{"title":"nginx实现二级域名转发","text":"原文链接：Metropolis_cn 目的：解决只有一个服务器和域名，同时为几个应用提供服务的问题 举例：比如说你现在有 abc.com 的主域名，你又划分了 shop.abc.com 和 mail.abc.com 两个二级域名来实现不同的功能，并希望两个二级域名使用同一个IP地址和端口访问，但是提供不同的服务，nginx则可以监听指定的端口，根据域名的不同将请求转发给相应的端口。 实现： 1.打开nginx的配置文件，打开 /安装路径/conf/nginx.conf，进行如下配置 server { listen 80; server_name *.abc.com; if ($http_host ~* \"^(.*?)\\.abc\\.com$\") { #正则表达式 set $domain $1; #设置变量 } location / { if ($domain ~* \"shop\") { proxy_pass http://abc.com:3001; #域名中有shop，转发到3001端口 } if ($domain ~* \"mail\") { proxy_pass http://abc.com:3002; #域名中有mail，转发到3002端口 } tcp_nodelay on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以上三行，目的是将代理服务器收到的用户的信息传到真实服务器上 root html; index index.html index.htm; #默认情况 } } 2.命令行输入 /安装路径/sbin/nginx -t 查看nginx配置是否正确3.命令行输入 /安装路径/sbin/nginx -s reload 重新加载nginx4.如果相应端口上有对应的服务，那么我们的目的就达到了 作者：Metropolis_cn来源：CSDN原文：https://blog.csdn.net/Metropolis_cn/article/details/73613022版权声明：本文为博主原创文章，转载请附上博文链接！","path":"2019/01/12/nginxTurn/","date":"01-12","excerpt":""},{"title":"Docker 容器镜像删除","text":"参考链接 1.停止所有的container，这样才能够删除其中的images： docker stop $(docker ps -a -q) 如果想要删除所有container的话再加一个指令： docker rm $(docker ps -a -q) 2.查看当前有些什么images docker images 3.删除images，通过image的id来指定删除谁 docker rmi &lt;image id> 想要删除untagged images，也就是那些id为的image的话可以用 docker rmi $(docker images | grep \"^&lt;none>\" | awk \"{print $3}\") 要删除全部image的话 docker rmi $(docker images -q)","path":"2018/11/04/dockerImageDel/","date":"11-04","excerpt":""},{"title":"ASP.NET Core发布到Docker遇到的问题","text":"创建镜像时发生错误 Error: An assembly specified in the application dependencies manifest (YTF.Blog.Service.deps.json) was not found: package: 'SQLitePCLRaw.lib.e_sqlite3.linux', version: '1.1.11' path: 'runtimes/linux-x64/native/libe_sqlite3.so' ` 问题是asp.net runtime没有把服务器需要的包全部发布出来，它认为是目标系统带着有，而实际上目标系统中没有。增加如下一行到 csproj文件中即可： &lt;PublishWithAspNetCoreTargetManifest>false&lt;/PublishWithAspNetCoreTargetManifest> 最后csproj文件看上去像这个样子 &lt;Project Sdk=\"Microsoft.NET.Sdk.Web\"> &lt;PropertyGroup> &lt;TargetFramework>netcoreapp2.0&lt;/TargetFramework> &lt;PublishWithAspNetCoreTargetManifest>false&lt;/PublishWithAspNetCoreTargetManifest> &lt;/PropertyGroup> 参考链接–五角大寨 创建镜像pull dotnet镜像时出现错误：error pulling image configuration: Get https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/1f/1fe6774e5e9e4be6904e2f0b61658c67225aa36b65f76b2949e386e8da124cde/data?verify=1541342525-ulZ5ck1zqnMHaRlexfo79WRZ1gQ%3D: dial tcp: lookup production.cloudflare.docker.com: no such host 解决办法：解析production.cloudflare.docker.com的IP地址并加入/etc/hosts文件中，命令如下：echo '104.18.121.25 production.cloudflare.docker.com' >> /etc/hosts","path":"2018/11/04/aspnetDockerError/","date":"11-04","excerpt":""},{"title":"ASP.NET管道模型","text":"访问一个网页的全过程参考toumingren527 域名解析 从浏览器输入一个网址，首先要做的是域名解析，将网址解析成IP+端口，定位到网站所在的服务器。 域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。 域名解析也叫域名指向、服务器设置、域名配置以及反向IP登记等等。说得简单点就是将好记的域名解析成IP，服务由DNS服务器完成，是把域名解析到一个IP地址，然后在此IP地址的主机上将一个子目录与域名绑定。 互联网中的地址是数字的IP地址，域名解析的作用主要就是为了便于记忆。 DNS域名解析时用的是UDP协议。整个域名解析的过程如下： 浏览器向本机DNS模块发出DNS请求，DNS模块生成相关的DNS报文； DNS模块将生成的DNS报文传递给传输层的UDP协议单元； UDP协议单元将该数据封装成UDP数据报，传递给网络层的IP协议单元； IP协议单元将该数据封装成IP数据包，其目的IP地址为DNS服务器的IP地址； 封装好的IP数据包将传递给数据链路层的协议单元进行发送； 发送时在ARP缓存中查询相关数据，如果没有，就发送ARP广播（包含待查询的IP地址，收到广播的主机检查自己的IP，符合条件的主机将含有自己MAC地址的ARP包发送给ARP广播的主机）请求，等待ARP回应； 得到ARP回应后，将IP地址与路由的下一跳MAC地址对应的信息写入ARP缓存表； 写入缓存后，以路由下一跳的地址填充目的MAC地址，以数据帧形式转发；转发可能进行多次； DNS请求到达DNS服务器的数据链路层协议单元； DNS服务器的数据链路层协议单元解析数据帧，将内部的IP数据包传递给网络层IP协议单元； DNS服务器的IP协议单元解析IP数据包，将内部的UDP数据报传递给传输层UDP协议单元； DNS服务器的UDP协议单元解析收到的UDP数据报，将内部的DNS报文传递给DNS服务单元； DNS服务单元将域名解析成对应IP地址，产生DNS回应报文； DNS回应报文-&gt;UDP-&gt;IP-&gt;MAC-&gt;我的主机； 我的主机收到数据帧，将数据帧-&gt;IP-&gt;UDP-&gt;浏览器； 将域名解析结果以域名和IP地址对应的形式写入DNS缓存表。 与目的主机进行TCP连接（三次握手） 向目的主机发送TCP连接请求报文； 该TCP报文中SYN标志位设为1，表示连接请求； 该TCP报文通过IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机； 目的主机收到数据帧，通过IP-&gt;TCP，TCP协议单元回应请求应答报文； 该报文中SYN和ACK标志设为1，表示连接请求应答； 该TCP报文通过IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;我的主机； 我的主机收到数据帧，通过IP-&gt;TCP，TCP协议单元回应请求确认报文； 该TCP报文通过IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机； 目的主机收到数据帧，通过IP-&gt;TCP，连接建立完成。 发送与收取数据（浏览器与目的主机开始HTTP访问过程）只有建立连接后才能开始传输数据。 浏览器向域名发出GET方法报文（HTTP请求）； 该GET方法报文通过TCP-&gt;IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机； 目的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据（HTTP响应）；[从请求信息中获得客户机想访问的主机名。从请求信息中获取客户机想要访问的web应用（web应用程序指提供浏览器访问的程序，简称web应用）。从请求信息中获取客户机要访问的web资源。（web资源，即各种文件，图片，视频，文本等）读取相应的主机下的web应用，web资源。用读取到的web资源数据，创建一个HTTP响应。] 该HTML数据通过TCP-&gt;IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;我的主机； 我的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP-&gt;浏览器，浏览器以网页形式显示HTML内容。 与目的主机断开TCP连接（四次挥手）TCP连接释放过程： 浏览器向目的主机发出TCP连接结束请求报文，此时进入FIN WAIT状态； 该报文FIN标志位设为1，表示结束请求； TCP结束请求报文通过IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机； 目的主机收到数据帧，通过IP-&gt;TCP，TCP协议单元回应结束应答报文； 当前只是进行回应，因为目的主机可能还有数据要传，并不急着断开连接； 该报文中ACK标志位设为1，表示收到结束请求； 目的数据发送完所有数据后，向我的主机发出TCP连接结束请求报文； 该报文FIN标志位设为1，表示结束请求； TCP结束请求报文通过IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;我的主机； 我的主机收到数据帧，通过IP-&gt;TCP，TCP协议单元回应结束应答报文，此时进入TIME WAIT状态，因为不相信网络是可靠的，如果目的主机没收到还可以重发； 该报文中的FIN标志位均设为1，表示结束应答； 该TCP回应报文通过IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机； 目的主机关闭连接； TIME WAIT等待结束后，没有收到回复，说明目的正常关闭了，我的主机也关闭连接。 Http请求到达管道模型请求到达管道模型之前图示如下： 经过域名解析和三次握手之后，便开始正式发送Http请求数据，请求到达IIS服务器后: 首先是HTTP.SYS接收到请求，转发给ISAPI扩展器aspnet_isapi; aspnet_isapi将请求包装成HttpWorkerRequest对象。 调用HttpRuntime类的ProcessRequest方法并将封装的HttpWorkerRequest对象传入。 HttpRuntime中将请求放入队列。 从队列中取出第一个请求并创建HttpContext对象。 HttpApplicationFactory从对象池中创建HttpApplication对象&lt;每次请求都创建一次&gt; 反编译代码如下： HttpApplication便是Asp.Net管道模型的核心，我们在网站程序中最常用的便是扩展它，HttpModule便是专门用于扩展HttpApplication的。 HttpApplication类的请求处理流程在HttpApplication类中定义了一系列处理Http请求的事件，按照.Net Framework既定的顺序处理逻辑，并按此顺序触发事件。 所有事件如下： // // 摘要: // Occurs just before ASP.NET sends HTTP headers to the client. public event EventHandler PreSendRequestHeaders; // // 摘要: // Occurs when the handler is selected to respond to the request. public event EventHandler MapRequestHandler; // // 摘要: // Occurs when the application is disposed. public event EventHandler Disposed; // // 摘要: // Occurs as the first event in the HTTP pipeline chain of execution when ASP.NET // responds to a request. public event EventHandler BeginRequest; // // 摘要: // Occurs when a security module has established the identity of the user. public event EventHandler AuthenticateRequest; // // 摘要: // Occurs when a security module has established the identity of the user. public event EventHandler PostAuthenticateRequest; // // 摘要: // Occurs when a security module has verified user authorization. public event EventHandler AuthorizeRequest; // // 摘要: // Occurs when the user for the current request has been authorized. public event EventHandler PostAuthorizeRequest; // // 摘要: // Occurs when ASP.NET finishes an authorization event to let the caching modules // serve requests from the cache, bypassing execution of the event handler (for // example, a page or an XML Web service). public event EventHandler ResolveRequestCache; // // 摘要: // Occurs when ASP.NET bypasses execution of the current event handler and allows // a caching module to serve a request from the cache. public event EventHandler PostResolveRequestCache; // // 摘要: // Occurs just before ASP.NET sends content to the client. public event EventHandler PreSendRequestContent; // // 摘要: // Occurs when ASP.NET has mapped the current request to the appropriate event handler. public event EventHandler PostMapRequestHandler; // // 摘要: // Occurs when ASP.NET has completed processing all the event handlers for the System.Web.HttpApplication.LogRequest // event. public event EventHandler PostLogRequest; // // 摘要: // Occurs when the managed objects that are associated with the request have been // released. public event EventHandler RequestCompleted; // // 摘要: // Occurs when the request state (for example, session state) that is associated // with the current request has been obtained. public event EventHandler PostAcquireRequestState; // // 摘要: // Occurs just before ASP.NET starts executing an event handler (for example, a // page or an XML Web service). public event EventHandler PreRequestHandlerExecute; // // 摘要: // Occurs when the ASP.NET event handler (for example, a page or an XML Web service) // finishes execution. public event EventHandler PostRequestHandlerExecute; // // 摘要: // Occurs after ASP.NET finishes executing all request event handlers. This event // causes state modules to save the current state data. public event EventHandler ReleaseRequestState; // // 摘要: // Occurs when ASP.NET has completed executing all request event handlers and the // request state data has been stored. public event EventHandler PostReleaseRequestState; // // 摘要: // Occurs when ASP.NET finishes executing an event handler in order to let caching // modules store responses that will be used to serve subsequent requests from the // cache. public event EventHandler UpdateRequestCache; // // 摘要: // Occurs when ASP.NET finishes updating caching modules and storing responses that // are used to serve subsequent requests from the cache. public event EventHandler PostUpdateRequestCache; // // 摘要: // Occurs just before ASP.NET performs any logging for the current request. public event EventHandler LogRequest; // // 摘要: // Occurs when ASP.NET acquires the current state (for example, session state) that // is associated with the current request. public event EventHandler AcquireRequestState; // // 摘要: // Occurs as the last event in the HTTP pipeline chain of execution when ASP.NET // responds to a request. public event EventHandler EndRequest; // // 摘要: // Occurs when an unhandled exception is thrown. public event EventHandler Error; 执行顺序如下： /* BeginRequest Asp.net处理的第一个事件，表示处理的开始 AuthenticateRequest 验证请求，一般用来取得请求用户的信息 PostAuthenticateRequest 已经获取请求用户的信息 AuthorizeRequest 授权，一般用来检查用户的请求是否获得权限 PostAuthorizeRequest 用户请求已经得到授权 ResolveRequestCache 获取以前处理缓存的处理结果，如果以前缓存过，那么，不必再进行请求的处理工作，直接返回缓存结果 PostResolveRequestCache 已经完成缓存的获取操作 PostMapRequestHandler 已经根据用户的请求，创建了处理请求的处理器对象 AcquireRequestState 取得请求的状态，一般用于Session PostAcquireRequestState 已经取得了Session PreRequestHandlerExecute 准备执行处理程序 PostRequestHandlerExecute 已经执行了处理程序 ReleaseRequestState 释放请求的状态 PostReleaseRequestState 已经释放了请求的状态 UpdateRequestCache 更新缓存 PostUpdateRequestCache 已经更新了缓存 LogRequest 请求的日志操作 PostLogRequest 已经完成了请求的日志操作 EndRequest 本次请求处理完成 */ 请求并非所有事件都会执行，例如Error。 HttpModuleASP.NET 请求处理过程是基于管道模型的，这个管道模型是由多个HttpModule和HttpHandler组成，ASP.NET 把http请求依次传递给管道中各个HttpModule，最终被HttpHandler处理，处理完成后，再次经过管道中的HTTP模块，把结果返回给客户端。我们可以在每个HttpModule中都可以干预请求的处理过程。 当请求到达HttpModule的时候，系统还没有对这个请求真正处理，但是我们可以在这个请求传递到处理中心（HttpHandler）之前附加一些其它信息，或者截获的这个请求并作一些额外的工作，也或者终止请求等。在HttpHandler处理完请求之后，我们可以再在相应的HttpModule中把请求处理的结果进行再次加工返回客户端。 系统自带的HttpModule OutputCacheModule完成Asp.net的输出缓存管理工作：OutputCacheModule的配置参数通过system.web配置元素的caching子元素的outputCache元素进行定义。当启用输出缓存之后(启用还是通过配置文件，下同)，OutputCacheModule将注册HttpApplication的ResolveRequestCache和UpdateRequestCache两个事件完成输出缓存的管理。 SessionStateModule完成Session的管理工作：这个Module的配置参数通过配置文件中的system.web配置元素的sessionState子元素进行配置。当启用Session状态管理之后，SessionStateModule将注册HttpApplication的AcquireRequestState、ReleaseRequestState、EndRequest三个事件完成Session状态的管理工作。 ProfileModule提供个性化数据管理：这是一个自定义的类似于Session的会话状态管理，但是，个性化数据的读取和保存可以由程序员完全控制，并且提供了强类型的数据访问方式。这个Module的配置参数在system.web的子元素profile中进行说明。当启用了个性化数据管理之后，Module将注册HttpApplication的AcquireRequestState和EndRequest事件处理。 AnonymousIdentificationModule提供匿名用户的标志：是否启用匿名用户标志在配置文件的system.web配置元素的子元素anonymousIdentification中定义，还可以配置匿名标识的管理方式。由于在AuthenticateRequest事件中将验证用户，获取用户名，所以这个Module注册了PostAuthenticateRequest的事件处理，当用户没有经过验证的时候，为用户分配一个唯一的匿名标识。 WindowsAuthenticationModule、FormsAuthenticationModule和PassportAuthenticationModule用来完成用户的验证工作。 它们通过配置文件中system.web的子元素authentication子元素定义，mode属性用来指定网站当前使用的验证方式，也就是哪一个Module将被用来完成验证工作。在启用验证的情况下，FormsAuthenticationModule和PassportAuthenticationModule将注册HttpApplication的AuthenticateRequest和EndRequest事件进行用户的验证处理。WindowsAuthenticationModule将注册AuthenticateRequest的事件处理。 RoleManagerModule、UrlAuthorizationModule、FileAuthorizationModule用来完成用户的授权管理：授权管理的配置参数来自system.web的authorization子元素。UrlAuthorizationModule和FileAuthorizationModule注册了HttpApplication的AuthorizeRequest事件处理，用来检查Url和文件的访问授权。RoleManagerModule在Url和文件访问授权检查通过之后，通过用户的标识和角色来完成用户的授权检查，RoleManagerModule注册了HttpApplication的PostAuthenticateRequest和EndRequest事件处理。 自定义HttpModule 编写一个类实现IHttpModule接口。 在Init事件中注册事件，并实现事件处理方法。 在Web.Conofig中注册这个HttpModule模块。 /// &lt;summary> /// 防盗链 /// &lt;/summary> public class ImageHandler : IHttpHandler { #region IHttpHandler Members public void ProcessRequest(HttpContext context) { // 如果UrlReferrer为空，则显示一张默认的禁止盗链的图片 if (context.Request.UrlReferrer == null || context.Request.UrlReferrer.Host == null) { context.Response.ContentType = \"image/JPEG\"; context.Response.WriteFile(\"/Content/Image/Forbidden.jpg\"); } else { // 如果 UrlReferrer中不包含自己站点主机域名，则显示一张默认的禁止盗链的图片 if (context.Request.UrlReferrer.Host.Contains(\"localhost\")) { // 获取文件服务器端物理路径 string FileName = context.Server.MapPath(context.Request.FilePath); context.Response.ContentType = \"image/JPEG\"; context.Response.WriteFile(FileName); } else { context.Response.ContentType = \"image/JPEG\"; context.Response.WriteFile(\"/Content/Image/Forbidden.jpg\"); } } } #endregion }","path":"2018/10/11/aspnetPipleline/","date":"10-11","excerpt":""},{"title":"Oracle创建表空间和用户","text":"--创建表空间 create tablespace DOTNET datafile 'D:\\DOTNET\\DOTNET.DBF' size 200m autoextend on next 32m maxsize 2048m extent management local; --创建临时表空间 create temporary tablespace DOTNET_TEMP tempfile 'D:\\DOTNET\\DOTNET_TEMP.dbf' size 50M autoextend ON next 10M maxsize 100M; --创建用户 create user datamanage identified by datamanage; --分配表空间和临时表空间 alter user datamanage default tablespace DOTNET temporary tablespace DOTNET_TEMP; --给用户分配权限 grant create session,create table,create view,create sequence,unlimited tablespace to datamanage; ---授予dba权限 grant connect,resource,dba to wmlt;","path":"2018/09/17/oracleCreadUser/","date":"09-17","excerpt":""},{"title":"EF Core连接Oracle","text":"仅适用于.Net Core 2.0及以下 新建Core项目略 安装NuGet 官方尚不支持Ef Core连接Oracle,目前只有bate版 安装 Citms.EntityFrameworkCore.Oracle。 nuget地址:https://www.nuget.org/packages/Citms.EntityFrameworkCore.Oracle github:https://github.com/CrazyJson/Citms.EntityFrameworkCore.Oracle Install-Package Citms.EntityFrameworkCore.Oracle 新建DBContextpublic class CommonDBContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { var logger = new LoggerFactory(); logger.AddConsole(); optionsBuilder.UseLoggerFactory(logger); optionsBuilder.UseOracle(\"DATA SOURCE=127.0.0.1:1521/tjims;PASSWORD=test;PERSIST SECURITY INFO=True;USER ID=test\"); base.OnConfiguring(optionsBuilder); } public DbSet&lt;Spotting> Spotting { get; set; } }","path":"2018/09/17/efcoreLinkOracle/","date":"09-17","excerpt":""},{"title":"解决WebApp手机返回键直接退出问题","text":"安装vue-awesome-muinpm install vue-awesome-mui --save 更改main.jsimport Mui from 'vue-awesome-mui'; Vue.use(Mui); 更改index.html&lt;script> mui.init({ keyEventBind: { backbutton: true //关闭back按键监听 } }); //首页返回键处理 //处理逻辑：1秒内，连续两次按返回键，则退出应用； var first = null; mui.back = function () { //首次按键，提示 再按一次退出应用 if (!first) { first = new Date().getTime();//记录第一次按下回退键的时间 mui.toast('再按一次退出应用');//给出提示 history.go(-1)//回退到上一页面 setTimeout(function () {//1s中后清除 first = null; }, 1000); } else { if (new Date().getTime() - first &lt; 1000) {//如果两次按下的时间小于1s， plus.runtime.quit();//那么就退出app } } }; &lt;/script>","path":"2018/09/11/webappback/","date":"09-11","excerpt":""},{"title":"VueJs路由入门","text":"官方API 第一步 引入vue-router包npm install vue-router --save 第二步 配置路由//配置路由 const routes = [ {path: '/home', component: Home}, {path: '/news', component: News}, {path: '/', redirect: '/home'} //重定向 {path: '/*', redirect: '/home'} //重定向 ]; 第三步 实例化VueRouter对象const router = new VueRouter({ routes,//routes:routes linkActiveClass: 'active' //路由激活时的样式 }); 注意：VueRouter中的routes如果省略k-v格式，则必须叫routes，如果不省略，则key必须叫routes 第四步 在组件vue实例中引入路由vm = new Vue({ el:'#my', router, data:{ } }); 第五步 配置HTML &lt;!-- 使用 router-link 组件来导航. --> &lt;!-- 通过传入 `to` 属性指定链接. --> &lt;!-- &lt;router-link> 默认会被渲染成一个 `&lt;a>` 标签 --> &lt;router-link to=\"/home\">home&lt;/router-link> &lt;router-link to=\"/news\">news&lt;/router-link> &lt;!-- 路由出口 --> &lt;!-- 路由匹配到的组件将渲染在这里 --> &lt;router-view>&lt;/router-view> 完整示例如下&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>vue-router&lt;/title> &lt;script src=\"./node_modules/vue/dist/vue.js\">&lt;/script> &lt;script src=\"./node_modules/vue-router/dist/vue-router.js\">&lt;/script> &lt;style> /*.router-link-active { color: #f60; }*/ .active { color: #f60; } &lt;/style> &lt;script> // 定义组件 var Home = { template: '#home' } var News = { template: '#news' } //配置路由 const routes = [ {path: '/home', component: Home}, {path: '/news', component: News}, {path: '/', redirect: '/home'} //重定向 {path: '/*', redirect: '/home'} //重定向 ]; const router = new VueRouter({ routes,//routes:routes linkActiveClass: 'active' }); var vm = null; window.onload=function(){ vm = new Vue({ el:'#my', router, data:{ } }); } &lt;/script> &lt;/head> &lt;template id=\"home\"> &lt;div> &lt;h3>组件home&lt;/h3> &lt;/div> &lt;/template> &lt;template id=\"news\"> &lt;div> &lt;h3>组件news&lt;/h3> &lt;/div> &lt;/template> &lt;body> &lt;div id=\"my\"> &lt;router-link to=\"/home\">home&lt;/router-link> &lt;router-link to=\"/news\">news&lt;/router-link> &lt;div> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/div> &lt;/body> &lt;/html>","path":"2018/08/14/vueJsRoute/","date":"08-14","excerpt":""},{"title":"VueJs组件间的数据交换","text":"父组件传递数据到子组件var vm = new Vue({ el:'#my',// 2.0不允许挂载到html,body元素上 data:{ flag:'my-hello' }, components: { //局部组件 'my-parent': { template:'#parent', data(){ return { page:40, pname:'parent', } }, components:{ 'my-child':{//子组件 data(){ return { cage:'10', cname:'child' } }, template:'#child', props:['message','message2'] , //父传到子 /*props:{ //也可以是对象，允许配置高级设置，如类型判断、数据校验、设置默认值 message:String, //指定类型 message2:String, name:{ type:String, required:false }, age:{ //传的参数进行校验 type:Number, required:false, //是否必须 default:10, //默认值 validator:function(value){ //是否进行校验 return value>=0; } }, user:{ type:Object, default:function(){ return {id:111} } } },*/ } } } } }); &lt;template id=\"parent\"> &lt;div> &lt;h3>我是父组件，访问自己的数据：姓名-{{pname}},年龄-{{page}}&lt;/h3> &lt;hr> &lt;!-- 父调用子 父传入子 --> &lt;my-child :message=\"page\" :message2=\"pname\" >&lt;/my-child> &lt;/div> &lt;/template> &lt;template id=\"child\"> &lt;div> &lt;h3>我是子组件，访问父的数据：姓名-{{message2}} ,年龄-{{message}}&lt;/h3> &lt;h3>我是子组件，访问自己的数据：年龄-{{cage}}, 姓名-{{cname}}&lt;/h3> &lt;/div> &lt;/template> &lt;body> &lt;div id=\"my\"> &lt;my-parent>&lt;/my-parent> &lt;/div> &lt;/body> 在本例中： 在子组件中定义props,声明message、message2 在父组件的template中调用子组件时，使用message、message2用于传递page、pname。 子组件中直接使用message和message2即可。 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述示例中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样 子组件传递数据到父组件var vm = new Vue({ el:'#my',// 2.0不允许挂载到html,body元素上 data:{ flag:'my-hello' }, components: { //局部组件 'my-parent': { template:'#parent', data(){ return { page:40, pname:'parent', cage:'', cname:'' } }, methods:{ getSubData(name,age) { this.cage = age; this.cname = name; } }, components:{ 'my-child':{//子组件 data(){ return { cage:'10', cname:'child' } }, template:'#child', methods:{ send(){ console.log(this);// 此时this为子组件实例 this.$emit('e-child', this.cname, this.cage); //发送数据 emit发射/发送 }, }, mounted(){//常用 挂载结束状态 完成挂载 this.send(); }, } } } } }); &lt;template id=\"parent\"> &lt;div> &lt;h3>我是父组件，访问自己的数据：姓名-{{pname}},年龄-{{page}}&lt;/h3> &lt;h3 >我是父组件，接收子的数据：姓名-{{cname}}, 年龄-{{cage}}&lt;/h3> &lt;hr> &lt;!-- 子调用父 --> &lt;my-child @e-child=\"getSubData\">&lt;/my-child> &lt;/div> &lt;/template> &lt;template id=\"child\"> &lt;div> &lt;h3>我是子组件，访问自己的数据：年龄-{{cage}}, 姓名-{{cname}}&lt;/h3> &lt;button @click=\"send\">手动将子组件的数据向上传递给父组件&lt;/button> &lt;/div> &lt;/template> &lt;body> &lt;div id=\"my\"> &lt;my-parent>&lt;/my-parent> &lt;/div> &lt;/body> 在本例中： 子组件被挂载完毕时(mounted),执行了子组件中的send方法。 在send方法中，触发了e-child事件，而在父组件的template中将e-child指向了getSubData方法,并将cname、cage传递了过去。 父组件的getSubData接收到数据并向自身data赋值，数据展示完毕。 除了挂载完毕时自动传递，还可以点击按钮手动传递。 非父子组件间的数据传递与子传父类似，通过emit向另一个组件的方法发送数据。 用vm.$on接收数据 vm.$on:监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>非父子组件间的通信&lt;/title> &lt;script src=\"../node_modules/vue/dist/vue.js\">&lt;/script> &lt;script> // 定义一个空对象，用于触发和监听实例 var Bus = new Vue(); var A = { template: '#a', data(){ return { name:'aaa' } }, methods:{ send(){ Bus.$emit('data-a', this.name); } } } var B = { template: '#b', data(){ return { age:33 } }, methods:{ send(){ Bus.$emit('data-b', this.age); } } // mounted(){ // Bus.$emit('data-b', this.age) // } } var C = { template: '#c', data(){ return { name:'', age:'' } }, mounted(){ //这种写法取不到值 因为this指向Bus Bus.$on('data-a', function(name){ this.name = name; }); //箭头函数this总是指向函数定义生效时所在的对象 // 注意：箭头函数内部不会产生新的this，即就是当前实例，回调会 // 回调函数内部this为上面的空vue实例对象 /*Bus.$on('data-a', name =>{ this.name = name; });*/ Bus.$on('data-b', age =>{ //$on接收 this.age = age; }); } } var vm = null; window.onload=function(){ vm = new Vue({ el:'#my', data:{ }, components: { //局部组件 'my-a': A, 'my-b': B, 'my-c': C } }); } &lt;/script> &lt;/head> &lt;template id=\"a\"> &lt;div> &lt;h3>组件a：{{name}}&lt;/h3> &lt;button @click=\"send\">数据发给C&lt;/button> &lt;/div> &lt;/template> &lt;template id=\"b\"> &lt;div> &lt;h3>组件b：{{age}}&lt;/h3> &lt;button @click=\"send\">数据发给C&lt;/button> &lt;/div> &lt;/template> &lt;template id=\"c\"> &lt;div> &lt;h3>组件c：{{name}} {{age}}&lt;/h3> &lt;/div> &lt;/template> &lt;body> &lt;div id=\"my\"> &lt;my-a>&lt;/my-a> &lt;my-b>&lt;/my-b> &lt;my-c>&lt;/my-c> &lt;/div> &lt;/body> &lt;/html>","path":"2018/07/31/vueJsCompoentData/","date":"07-31","excerpt":""},{"title":"VueJs组件插槽、动态组件、缓存组件","text":"在组件中插入自定义内容 slot&lt;html> &lt;head> &lt;link rel=\"stylesheet\" href=\"index.css\"> &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\">&lt;/script> &lt;/head> &lt;template id=\"myslot\"> &lt;div> &lt;h3>组件&lt;/h3> &lt;slot name=\"s1\">&lt;/slot> &lt;slot name=\"s2\">&lt;/slot> &lt;/div> &lt;/template> &lt;body> &lt;div id=\"app\"> &lt;my-slot> &lt;ul slot=\"s1\"> &lt;li>1&lt;/li> &lt;li>1&lt;/li> &lt;li>1&lt;/li> &lt;/ul> &lt;ul slot=\"s2\"> &lt;li>2&lt;/li> &lt;li>2&lt;/li> &lt;li>2&lt;/li> &lt;/ul> &lt;/my-slot> &lt;/div> &lt;script src=\"index.js\">&lt;/script> &lt;/body> &lt;/html> Vue.component('my-slot', { template:'#myslot' }); var app = new Vue({ el: '#app' }) 最终生成的html代码为: &lt;div id=\"app\"> &lt;div> &lt;h3>组件&lt;/h3> &lt;ul> &lt;li>1&lt;/li> &lt;li>1&lt;/li> &lt;li>1&lt;/li> &lt;/ul> &lt;ul> &lt;li>2&lt;/li> &lt;li>2&lt;/li> &lt;li>2&lt;/li> &lt;/ul> &lt;/div> &lt;/div> slot可以将html插入到template中指定name的slot标签处，将slot标签替换掉。 动态组件 :is有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： 上述内容可以通过 Vue 的 &lt;component&gt; 元素加一个特殊的 is 特性来实现： &lt;!-- 组件会在 `currentTabComponent` 改变时改变 --> &lt;component v-bind:is=\"currentTabComponent\">&lt;/component> 在上述示例中，currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 示例如下： &lt;script src=\"https://unpkg.com/vue\">&lt;/script> &lt;div id=\"dynamic-component-demo\" class=\"demo\"> &lt;button v-for=\"tab in tabs\" v-bind:key=\"tab\" v-bind:class=\"['tab-button', { active: currentTab === tab }]\" v-on:click=\"currentTab = tab\" >{{ tab }}&lt;/button> &lt;component v-bind:is=\"currentTabComponent\" class=\"tab\" >&lt;/component> &lt;/div> Vue.component('tab-home', { template: '&lt;div>Home component&lt;/div>' }) Vue.component('tab-posts', { template: '&lt;div>Posts component&lt;/div>' }) Vue.component('tab-archive', { template: '&lt;div>Archive component&lt;/div>' }) new Vue({ el: '#dynamic-component-demo', data: { currentTab: 'Home', tabs: ['Home', 'Posts', 'Archive'] }, computed: { currentTabComponent: function () { return 'tab-' + this.currentTab.toLowerCase() } } }) 完整代码 API地址 缓存动态组件 keep-alive属性 include - 字符串或正则表达式。只有匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何匹配的组件都不会被缓存。 &lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt;transition&gt; 相似，&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 主要用于保留组件状态或避免重新渲染。 基本用法： &lt;!-- 基本 --> &lt;keep-alive> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;!-- 多个条件判断的子组件 --> &lt;keep-alive> &lt;comp-a v-if=\"a > 1\">&lt;/comp-a> &lt;comp-b v-else>&lt;/comp-b> &lt;/keep-alive> &lt;!-- 和 `&lt;transition>` 一起使用 --> &lt;transition> &lt;keep-alive> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;/transition>","path":"2018/07/30/vueJsComponentSendData/","date":"07-30","excerpt":""},{"title":"VueJs通过webpack启服务运行VUE模块文件","text":"安装依赖安装命令cnpm init cnpm i vue –s cnpm i -g webpack-cli npm i -D webpack webpack-cli cnpm i -D webpack webpack-dev-server I install -s –save 预编译模板： cnpm i -D vue-loader vue-html-loader vue-style-loader vue-template-compiler cnpm i -D css-loader file-loader style-loader cnpm i -D babel-loader babel-core babel-preset-env 使用-D会安装到devDependencies,使用-S会安装到dependencies，分别表示生产环境和开发环境的依赖。例如jquery，vue属于项目运行的依赖插件，需要放入dependencies中，像gulp，webpack等打包工具，在开发时发挥作用，存在开发环境即可。 配置package.json{ \"dependencies\": { \"vue\": \"^2.5.16\" }, \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-preset-env\": \"^1.7.0\", \"css-loader\": \"^1.0.0\", \"file-loader\": \"^1.1.11\", \"style-loader\": \"^0.21.0\", \"vue-html-loader\": \"^1.2.4\", \"vue-loader\": \"^15.2.6\", \"vue-style-loader\": \"^4.1.1\", \"vue-template-compiler\": \"^2.5.16\", \"webpack\": \"^4.16.3\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" }, \"name\": \"webpack-vue\", \"version\": \"1.0.0\", \"main\": \"main.js\", \"scripts\": { \"dev\": \"webpack-dev-server --open\" }, \"author\": \"\", \"license\": \"ISC\", \"description\": \"\" } 注意main节点配置了入口;scripts的dev配置了服务启动的快捷命令(可以不叫dev); dependencies是开发时需要依赖的模块，devDependencies是部署到生产环境需要的模块。 配置webpack webpack.config.jsconst VueLoaderPlugin = require('vue-loader/lib/plugin'); module.exports={ //模块 entry: './main.js', //入口文件 output:{ //将VUE文件编译输出 path: __dirname, //项目根路径 是node.js中的一个全局变量,它指向当前执行脚本所在的目录 filename: 'build.js' //所有的JS放入build.js }, plugins: [ // make sure to include the plugin for the magic new VueLoaderPlugin() ], module:{ rules:[{ //加载规则 test:/\\.vue$/, //vue文件 loader:'vue-loader' //加载器 },{ test:/\\.js$/, loader:'babel-loader', //ES6转换，所有的ES6文件加载及转换 exclude: /node_modules/ //排除这个目录 }, { test: /\\.css$/, //vue-loader@15.*之后除了必须带有VueLoaderPlugin 之外，还需另外单独配置css-loader。 use: ['style-loader','css-loader'] } ] } } 编写.babelrcbabel是什么? babel官网正中间一行黄色大字写着“babel is a javascript compiler”，翻译一下就是babel是一个javascript转译器。为什么会有babel存在呢？原因是javascript在不断的发展，但是浏览器的发展速度跟不上。以es6为例，es6中为javascript增加了箭头函数、块级作用域等新的语法和Symbol、Promise等新的数据类型，但是这些语法和数据类型并不能够马上被现在的浏览器全部支持，为了能在现有的浏览器上使用js新的语法和新的数据类型，就需要使用一个转译器，将javascript中新增的特性转为现代浏览器能理解的形式。babel就是做这个方面的转化工作。 { \"presets\": [ [\"env\", {\"module\": false}] ] } 编写入口文件 main.js main.js是入口文件 webpack编译会通过根目录文件打包到build.js import Vue from 'vue' import App from './App.vue' new Vue({ el: '#app', render: h => h(App) //渲染App.vue //render:function(createElement) { //return createElement(App); //} }) 建立 index.html 引用 build.js&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>vue-demo&lt;/title> &lt;/head> &lt;body> &lt;div id=\"app\">&lt;/div> &lt;script src=\"build.js\">&lt;/script> &lt;/body> &lt;/html> 此时webpack 将js/vue打包到build.js。先执行npm install 或者cnpm install。 建立Vue模块文件 App.vue &lt;template> &lt;div id=\"app\"> &lt;h1>Welcome to&lt;/h1> &lt;div>{{name}}&lt;/div> &lt;button @click=\"change\">update name&lt;/button> &lt;!-- &lt;user-list>&lt;/user-list> --> &lt;User>&lt;/User> &lt;/div> &lt;/template> &lt;script> import User from './components/User.vue' export default { data(){ return { name: 'jack' } }, methods:{ change(){ this.name = 'tom'; } }, components:{ // 'user-list':User User //相当于User:User } } &lt;/script> &lt;style > #app{ background-color:#ccc; } &lt;/style> User.vue &lt;template> &lt;div class=\"user\"> &lt;h1>用户列表&lt;/h1> &lt;ul> &lt;li v-for=\"v in users\">{{v}}&lt;/li> &lt;/ul> &lt;/div> &lt;/template> &lt;script> console.log(111); export default { data(){ return { users:['tom', 'jack', 'mike'] } } } &lt;/script> &lt;!-- scoped表示该样式只在当前组件中有效 --> &lt;!-- 加了scoped后，就不影响app.vue中的h1，否则影响 --> &lt;!-- 注意：修改style后，页面热加载有问题，需手动刷新 --> &lt;style scoped> h1{ color:red; } &lt;/style> 代码结构如下： 运行测试执行npm run dev","path":"2018/07/26/vueJswebpack/","date":"07-26","excerpt":""},{"title":"VueJs自定义指令和组件","text":"自定义指令作用除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 钩子函数// 自定义指定可操作DOM 注：必须加前缀，v- Vue.directive('hello', { // 可以有参数el binding, binding中包括一些属性：name,value, // binding.vlaue => 绑定的变量 // binding.expression => 表达式 v-my-directive=\"1+1\" // binding.arg => 传参 v-on:click // binding.modifiers => 如: v-on:click.prevent 修饰符可以有多个 bind(el, binding){//常用 console.log(el, binding.arg); el.style.color = 'red'; alert(\"指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作\"); }, inserted(){ alert(\"被绑定元素插入到dom中时调用\"); }, update(){ alert(\"被绑定元素所在模板更新时调用\"); }, componentUpdated(){ alert(\"被绑定元素所在模板完成一次更新周期时调用\") }, unbind(){ alert(\"指令与元素解绑时调用，只调用一次\"); } }) 简单实例 &lt;div id=\"app\"> &lt;span v-hello>{{message}}&lt;/span>&lt;br> &lt;span v-hello:foo>{{message}}&lt;/span> &lt;/div> Vue.directive(\"hello\",{ bind:function(el,binding){ el.style.color='red'; console.log(el,binding.arg); } }) var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }); 效果如下： 控制台输出： v-hello:foo，冒号后面表示要传递的参数。 API地址 组件创建组件外部组件 //创建方式一 var myComponent=Vue.extend({ template:\"&lt;h2>Hello world&lt;/h2>\" }); Vue.component(\"firstcom\",myComponent); //创建方式二 Vue.component(\"myvue\",{ template:\"&lt;h2>你好 VUE&lt;/h2>\" }); var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }); &lt;div id=\"app\"> &lt;myvue>&lt;/myvue> &lt;firstcom>&lt;/firstcom> &lt;/div> 效果如下： 局部组件var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, components:{ \"firstcom\":{ template:\"&lt;h2>Hello world&lt;/h2>\" }, \"myvue\":{ template:\"&lt;h2>你好 VUE&lt;/h2>\" } } }); 注意有s 使用数据var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, components:{ \"myvue\":{ template:\"&lt;h2>{{name}}&lt;/h2>\", data:function() { return { name:\"张三\" } } } } }); 每个组件都是独立的，不能直接使用vue实例中的数据。一个组件的 data 选项必须是一个函数 使用HTML模板var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, components:{ \"myvue\":{ template:\"#mytemp\", data:function() { return { arr:['a','b','c','d'] } } } } }); &lt;template id=\"mytemp\"> &lt;div> &lt;ul> &lt;li v-for=\"item in arr\">{{item}}&lt;/li> &lt;/ul> &lt;/div> &lt;/template> &lt;body> &lt;div id=\"app\"> &lt;myvue>&lt;/myvue> &lt;/div> &lt;script src=\"index.js\">&lt;/script> &lt;/body> 注意template需要写在body外部。","path":"2018/07/25/vuejscmd/","date":"07-25","excerpt":""},{"title":"VueJs实例属性","text":"获取data中的属性var app = new Vue({ el: '#app', data: { message: 'Hello Vue!哈哈哈哈哈哈哈哈哈' } }); console.log(app.message); Hello Vue!哈哈哈哈哈哈哈哈哈 获取实例关联的DOM&lt;div id=\"app\"> {{ message }} &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!哈哈哈哈哈哈哈哈哈' } }); console.log(app.$el); &lt;div id=\"app\"> 获取自定义属性var app = new Vue({ el: '#app', data: { message: 'Hello Vue!哈哈哈哈哈哈哈哈哈' }, name:\"我是自定义属性\" }); console.log(app.$options.name); //我是自定义属性 ref 获取单个标签或组件ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： &lt;!-- `vm.$refs.p` will be the DOM node --> &lt;p ref=\"p\">hello&lt;/p> &lt;!-- `vm.$refs.child` will be the child component instance --> &lt;child-component ref=\"child\">&lt;/child-component> vm.$refs.child获取child-component标签。 关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 手动挂载VUE实例 $mount 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。 var app = new Vue({ data: { message: 'Hello Vue!' } }); app.$mount(\"#app\"); 在页面加载完成时得到DOM值vm.$nextTick( [callback] ) 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 直接获取DOM: &lt;div id=\"app\"> &lt;span ref=\"msg\">{{message}}&lt;/span>&lt;br> &lt;span> {{ show() }}&lt;/span> &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, methods: { show:function() { console.log(this.$refs.msg); } } }); 输出： null 加上$nextTick: var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, methods: { show:function() { this.$nextTick(function(){ console.log(this.$refs.msg); }); } } }); 输出： Hello Vue! 防止页面未渲染导致DOM数据获取失败。 动态添加和删除数据对象的属性&lt;div id=\"app\"> &lt;button @click=\"add\">add&lt;/button> &lt;button @click=\"show\">show&lt;/button> &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!', user:{ name:\"张三\", age:18 } }, methods:{ add:function(){ this.user.hobby=\"game\"; console.log(\"ok\"); }, show:function() { console.log(this.user.game); } } }); 依次点击add和show按钮，输出如下： ok null 由此可见，对于对象类型的数据，直接扩展属性是不行的。 set delete 增加和删除数据对象属性 受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。 如果直接增加属性： &lt;div id=\"app\"> &lt;span>{{user.hobby}}&lt;/span>&lt;br/> &lt;button @click=\"add\">add&lt;/button> &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!', user:{ name:\"张三\", age:18 } }, methods:{ add:function(){ this.user.hobby=\"game\"; } } }); 点击add按钮，毫无反应： 使用$set增加属性var app = new Vue({ el: '#app', data: { message: 'Hello Vue!', user:{ name:\"张三\", age:18 } }, methods:{ add:function(){ this.$set(this.user,\"hobby\",\"game\") } } }); 点击add按钮，顺利显示hobby属性： 使用$delete删除属性var app = new Vue({ el: '#app', data: { message: 'Hello Vue!', user:{ name:\"张三\", age:18 } }, methods:{ add:function(){ this.$delete(this.user,\"name\") } } }); API地址","path":"2018/07/25/vueAttr/","date":"07-25","excerpt":""},{"title":"VueJs生命周期、计算属性和侦听器","text":"VUE生命周期生命周期说明 new Vue({ el:'#my',// 2.0不允许挂载到html,body元素上 data:{ msg:'welcome' }, methods:{ update(){ this.msg=\"欢迎\"; }, destroy(){ this.$destroy(); //销毁实例 } }, beforeCreate(){ console.log('loading'); alert('组件实例刚刚创建，还未进行数据观测和事件配置');//创建前状态 el和data并未初始化 }, created(){//常用 创建完毕状态 完成了data数据的初始化 el没有 alert(\"实例已经创建完成，并且已经进行数据观测和事件配置\") }, beforeMount(){ //挂载前状态 完成了el和data初始化 this.msg=\"112233\"; alert(\"模板编译之前，还没挂载\"); }, mounted(){//常用 挂载结束状态 完成挂载 alert(\"模板编译之后，已经挂载，此时才会有渲染页面，才能看到页面上数据的显示\") }, beforeUpdate(){ //更新前状态 alert(\"组件更新之前\"); }, updated(){ //更新完成状态 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 alert(\"组件更新之后\"); }, beforeDestroy(){ //销毁前状态 alert(\"组件销毁之前\"); }, destroyed(){ //销毁完成状态 alert('组件销毁之后'); } }); API地址 图示： 计算属性 计算属性可用于存储和处理数据。对于任何复杂逻辑，都应当使用计算属性。 简单使用示例(反转字符串)var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, computed:{ reverseMsg:function(){ return this.message.split('').reverse().join(''); } } }); &lt;div id=\"app\"> &lt;span>{{ message }}&lt;/span>&lt;br> &lt;span>{{ reverseMsg }}&lt;/span> &lt;/div> 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。也就是说，如果需要更改计算属性的值，则必须使用getter和setter的方式，不能直接更改计算属性。 使用getter settervar vm = new Vue({ data: { a: 1 }, computed: { // 仅读取 aDouble: function () { return this.a * 2 }, // 读取和设置 aPlus: { get: function () { return this.a + 1 }, set: function (v) { this.a = v - 1 } } } }) vm.aPlus // => 2 vm.aPlus = 3 vm.a // => 2 vm.aDouble // => 4 计算属性缓存 vs 方法 你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果;我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 API地址 watch侦听器 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 官方示例: var vm = new Vue({ data: { a: 1, b: 2, c: 3, d: 4, e: { f: { g: 5 } } }, watch: { a: function (val, oldVal) { console.log('new: %s, old: %s', val, oldVal) }, // 方法名 b: 'someMethod', // 深度 watcher c: { handler: function (val, oldVal) { /* ... */ }, deep: true }, // 该回调将会在侦听开始之后被立即调用 d: { handler: function (val, oldVal) { /* ... */ }, immediate: true }, e: [ function handle1 (val, oldVal) { /* ... */ }, function handle2 (val, oldVal) { /* ... */ } ], // watch vm.e.f's value: {g: 5} 'e.f': function (val, oldVal) { /* ... */ } } }) vm.a = 2 // => new: 2, old: 1 注意事项： 注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 外部定义watch//方式2 vm.$watch('name', function(newValue, oldValue){ console.log('name被修改了', newValue, oldValue); }); watch VS computed在vue的 模板内（{{}}）是可以写一些简单的js表达式的 ，很便利。但是如果在页面中使用大量或是复杂的表达式去处理数据，对页面的维护会有很大的影响。这个时候就需要用到computed 计算属性来处理复杂的逻辑运算。 computed优点： 在数据未发生变化时，优先读取缓存。computed 计算属性只有在相关的数据发生变化时才会改变要计算的属性，当相关数据没有变化是，它会读取缓存。而不必像 motheds方法 和 watch 方法是的每次都去执行函数。 demo: &lt;div id=\"app\"> &lt;span>名字：&lt;/span>&lt;input v-model=\"name\">&lt;br/> &lt;span>年龄：&lt;/span>&lt;input v-model=\"age\">&lt;br/> &lt;span>{{text}}&lt;/span>&lt;br/> &lt;span>{{computedAge}}&lt;/span> &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!', name:\"sdf\", age:18, text:\"\" }, watch:{ name:function(newvalue,oldvalue) { this.text='watch》》》'+\"我的名字改成了：\"+newvalue+\",原来的名字叫：\"+oldvalue; } }, computed:{ computedAge:{ get:function() { return 'computed》》》'+'我的年龄'+this.age + '我的姓名' + this.name } } } }); 初次加载效果： 更改age值之后： 更改name值之后: watch监视对象变化var app = new Vue({ el: '#app', data: { message: 'Hello Vue!', user:{ name:\"sdf\", age:18, }, text:\"\" }, watch:{ user:{ handler(newvalue,oldvalue) { this.text='watch》》》'+\"我的名字改成了：\"+newvalue.name+\",原来的名字叫：\"+oldvalue.age; }, deep:true } } }); handler表示默认执行的函数。 表示监视对象的属性变化,false则handler函数不执行,但此时看不到newValue与oldValue区别, 为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意:监听数组的变动不需要这么做。","path":"2018/07/20/vueLifeCycle/","date":"07-20","excerpt":""},{"title":"VueJs过滤器","text":"内部过滤器Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。 简单示例如下: &lt;div id=\"app\"> {{ 3.1415926 | number(2)}} &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, filters:{ number:function(data,n){ return data.toFixed(n); } } }); 效果如下： 以上是对数字进行保留两位小数的四舍五入，data是数据,n是传入参数。 外部过滤器 当过滤器定义为内部过滤器时，则只能在当前实例中使用，定义为外部过滤器则在所有实例中可以公用。 使用Vue.filter即可： Vue.filter('date',(data,n)=>{ let d = new Date(data); return d.getFullYear()+'-'+(d.getMonth()+1)+'-'+d.getDay(); }); var app = new Vue({ el: '#app', data: { message: 'Hello Vue!', currentTime:Date.now() }, filters:{ number:function(data,n){ return data.toFixed(n); } } }); &lt;div id=\"app\"> &lt;span>{{currentTime | date}}&lt;/span> &lt;/div>","path":"2018/07/17/vueJsFilter/","date":"07-17","excerpt":""},{"title":"VueJs事件操作","text":"阻止事件冒泡事件冒泡HTML的事件会按照DOM的结构由内向外冒泡触发，如下所示： &lt;div @click=\"show3()\" id=\"app\">A3 &lt;div @click=\"show2()\">A2 &lt;button @click=\"show1()\">A1&lt;/button> &lt;/div> &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, methods:{ show1:function(){ console.log(111); }, show2:function(){ console.log(222); }, show3:function(){ console.log(333); } } }); 点击A1之后的输出如下： 111 222 333 普通方式阻止事件冒泡 stopPropagation()方法可以阻止事件冒泡。 将button的事件加上$event参数： &lt;div @click=\"show3()\" id=\"app\">A3 &lt;div @click=\"show2()\">A2 &lt;button @click=\"show1($event)\">A1&lt;/button> &lt;/div> &lt;/div> 使用event参数调用stopPropagation方法。 var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, methods:{ show1:function(e){ console.log(111); e.stopPropagation(); }, show2:function(){ console.log(222); }, show3:function(){ console.log(333); } } }); 输出如下： 111 使用vue的方式阻止事件冒泡 只需在事件后面加上.stop即可 &lt;div @click=\"show3()\" id=\"app\">A3 &lt;div @click=\"show2()\">A2 &lt;button @click.stop=\"show1()\">A1&lt;/button> &lt;/div> &lt;/div> 取消默认动作html标签都有一些默认的行为，比如form的提交，a标签的跳转,原生js可以使用preventDefault取消默认动作，用法和阻止事件冒泡一样。 vuejs的用法： 只需在事件后加上.prevent即可 &lt;div id=\"app\"> &lt;a href=\"http://www.baidu.com\" @click.prevent=\"show1()\">A1&lt;/a> &lt;/div> 点击A1标签不会跳转到百度。 只触发一次&lt;div id=\"app\"> &lt;a href=\"http://www.baidu.com\" @click.once=\"show1()\">A1&lt;/a> &lt;/div> 多次点击A1标签，show1也只会被触发一次。 API地址 键盘事件&lt;!-- Alt + C --> &lt;input @keyup.alt.67=\"clear\"> &lt;!-- Ctrl + Click --> &lt;div @click.ctrl=\"doSomething\">Do something&lt;/div> API地址","path":"2018/07/16/vueJsEvent/","date":"07-16","excerpt":""},{"title":"VueJs表单数据操作","text":"实现根据条件禁用DOM示例如下： var app = new Vue({ el: '#app', data: { value: 'a' } }); &lt;div id=\"app\"> &lt;input type=\"text\" :disabled=\"value=='b'\" v-model=\"value\"> &lt;/div> 获取设置复选框和单选按钮值复选框示例var app = new Vue({ el: '#app', data: { values:[] } }); &lt;div id=\"app\"> &lt;input type=\"checkbox\" v-model=\"values\" value=\"a\" />a &lt;input type=\"checkbox\" v-model=\"values\" value=\"b\" />b &lt;input type=\"checkbox\" v-model=\"values\" value=\"c\" />c &lt;input type=\"checkbox\" v-model=\"values\" value=\"d\" />d &lt;span>{{values}}&lt;/span> &lt;/div> 单选按钮示例var app = new Vue({ el: '#app', data: { values:'0' } }); &lt;div id=\"app\"> &lt;input type=\"radio\" name=\"sex\" v-model=\"values\" value=\"0\" />男 &lt;input type=\"radio\" name=\"sex\" v-model=\"values\" value=\"1\" />女 &lt;span>{{values}}&lt;/span> &lt;/div> 获取下拉列表值var app = new Vue({ el: '#app', data: { items:[ {text:\"老师\",value:1}, {text:\"学生\",value:2}, {text:\"家长\",value:3}, ], selectvalue:1 } }); &lt;div id=\"app\"> &lt;select v-model=\"selectvalue\"> &lt;option v-for=\"item in items\" :value=\"item.value\">{{item.text}}&lt;/option> &lt;/select> &lt;span>{{selectvalue}}&lt;/span> &lt;/div> 常用修饰符不允许输入空格&lt;input v-model.trim=\"message\" /> 加上trim，输入空格会被自动移除 引用多个样式数组方式var app = new Vue({ el: '#app', data: { aa:'aa-class', bb:'bb-class' } }); &lt;div id=\"app\"> &lt;span :class=\"[aa,bb]\"> &lt;/div> 对象方式var app = new Vue({ el: '#app', data: { aa:'aa-class', bb:'bb-class', flag:true } }); &lt;div id=\"app\"> &lt;span :class=\"{aa:flag,bb:flag}\"> &lt;/div>","path":"2018/07/12/vuejstemplete/","date":"07-12","excerpt":""},{"title":"VueJs内置指令入门","text":"v-modelv-model 可用于双向数据绑定 ，主要用于表单，表单值发生变化，数据也会变化。同样的，数据发生变化，表单值也会发生变化。 var app = new Vue({ el: '#app', data: { msg: '你好 Vue!', name:'xxx', age:22, work:'设计师' } }); &lt;div id=\"app\"> {{ msg }} &lt;pre> 名字：{{name}} 年龄：{{age}} 工作：{{work}} &lt;/pre> &lt;span>&lt;/span> &lt;input type=\"text\" v-model=\"name\" value=\"test\"> &lt;/div> v-model的值指向data中的一项数据即可。 API地址 v-forv-for可以循环操作数组或者对象 简单示例： var app = new Vue({ el: '#app', data: { arr:['a','b','c','d'] } }); &lt;div id=\"app\"> &lt;ul> &lt;li v-for=\"item in arr\">{{item}}&lt;/li> &lt;/ul> &lt;/div> 获取键的写法 &lt;div id=\"app\"> &lt;ul> &lt;li v-for=\"(item,index) in arr\">{{item}}===={{index}}&lt;/li> &lt;/ul> &lt;/div> index如果是数组则是索引，如果是对象则是key API地址 v-onv-on 用于绑定事件处理函数。 click事件示例： &lt;div id=\"app\"> &lt;span>{{name}}&lt;/span> &lt;button v-on:click=\"myclick\">点击&lt;/button> &lt;/div> var app = new Vue({ el: '#app', data: { name:'是啥', arr:['a','b','c','d'] }, methods:{ myclick:function(){ this.name='hello'; } } }); 其他： &lt;!-- 方法处理器 --> &lt;button v-on:click=\"doThis\">&lt;/button> &lt;!-- 内联语句 --> &lt;button v-on:click=\"doThat('hello', $event)\">&lt;/button> &lt;!-- 缩写 --> &lt;button @click=\"doThis\">&lt;/button> &lt;!-- 停止冒泡 --> &lt;button @click.stop=\"doThis\">&lt;/button> &lt;!-- 阻止默认行为 --> &lt;button @click.prevent=\"doThis\">&lt;/button> &lt;!-- 阻止默认行为，没有表达式 --> &lt;form @submit.prevent>&lt;/form> &lt;!-- 串联修饰符 --> &lt;button @click.stop.prevent=\"doThis\">&lt;/button> &lt;!-- 键修饰符，键别名 --> &lt;input @keyup.enter=\"onEnter\"> &lt;!-- 键修饰符，键代码 --> &lt;input @keyup.13=\"onEnter\"> &lt;!-- 点击回调只会触发一次 --> &lt;button v-on:click.once=\"doThis\">&lt;/button> &lt;!-- 对象语法 (2.4.0+) --> &lt;button v-on=\"{ mousedown: doThis, mouseup: doThat }\">&lt;/button> API地址 v-show v-if v-else v-else-ifv-show根据表达式之真假值，切换元素的 display CSS 属性。 &lt;div v-if=\"Math.random() > 0.5\"> Now you see me &lt;/div> &lt;div v-else> Now you don't &lt;/div> v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-if vs v-show不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。","path":"2018/07/10/vuejsInInstruct/","date":"07-10","excerpt":""},{"title":"Promise 异步优化","text":"测试浏览器是否支持promise.在浏览器控制台输入: new Promise(function() { console.log(\"ok\"); }); 输出ok则表示支持。 基本使用方法示例如下： 定义 let fun=function(url,type,data) { //resolve 表示执行成功 reject表示失败 const p = new Promise(function(resolve,reject){ const handler = function(){ if(this.readyState!==4) //XHR的状态，从0-4发生变化(0请求尚未初始化，1服务器链接已成功，2请求已接收，3请求处理中，4请求已完成，响应就绪) { return; } if(this.status===200) { resolve(this.respose); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(type,url,true); client.onreadystatechange=handler; //当readyState属性改变时，就会触发 client.responseType=\"json\"; if(type.toUpper() == \"GET\") { client.send(); } else { client.setRequestHeader(\"Accept\",application/json\"\"); client.send(data); } }); return p; } 调用let add =(name,message)=>{ p(\"/map/add\",\"post\",{name:name,message:message}) .then(json=>{ //成功后逻辑 },error=>{ //失败后逻辑 console.log('发生错误',error); }); } 另一种写法: let add =(name,message)=>{ p(\"/map/add\",\"post\",{name:name,message:message}) .then(json=>{ //成功后逻辑 }) .catch(error=>{ //失败后逻辑 console.log('发生错误',error); }); } 串行执行then关键字可以串行执行异步操作。 // 0.5秒后返回input*input的计算结果: function multiply(input) { return new Promise(function (resolve, reject) { log('calculating ' + input + ' x ' + input + '...'); setTimeout(resolve, 500, input * input); }); } // 0.5秒后返回input+input的计算结果: function add(input) { return new Promise(function (resolve, reject) { log('calculating ' + input + ' + ' + input + '...'); setTimeout(resolve, 500, input + input); }); } var p = new Promise(function (resolve, reject) { log('start new Promise...'); resolve(123); }); p.then(multiply) .then(add) .then(multiply) .then(add) .then(function (result) { log('Got value: ' + result); }); 执行结果: start new Promise... calculating 123 x 123... calculating 15129 + 15129... calculating 30258 x 30258... calculating 915546564 + 915546564... Got value: 1831093128 并行执行除了串行执行若干异步任务外，Promise还可以并行执行异步任务。 试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下： var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, 'P1'); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, 'P2'); }); // 同时执行p1和p2，并在它们都完成后执行then: Promise.all([p1, p2]).then(function (results) { console.log(results); // 获得一个Array: ['P1', 'P2'] }); 有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现： var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, 'P1'); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, 'P2'); }); Promise.race([p1, p2]).then(function (result) { console.log(result); // 'P1' }); 由于p1执行较快，Promise的then()将获得结果’P1’。p2仍在继续执行，但执行结果将被丢弃。 JQuery的用法基本用法 $.ajax(url:\"/rest/add\",type:\"POST\",datatype:\"json\") .done(function(data){ //执行成功的逻辑 }) .fail(function(){ //发生错误 }); 链式写法 $.ajax(url:\"/rest/add\",type:\"POST\",datatype:\"json\") .then(data=>{ return $.ajax(url:\"/rest/add1\",type:\"POST\",datatype:\"json\",data:data); }) .then(data=>{ return $.ajax(url:\"/rest/add2\",type:\"POST\",datatype:\"json\",data:data.id); }) .then(data=>{ alert(data); }); 并行执行 $.ajax(url:\"/rest/add\",type:\"POST\",datatype:\"json\") .when($.ajax(url:\"/rest/add1\",type:\"POST\",datatype:\"json\"), $.ajax(url:\"/rest/add2\",type:\"POST\",datatype:\"json\") }) .then(data1,data2=>{ //成功 },()=>{ //失败 }); 参考资料","path":"2018/06/26/jsPromise/","date":"06-26","excerpt":""},{"title":"JS变量提升","text":"JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。以下两个实例将获得相同的结果： 例1 x = 5; // 变量 x 设置为 5 elem = document.getElementById(\"demo\"); // 查找元素 elem.innerHTML = x; // 在元素中显示 x var x; // 声明 x //例2 var x; // 声明 x x = 5; // 变量 x 设置为 5 elem = document.getElementById(\"demo\"); // 查找元素 elem.innerHTML = x; // 在元素中显示 x JavaScript 只有声明的变量会提升，初始化的不会。以下两个实例结果结果不相同： var x = 5; // 初始化 x var y = 7; // 初始化 y elem = document.getElementById(\"demo\"); // 查找元素 elem.innerHTML = x + \" \" + y; // 显示 x 和 y var x = 5; // 初始化 x elem = document.getElementById(\"demo\"); // 查找元素 elem.innerHTML = x + \" \" + y; // 显示 x 和 y var y = 7; // 初始化 y //实例 2 的 y 输出了 undefined，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量 容易引发的问题var str = '123'; function a() { console.log(str); if (false) { var str = '6546'; } }; a(); 以上例子会输出undefined,虽然函数外部声明了一个str,但是在函数内部再次声明了一个str,所以str的声明被提升到函数顶部，并且未赋值，会覆盖外部声明的str，所以输出undefined","path":"2018/06/22/varPromote/","date":"06-22","excerpt":""},{"title":"Javascript解构赋值","text":"解构赋值语法是一个 Javascript 表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。 解构数组变量声明并赋值时的解构var foo = [\"one\", \"two\", \"three\"]; var [one, two, three] = foo; console.log(one); // \"one\" console.log(two); // \"two\" console.log(three); // \"three\" 变量先声明后赋值时的解构var a, b; [a, b] = [1, 2]; console.log(a); // 1 console.log(b); // 2 默认值//为了防止从数组中取出一个值为undefined的对象，可以为这个对象设置默认值。 var a, b; [a = 5, b = 7] = [1]; console.log(a); // 1 console.log(b); // 7 交换变量 在一个解构表达式中可以交换两个变量的值。 没有解构赋值的情况下，交换两个变量需要一个临时变量。 var a = 1; var b = 3; [a, b] = [b, a]; console.log(a); // 3 console.log(b); // 1 解析一个从函数返回的数组 从一个函数返回一个数组是十分常见的情况.。解构使得处理返回值为数组时更加方便。 在下面例子中，[1, 2] 作为函数的f() 的输出值，可以使用解构用一句话完成解析: function f() { return [1, 2]; } var a, b; [a, b] = f(); console.log(a); // 1 console.log(b); // 2 忽略某些返回值 你也可以忽略你不感兴趣的返回值：`javascriptfunction f() { return [1, 2, 3];} var [a, , b] = f();console.log(a); // 1console.log(b); // 3 ### 将剩余数组赋值给一个变量 &gt; 当解构一个数组时，可以使用剩余模式，将数组剩余部分赋值给一个变量。 ```javascript var [a, ...b] = [1, 2, 3]; console.log(a); // 1 console.log(b); // [2, 3] 注意：如果剩余元素右侧有一个逗号，会抛出SyntaxError，因为剩余元素必须是数组的最后一个元素。 用正则表达式匹配提取值 用正则表达式方法exec()匹配字符串会返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串——如果不需要的话`javascriptvar url = “https://developer.mozilla.org/en-US/Web/JavaScript&quot;; var parsedURL = /^(\\w+)\\:\\/\\/([^\\/]+)\\/(.*)$/.exec(url);console.log(parsedURL); // [“https://developer.mozilla.org/en-US/Web/JavaScript&quot;, “https”, “developer.mozilla.org”, “en-US/Web/JavaScript”] var [, protocol, fullhost, fullpath] = parsedURL; console.log(protocol); // “https” ## 解构对象 ### 基本赋值 ```javascript var o = { p: 42, q: true }; var { p, q } = o; console.log(p); // 42 console.log(q); // true 无声明赋值var a, b; ({ a, b } = { a: 1, b: 2 }); 赋值语句周围的( .. ) 是使用对象字面解构赋值时不需要声明的语法。 { a, b } = { a: 1, b: 2 } 不是有效的独立语法，因为左边的{a, b } 被认为是一个块而不是对象字面量。然而，({ a, b } = { a: 1, b: 2 }) 是有效的，正如 var { a, b } = { a: 1, b: 2 } 注意：你的( .. ) 表达式需要一个分号在它前面，否则它也许会被当成上一行中的函数来执行。 给新的变量名赋值 可以从一个对象中提取变量并赋值给和对象属性名不同的新的变量名。自定义变量名/重新定义变量名 //p和q只是一个模式匹配 var o = { p: 42, q: true }; var { p: foo, q: bar } = o; console.log(foo); // 42 console.log(bar); // true 默认值 变量可以先赋予默认值。当要提取的对象没有对应的属性，变量就被赋予默认值。 var { a = 10, b = 5 } = { a: 3 }; console.log(a); // 3 console.log(b); // 5 给新的变量命名并提供默认值 一个属性可以是从一个对象解构，并分配给一个不同名称的变量，分配一个默认值，以防未解构的值是undefined。 var { a: aa = 10, b: bb = 5 } = { a: 3 }; console.log(aa); // 3 console.log(bb); // 5 函数参数默认值//ES5版本 function drawES5Chart(options) { options = options === undefined ? {} : options; var size = options.size === undefined ? 'big' : options.size; var cords = options.cords === undefined ? { x: 0, y: 0 } : options.cords; var radius = options.radius === undefined ? 25 : options.radius; console.log(size, cords, radius); // now finally do some chart drawing } drawES5Chart({ cords: { x: 18, y: 30 }, radius: 30 }); //ES6版本 function drawES2015Chart({ size = 'big', cords = { x: 0, y: 0 }, radius = 25 } = {}) { console.log(size, cords, radius); // do some chart drawing } drawES2015Chart({ cords: { x: 18, y: 30 }, radius: 30 }); 在上面的drawES2015Chart的函数签名中，解构的左手边被分配给右手边的空对象字面值：{ size = ‘big’, cords = { x: 0, y: 0 }, radius = 25 } = { } 。 你也可以在没有右侧分配的情况下编写函数。 但是，如果你忽略了右边的赋值，那么函数会在被调用的时候查找至少一个被提供的参数，而在当前的形式下，你可以直接调用drawES2015Chart()而不提供任何参数。 如果你希望能够在不提供任何参数的情况下调用该函数，则当前的设计非常有用，而另一种方法在您确保将对象传递给函数时非常有用。 解构嵌套对象和数组var metadata = { title: \"Scratchpad\", translations: [ { locale: \"de\", localization_tags: [], last_edit: \"2014-04-14T08:43:37\", url: \"/de/docs/Tools/Scratchpad\", title: \"JavaScript-Umgebung\" } ], url: \"/en-US/docs/Tools/Scratchpad\" }; var { title: englishTitle, translations: [{ title: localeTitle }] } = metadata; console.log(englishTitle); // \"Scratchpad\" console.log(localeTitle); // \"JavaScript-Umgebung\" For of 迭代和解构var people = [ { name: \"Mike Smith\", family: { mother: \"Jane Smith\", father: \"Harry Smith\", sister: \"Samantha Smith\" }, age: 35 }, { name: \"Tom Jones\", family: { mother: \"Norah Jones\", father: \"Richard Jones\", brother: \"Howard Jones\" }, age: 25 } ]; for (var { name: n, family: { father: f } } of people) { console.log(\"Name: \" + n + \", Father: \" + f); } // \"Name: Mike Smith, Father: Harry Smith\" // \"Name: Tom Jones, Father: Richard Jones\" 从作为函数实参的对象中提取数据function userId({ id }) { return id; } function whois({ displayName: displayName, fullName: { firstName: name } }) { console.log(displayName + \" is \" + name); } var user = { id: 42, displayName: \"jdoe\", fullName: { firstName: \"John\", lastName: \"Doe\" } }; console.log(\"userId: \" + userId(user)); // \"userId: 42\" whois(user); // \"jdoe is John\" 这段代码从user对象中提取并输出id、displayName和firstName。 对象属性名和解构 属性名，如object literals，可以被解构。 let key = \"z\"; let { [key]: foo } = { z: \"bar\" }; console.log(foo); // \"bar\" //对象解构中的Rest //Rest 属性收集尚未被解构模式拾取的剩余可枚举属性键。 let { a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 } a; // 10 b; // 20 rest; // { c: 30, d: 40 } 参考链接","path":"2018/06/22/DestructuringAssignment/","date":"06-22","excerpt":""},{"title":".NET平台常用的框架整理","text":"分布式缓存框架Microsoft Velocity：微软自家分布式缓存服务框架。 Memcahed：一套分布式的高速缓存系统，目前被许多网站使用以提升网站的访问速度。 Redis：是一个高性能的KV数据库。 它的出现很大程度补偿了Memcached在某些方面的不足。 EnyimMemcached：访问Memcached最优秀的.NET客户端，集成不错的分布式均衡算法。 开源的.NET系统推荐OXITE：微软ASP.NET MVC案例演示框架。 PetShop：微软ASP.Net宠物商店。 Orchard：国外一个MVC开源的博客系统。 SSCLI：微软在NET Framework 2.0时代的开源代码。 DasBlog：国外一个基于ASP.NET的博客系统。 BlogEngine.NET：国外一款免费开源的博客系统。 Dotnetnuke.NET：一套非常优秀的基于ASP.NET的开源门户网站程序。 Discuz.NET：国内开源的论坛社区系统。 nopCommerce和Aspxcommerce：国外一套高质量的开源B2C网站系统。 JumboTCMS和DTCMS：国内两款开源的网站管理系统： ##日志记录异常处理 Log4Net.dll：轻量级的免费开源.NET日志记录框架。 Enterprise Library Log Application Black：微软企业库日志记录。 Elmah：实现最流行的ASP.NET应用异常日志记录框架。 NLog：是一个简单灵活的日志记录类库，性能比Log4Net高，使用和维护难度低。 ##关于NoSQL数据库 MongoDB：分布式文件存储数据库。 Membase：家族的一个新的重量级的成员。 自动任务调度框架Quartz.NET：开源的作业调度和自动任务框架。 Topshelf：另一种创建Windows服务的开源框架 依赖注入IOC容器框架Unity：微软patterns&amp;practicest团队开发的IOC依赖注入框架，支持AOP横切关注点。 MEF（Managed Extensibility Framework）：是一个用来扩展.NET应用程序的框架，可开发插件系统。 spring.NET：依赖注入、面向方面编程(AOP)、数据访问抽象,、以及ASP.NET集成。 Autofac：最流行的依赖注入和IOC框架，轻量且高性能，对项目代码几乎无任何侵入性。 PostSharp：实现静态AOP横切关注点，使用简单，功能强大，对目标拦截的方法无需任何改动。 Ninject：基于.NET轻量级开源的依赖注入IOC框架 常用的几个ORM框架EF（ADO.NET Entity Framework）：微软基于ADO.NET开发的ORM框架。 Nhibernate：面向.NET环境的轻量级的ORM框架。 SqlMapper.cs：用于小项目的通用的C#数据库访问类。 AutoMapper：流行的对象映射框架，可减少大量硬编码，很小巧灵活，性能表现也可接受。 SubSonic：优秀的开源的ORM映射框架，同时提供符合自身需要的代码生成器。 FluentData：开源的基于Fluent API的链式查询ORM轻量级框架。 Dapper：轻量级高性能基于EMIT生成的ORM框架。 EmitMapper：性能较高的ORM框架，运行时通过EMIT动态生成IL代码，并非采用反射机制。 格式和数据类型转换Newtonsoft.Json：目前.NET开发中最流行的JSON序列化库，为新版的WebApi库提供基础。 System.JSON.dll：微软自己开发的JSON序列化组件（需要单独下载） DataContractJsonSerializer 和 DataContractXmlSerializer：微软在WCF中使用的序列化器。 JavaScriptSerializer：微软默认针对WEB开发者提供的JSON格式化器。 iTextSharp、PDFsharp 和 PDF.NET：通过.NET处理和生成PDF文档的组件。 SharpZipLib.dll：免费开源的ZIP和GZIP文件解压缩组件。 Math.NET：强大的数学运算、微积分、解方程和科学运算。 DocX：不需要安装word软件，通过C#操作word文件。 SharpSerializer：开源XML和、二进制、JSON、压缩和优化框架。 反射和动态语言Clay dynamic：开源的动态语言dynamic框架让您形如JavaScript的方式创建对象。 ExposedObject：在类的外部通过动态语言dynamic的方式访问私有成员。 PrivateObject：微软单元测试框架中便捷在外部调用类内部私有成员的一个类。 跨平台和运行时解决方案MONO.NET：跨平台的.NET运行环境，让.NET跨平台运行成为可能。 DotGnu Portable.NET：类似于MONO.NET的跨平台运行时。 Phalanger：将PHP编译成.NET，可实现PHP与.NET互操作。 VMDotNet：中国移动飞信所使用过的.NET运行时。 Unity3D：微软大力支持的机遇C#和JavaScript的跨平台游戏开发框架。 Cassini、IIS Express和Cassinidev`：开源的ASP.NET执行环境。 Katana：微软基于OWIN规范实现的非IIS寄宿ASP.NET和MVC等。 IKVM.NET：基于.NET的Java虚拟机，让JAVA运行在.NET之上。 WEB开发和设计Jumony Core：基于.NET开发的HTML引擎。 Microsoft.mshtml.dll、Winista.HtmlParser.dll 和 HtmlAgilityPack.dll：解析处理HTML文档的框架。 JavaScript.NET和ClearScript（微软出品）：基于.NET开发的JavaScript引擎。 NCrawler：其HTML处理引擎htmlagilitypack的的开源网络爬虫软件。 AntiXSS：微软官方预防跨站XSS脚本入侵攻击的开源类库，它通过白名单机制进行内容编码。 YUICompressor.NET、Microsoft Ajax Minifier 和 Google Closure Compiler：JavaScrip和CSS压缩器。 NancyFx：是一个不错的轻量级开源.NET WEB框架。如果想快速做个简单的WEB应用 官网：http://nancyfx.org/。 AspNetPager：国内知名的ASP.NET分页控件，支持多种分页方式。 NOPI.dll：导出Excel报表的插件（基于微软OpenXml实现）（nopi.css.dl通过css设置样式） Enterprise Library：微软针对企业级应用开发的最佳实践组件。 PowerCollections：国外一个牛人写的高级开源集合。 移动互联网和云计算PushSharp：通过.NET向各种移动平台推送消息。 mono for Android：用.NET语言开发安卓应用： MonoTouch：用.NET语言开发iOS应用。 PhoneGap和AppCan：跨平台基于HTML5的移动开发平台。 Cordova：PhoneGap贡献给Apache后的开源项目，是驱动PhoneGap的核心引擎。 网络通信和网络协议SuperSocket：基于.NET轻量级的可扩展的Socket开发框架。 SuperWebSocket：通过.NET实现TML5 WebSocket框架。 XProxy：支持插件的基础代理程序集，内置NAT、加解密、反向、直接和间接代理。 图形和图像处理框架Paint.NET：基于.NET小巧灵活强大的图形处理开源项目。 Imagemagick.NET：用C#对开源图像处理组件Imagemagick的封装。 Skimpt：基于.NET开源的屏幕截图软件。 ImageGlue.NET：商业的图像处理组件，支持的格式列了一大堆。 Sprite and Image Optimization Framework：微软CSS精灵，多图合成一张大图和CSS样式。 桌面应用程序框架DevExpress：一个全球知名的桌面应用程序UI控件库。 Prism：微软开发的针对WPF和Silverlight的MVVM框架，通过功能模块化的思想，来讲复杂的业务功能和UI耦合性进行分离。 WPFToolkit 和 Fluent Ribbon Control Suite：开发类似于Office风格的Ribbon菜单。 测试和性能评估方面Faker.Net：方便生成大批量测试数据的框架。 Nunit：一个轻量级的单元测试框架。 Moq：非常流行的Mock框架，支持LINQ，灵活且高性能。 xUnit：比NUnit更好的单元测试框架，升级改进版的Nunit框架。 MiniProfiler和Glimpse：基于MVC的两款性能事件监控框架。 事务和分布式事务支持KtmIntegration：一个支持NTFS文件系统的事务开源类。 NET Transactional File Manager：对文件系统操作（复制、移动和删除）加入事务支持。 分词、全文检索和搜索引擎Lucene.net：流行高性能的全文索引库，可用于为各类信息提供强大的搜索功能。 Lucene.Net.Analysis.PanGu：支持Lucene.Net最新版的盘古中文分词扩展库。 数据验证组件整理FluentValidation for .NET：基于LINQ表达式方法链Fluent接口验证组件。 Microsoft.Practices.EnterpriseLibrary.Validation.dll：微软企业库验证程序块。 CuttingEdge.Conditions：基于Fluent接口方法练接口的契约编程组件。 DotNetOpenAuth：让网站具备支持OpenID、OAuth、InfoCard等身份验证的能力。 开源图表统计控件：Visifire：一套效果非常好的WPF图表控件，支持3D绘制、曲线、折线、扇形、环形和梯形。 SparrowToolkit：一套WPF图表控件集，支持绘制动态曲线，可绘制示波器、CPU使用率和波形。 DynamicDataDisplay：微软开源的WPF动态曲线图，线图、气泡图和热力图。 消息队列Kafka Kafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下： 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out：支持在线水平扩展。 RabbitMQ RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。 Redis Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。 ZeroMQ ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。 ActiveMQ ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。 Kafka/Jafka Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。","path":"2018/05/21/DotNetCommonFramework/","date":"05-21","excerpt":""},{"title":"var和let的作用域区别","text":"在方法中function a() { if (true) { var str = \"123\"; } console.log(str); } a(); //输出 123 function b() { if (true) { let str = \"123\"; } console.log(str); } b(); //Uncaught ReferenceError: str is not defined var 的作用域是函数体，let的作用域是一个代码块 在同一代码块声明//声明 var a = 1; var a = 3; //不会报错，后声明的会将先声明的覆盖 let a = 1; let a = 3; //会报错，不能重复声明。 使用let时和后台语言(C#、Java)代码更相似。","path":"2018/05/13/varAndletDifference/","date":"05-13","excerpt":""},{"title":"JS简单工厂和观察者模式","text":"简单工厂模式示例如下: function A() { this.name = 'ss'; this.action = function () { console.log(this.name); } } function B() { this.age = 1; this.action = function () { console.log(this.age); } } var CreateFactory = { Create: function (type) { if (type == 'a') { return new A(); } else { return new B(); } } } var obj = CreateFactory.Create(\"a\"); obj.action(); //输出 ss 观察者模式示例如下： 定义一个数组存放订阅者。 定义一个listen方法添加订阅者。 定义一个trigger方法，循环订阅者并执行。 调用listen方法添加订阅者。 调用trigger方法触发。 var ObserverObj = { list: [], listen: function (fn) { this.list.push(fn); }, trigger: function () { for (var i = 0, fn; fn = this.list[i++];) { console.log(fn); fn.apply(this, arguments); } } } ObserverObj.listen(function (name, age) { console.log(\"名字:\" + name); console.log(\"年龄:\" + age); }); ObserverObj.listen(function (name, age) { console.log(\"这个人叫:\" + name); console.log(\"How old:\" + age); }); ObserverObj.trigger(\"小王\", 18);","path":"2018/05/13/jsFactoryAndObserver/","date":"05-13","excerpt":""},{"title":"正则表达式","text":"使用方法var filter = /^[a-z]at$/; var value = 'cat'; if (filter.test(value)) { console.log('ok'); } //或者 var filter = new RegExp('^[a-z]at$'); var value = 'cat'; if (filter.test(value)) { console.log('ok'); } //输出ok \\b \\B \\b匹配一个单词的边界 \\B匹配一个单词的非边界 表达式 \\bhi\\b 可以匹配 hi this 表示找出的hi两边必须有空格 表达式 \\Bhi\\B 能匹配 hi this 表示找出的hi两边必须没有空格 \\d \\D \\d匹配一个数字字符 \\D匹配一个非数字字符 表达式 \\d 能匹配 123456 表达式 \\D 能匹配 A a \\w \\W \\w匹配数字、字母、下划线 \\W匹配非数字、字母、下划线 表达式\\w能匹配123ab_ 表达式\\W能匹配@#$% ^ $ ^表示字符串开头 $表示字符串结尾 [] []匹配指定一堆字符中的一个例如： [a - z]表示a- z中的其中一个字符。 [A - Za - z]表示a- z或A - Z中的其中一个字符 [aeiou]表示aeiou这几个字符中的其中一个 [^xyz]表示不匹配xyz这三个字符。 + +表示前一模式可以被重复1次或者n次例如： 表达式 ^go+gle$ 能匹配 gogle google gooooooogle 表达式 ^g[aeiou]+gle$ 能匹配 gagle gegle geagle geaeaioueagle * ? {x} {x,y} {x,} 号表示前一模式可以被重复0次或n次，和+号的区别就是+必须重复一次，可以不重复。 ?号表示前一模式可以被重复0次或1次。要么出现1次要么不出现 {x}表示前一模式可以被重复x次 {x,y}表示前一模式可以被重复x到y次 {x,}表示前一模式必须至少重复x次。 () ()可以指定一堆字符来匹配一个模式例如： ^(very )*large$ 可以匹配 large very very large 等 | |用来指定几个规则只要匹配一个规则即可完成匹配 例如： ^abc.(com|cn|net)$ 能匹配 abc.com abc.cn abc.net \\ \\转义 ，如果要匹配{、^、+等有特殊含义的字符，可以用\\转义。 例如: ^1*(2+3)=6$ 只能匹配 1*(2+3)=6","path":"2018/04/29/jsRegExp/","date":"04-29","excerpt":""},{"title":"this关键字","text":"函数中this的指向var x = 1; function test() { this.x; } console.log(x); //此时输出1 var x = 1; function test1() { this.x = 0; } test1(); console.log(x); //此时输出 0 function test2() { this.x = 2; } test2(); test1(); console.log(x); //此时输出0 以上示例中this指向函数的拥有者/调用者，也就是window对象。 第一个示例中没有调用，函数体不会执行，所以输出为初始值1； 第二个示例中调用了一次，由于是在window对象中调用的，x也是在window对象中声明的，所以this指向window对象中的x，x被改变为0。 第三个示例中，分别调用了两个函数，先调用test2该变x=2，然后调用test1改变x=0,最后输出0。 在对象中使用thisvar o = {}; o.a = 1; o.action = function () { return this.a; } console.log(o.action()); //输出1 this指向当前对象 指向一个实例，示例中this指向o。 对象中调用外部函数function f() { return this.a; } var o = {}; o.a = 1; o.action = f; console.log(o.action()); //输出1 以上示例中f属于o,所以o是f的拥有者，所以this指向o。 构造函数中使用 thisfunction ParentFunc(name, age) { this.name = name; this.age = age; } var p = new ParentFunc(\"lili\", 25); console.log(p.name); //输出lili //此时this指向实例，也就是p。 改变this的指向 使用 call(作用域，参数1，餐数2..) ,apply(作用域，参数数组) 在一个对象中调用另一个对象 var a = 121; function f() { return this.a; } var o = {}; o.a = 1; o.action = f; console.log(o.action.call()); //输出121 console.log(o.action.call(o)); //输出1 如果call方法不传参数则默认指向window对象，window对象中的a=121。当传了一个o的时候，作用域就被指向o，所以输出为o.a=1。 经典示例var number = 1; var obj = { number: 2, showNumber: function () { this.number = 3; //指向obj (function () { console.log(this.number);//指向window })(); console.log(this.number); //指向obj } }; obj.showNumber(); //输出 1 3 示例中调用showNumber方法中，首先改变obj.number=3 然后是一个自调用的方法，在自调用方法中，this指向window对象，所以先输出一个1; 然后输出obj.number=3。","path":"2018/04/29/thisOfJs/","date":"04-29","excerpt":""},{"title":"Js单例模式","text":"js的单例模式主要是使用闭包函数实现。 实现方式很简单，示例如下: &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;title>&lt;/title> &lt;script src=\"jquery-3.3.1.min.js\">&lt;/script> &lt;script type=\"text/javascript\"> var showWindow = (function CreateWindow() { var d; return function () { if (!d) { d = document.createElement(\"div\"); d.innerHTML = \"弹窗内容\"; d.setAttribute(\"display\", \"none\"); document.body.appendChild(d); } return d; }; })(); window.onload = function () { document.getElementById(\"btn\").onclick = function () { var win = showWindow(); win.style.display = \"block\"; } } &lt;/script> &lt;/head> &lt;body> &lt;input type=\"button\" value=\"show Window\" id=\"btn\" /> &lt;/body> &lt;/html>","path":"2018/04/29/jsSingleton/","date":"04-29","excerpt":""},{"title":"原生Js使用Ajax","text":"ajax技术核心 XMLHttpRequest对象(XHR)IE5/IE6 ActiveXObject var xhr; if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else { xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); //IE5/IE6 } //发起get请求 xhr.open( \"get\", url, true //true异步 false同步 ); xhr.send();","path":"2018/04/29/jsAjax/","date":"04-29","excerpt":""},{"title":"原型和继承","text":"原型属性prototype用法function Person() { }; Person.prototype.name = '呵呵'; Person.prototype.age = 18; Person.prototype.action = function () { console.log(this.name); }; var per1 = new Person(); per1.action(); /** * 1. 声明一个构造函数 * 2. 声明prototype属性 * 3. 实例化 * * 实例化的对象可以共享prototype的属性和方法。可由此实现继承 * */ 在实例中修改原型属性 protoper1.__proto__.name = '咳咳'; var per2 = new Person(); per2.action(); //输出 咳咳 检测对象是否属于原型if (Person.prototype.isPrototypeOf(per1)) { console.log('ok'); } //构造函数和原型的区别 //构造函数是用于生成对象的模板，当实例化多个对象时，会重复创建对象，造成内存空间浪费，增大CPU的开销，并没有消除代码的冗余。 //将公用方法或属性设置为原型方法或属性，会让公共方法或属性在内存中只存在一份，不会重复创建。 继承##用法 //Boy 继承Person function Person() { }; Person.prototype.name = '呵呵'; Person.prototype.age = 18; Person.prototype.action = function () { console.log(this.name); }; function Boy() { }; Boy.prototype = new Person(); var b = new Boy(); b.action(); //输出 呵呵 子类调用父类构造函数 call(作用域,参数1，参数2…), apply(作用域,参数数组) function ParentFunc(name,age) { this.name = name; this.age = age; } function SonFunc() { ParentFunc.call(this,'张三',22); } SonFunc.prototype = new ParentFunc(); var son1 = new SonFunc(); console.log(son1.name); //输出 张三","path":"2018/04/09/prototypeAndInherit/","date":"04-09","excerpt":""},{"title":"作用域和闭包","text":"闭包函数声明方式 每个函数生成时都会形成一个封闭环境 var func = (function parentFunc() { var name = 'parent'; return function sonFunc() { var name = 'son'; return name; }; })(); func(); //输出 son 另一个例子： var add = (function (arr) { var i = 0; return function () { return arr[i++]; } })(['a','b','c']); console.log(add()); //a console.log(add()); //b console.log(add()); //c //add相当于内部函数，每次调用add就相当于调用一次内部函数。 JS作用域var f =(function a() { var k = 20; return function () { console.log(k); }; })(); var k = 1000; f(); //输出 20 按照其他后台语言来讲，函数执行之后，内部的变量就不存在了，k会为1000; 但JS中不是的，在本例中，调用f时会输出k,首先在内部函数中没有k,则向外部函数找，所以k为20。 所以不是从调用的地方往上找所需变量，而是从声明函数的地方一层层往上找，找到之后就不再往上找。","path":"2018/04/09/closureScope/","date":"04-09","excerpt":""},{"title":"EF高级特性","text":"DBContext类理解DBContext 是数据库的映射，包含全部的表 管理了数据库链接，一个实例是一个链接 本地缓存属性：查询数据后是放入本地缓存；修改操作是本地属性；删除也是修改本地属性；savechange的时候是一次性保存本地属性的全部变化，默认是开启事务的 本地缓存由于对数据库实体的操作都是在本地缓存中执行的，所以如果直接new出来的对象是无法进行修改和删除的，示例如下: User userNew = new User() { Account = \"Admin\", State = 0, CompanyId = 4, CompanyName = \"万达集团\", CreateTime = DateTime.Now, CreatorId = 1, Email = \"57265177@qq.com\", LastLoginTime = null, LastModifierId = 0, LastModifyTime = DateTime.Now, Mobile = \"18664876671\", Name = \"yoyo\", Password = \"12356789\", UserType = 1 }; dbContext.User.Add(userNew); dbContext.SaveChanges(); 删除操作以上代码将userNew插入了数据库,接下来对其进行删除： dbContext.User.Remove(userNew); dbContext.SaveChanges(); 这样就会报一个错：无法删除此对象，因为未在ObjectStateManager中找到它。 如何解决？ context.User.Attach(userNew); dbContext.User.Remove(userNew); dbContext.SaveChanges(); 删除之前先Attach一下就可以了。 修改操作接下来对其进行修改: userNew.Name = \"安德鲁\"; dbContext.SaveChanges(); 直接这样操作将不会记录到数据库。 如何解决? context.User.Attach(userNew); userNew.Name = \"安德鲁\"; dbContext.SaveChanges(); 修改之前Attach一下就可以了，必须在修改之前,否则将不会生效。 但是如果非要在修改之后再Attach，也是可以的,但需要设置状态: userNew.Name = \"安德鲁\"; context.User.Attach(userNew); context.Entry&lt;User>(userNew).State = EntityState.Modified;//需要指定状态 或者Attach后修改 dbContext.SaveChanges(); 删除也是一样的。 查询单个查询时，在查询一次之后，如果以同样的条件查询，会从缓存中查询，不会再去查询数据库： var user1 = context.User.Find(2); var user2 = context.User.Where(u => u.Id == 2); var user3 = context.User.Find(2); var user4 = context.User.Where(u => u.Id == 2); 以上代码只会查询一次。 如果数据库有改变，程序中需要重新查询数据库,可以使用AsNoTracking方法： var user1 = context.User.Find(2).AsNoTracking(); Database类打印执行的Sql语句使用Database类的Log属性,这是一个委托，示例如下: using (JDContext dbContext = new JDContext()) { dbContext.Database.Log += c => Console.WriteLine(c); { User user2 = dbContext.User.Find(2); } } 这将在每次进行数据库操作时打印对应的Sql语句。 直接执行Sql语句以及开启数据库事物使用ExecuteSqlCommand方法进行增删改操作，使用SqlQuery方法进行查询操作，使用DbContextTransaction开启数据库事物。 示例代码如下: DbContextTransaction trans = null; try { trans = dbContext.Database.BeginTransaction(); string sql = \"Update [User] Set Name='小新' WHERE Id=@Id\"; SqlParameter parameter = new SqlParameter(\"@Id\", 1); dbContext.Database.ExecuteSqlCommand(sql, parameter); trans.Commit(); } catch (Exception ex) { if (trans != null) trans.Rollback(); throw ex; } finally { trans.Dispose(); } DbContextTransaction trans = null; try { trans = dbContext.Database.BeginTransaction(); string sql = \"SELECT * FROM [User] WHERE Id=@Id\"; SqlParameter parameter = new SqlParameter(\"@Id\", 1); List&lt;User> userList = dbContext.Database.SqlQuery&lt;User>(sql, parameter).ToList&lt;User>(); trans.Commit(); } catch (Exception ex) { if (trans != null) trans.Rollback(); throw ex; } finally { trans.Dispose(); } 导航属性延迟加载、子查询延迟加载设置是否延迟加载: context.Configuration.LazyLoadingEnabled = true;//默认是true 针对导航属性的 导航属性在查询父表时，不会同时查询子表，只有在使用子表数据(即导航属性)时才会去查询子表数据。 示例如下: using (JDContext context = new JDContext()) { context.Database.Log += c => Console.WriteLine(c); //实体类型包含其它实体类型（POCO类）的属性（也可称为导航属性），且同时满足如下条件即可实列延迟加载， //1.该属性的类型必需为public且不能为Sealed； //2.属性标记为Virtual context.Configuration.LazyLoadingEnabled = true;//默认是true 针对导航属性的 var companyList = context.Set&lt;Company>().Where(c => c.Id > 0); foreach (var company in companyList) { Console.WriteLine(\"Company id={0} name={1}\", company.Id, company.Name); foreach (var item in company.User)//这个时候才去数据库查询user { Console.WriteLine(\"User name={0}\", item.Name); } } } 这样每个company都会去数据库查询一次，但如果想要一次性查询出来呢？ 有如下几种方式： 使用Include方法 // // 摘要: // 指定要包括在查询结果中的相关对象。 // // 参数: // path: // 要在查询结果中返回的相关对象列表（以点号分隔）。 // // 返回结果: // 一个新的 System.Data.Entity.Infrastructure.DbQuery`1，它具有定义的查询路径。 public virtual DbQuery&lt;TResult> Include(string path); 示例如下： using (JDContext context = new JDContext()) { context.Database.Log += c => Console.WriteLine(c); //指定Include，一次性加载出来 var companyList = context.Set&lt;Company>().Include(\"User\").Where(c => c.Id > 0); foreach (var company in companyList) { Console.WriteLine(\"Company id={0} name={1}\", company.Id, company.Name); foreach (var item in company.User) { Console.WriteLine(\"User name={0}\", item.Name); } } }","path":"2018/01/22/EFAdvancedFeatures/","date":"01-22","excerpt":""},{"title":"EntityFramework建立的三种方式","text":"DBFirst添加步骤 添加Ado.net实体数据模型。 选择来自数据的EF设计器。 建立数据库连接。 选择数据库对象。 以上步骤完成后，会自动生成一个对应数据库的实体关系图。 以及以下文件： 如果更改了数据库结构，可以在实体关系图上右键选中该实体使用“从数据库更新模型即可” CodeFirst来自数据库的CodeFirst 添加Ado.net实体数据模型。 选择来自数据的CodeFirst。 建立数据库连接。 选择数据库对象。 以上步骤完成后会生成如下文件： 此方法和dbfirst较为相似，但只会生成数据库实体模型和数据访问上下文，比dbfirst生成的文件更简洁。 如果连接字符串中的数据库不存在，则会自动在服务器上根据配置及实体模型新建一个数据库以及表。 映射规则特性映射代码中使用特性Table即可: [Table(\"Company\")] public partial class Company {} 使用此特性后，数据库生成的表名就是给Table特性传递的参数。 如果要映射列名: [Table(\"Company\")] public partial class Company { [Column(\"CategoryId\")] public int? ClassId { get; set; } } Mapping方式 新建一个类: using System; using System.Collections.Generic; using System.Data.Entity.ModelConfiguration; using System.Linq; using System.Text; using System.Threading.Tasks; namespace EFDemo.CodeFirstFromDB.Mapping { public class JDCommodity002Mapping : EntityTypeConfiguration&lt;JDCommodity002> { public JDCommodity002Mapping() { this.ToTable(\"JD_Commodity_002\"); } } } 然后在Context中的OnModelCreating方法里添加配置: protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Configurations.Add(new JDCommodity002Mapping()); } ToTable方法中传递的参数就是要生成的表名了。 FluentAPI方式 protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity&lt;JDCommodity003>().ToTable(\"JD_Commodity_003\"); } 如果是要映射列名: protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity&lt;JDCommodity003>().ToTable(\"JD_Commodity_003\") .Property(c => c.ClassId).HasColumnName(\"CatetgoryId\"); } 这表示将C#模型中的JDCommodity003类的ClassId属性，映射为数据库的JD_Commodity_003表、CatetgoryId列。 ModelFirstModelFirst也就是Dbfirst的反向操作，即先做好实体模型，然后生成sql语句，也就是相当于把powerdesigner的功能拿过来了。个人不太喜欢，因此不做过多研究。","path":"2018/01/16/EntityFramework/","date":"01-16","excerpt":""},{"title":"EntityFramework操作数据库","text":"新增数据示例代码: using (CodeFirstDBContext dbContext = new CodeFirstDBContext()) { User userNew = new User() { Account = \"Admin\", State = 0, CompanyId = 4, CompanyName = \"万达集团\", CreateTime = DateTime.Now, CreatorId = 1, Email = \"57265177@qq.com\", LastLoginTime = null, LastModifierId = 0, LastModifyTime = DateTime.Now, Mobile = \"18664876671\", Name = \"yoyo\", Password = \"12356789\", UserType = 1 }; dbContext.Users.Add(userNew); dbContext.SaveChanges(); } 修改数据示例代码: userNew.Name = \"安德鲁\"; dbContext.SaveChanges(); 删除数据示例代码: dbContext.Users.Remove(userNew); dbContext.SaveChanges(); 查询数据 查询条件放在Where中使用lambda表达式: var list2 = dbContext.User.Where(u => u.Id &lt; 3); 排序 var list4 = list2.Where(u => u.Name.Length &lt; 3).OrderBy(u => u.Id); EF中的查询有延迟查询的效果，也就是说只有在真正使用查询结果的时候才会去数据库查询，在此之前如果还设置了查询条件则会与之前条件的连接。如果使用ToLit方法则会立即查询到内存中。 按主键查找查找单个示例代码: User user2 = dbContext.User.Find(2); 查找多个Contains方法,示例代码: var list = dbContext.User.Where(u => new int[] { 1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 14 }.Contains(u.Id)); 设置查询字段Select方法可以筛选查询的字段，不必查询全部字段的时候可以使用： var list = dbContext.User.Where(u => new int[] { 1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 14 }.Contains(u.Id)).Select(u=>new {Account =u.Account,Id=u.Id }); 以上示例中就只查询了Account和Id字段。 模糊查询 var list = dbContext.User.Where(u => u.Name.StartsWith(\"小\") &amp;&amp; u.Name.EndsWith(\"新\")) .Where(u => u.Name.EndsWith(\"新\")) .Where(u => u.Name.Contains(\"小新\")) .Where(u => u.Name.Length &lt; 5) .OrderBy(u => u.Id); StartsWith相当于前%，EndsWith相当于后%,Contains相当于两个%。 连接查询 var list = from u in dbContext.User join c in dbContext.Category on u.CompanyId equals c.Id into ucList from uc in ucList.DefaultIfEmpty() where new int[] { 1, 2, 3, 4, 6, 7, 10 }.Contains(u.Id) select new { Account = u.Account, Pwd = u.Password }; 相当于数据库左连接查询。 分页查询 var list = (from u in dbContext.User where new int[] { 1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 14 }.Contains(u.Id) .OrderBy(u => u.Id)//必须加OrderBy,不然运行会报错 select new { Account = u.Account, Pwd = u.Password }).Skip(3).Take(5); 表示跳过前3条，查询5条。","path":"2018/01/16/EFDatabaseOperation/","date":"01-16","excerpt":""},{"title":"ORM概念","text":"ORM 对象关系映射对象关系映射（英语：(Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换[1] 。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。 对象关系映射（Object-Relational Mapping）提供了概念性的、易于理解的模型化数据的方法。ORM方法论基于三个核心原则： 简单：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化的结构。 典型地，建模者通过收集来自那些熟悉应用程序但不熟练的数据建模者的人的信息开发信息模型。建模者必须能够用非技术企业专家可以理解的术语在概念层次上与数据结构进行通讯。建模者也必须能以简单的单元分析信息，对样本数据进行处理。ORM专门被设计为改进这种联系。 简单的说：ORM相当于中继数据。具体到产品上，例如ADO.NET Entity Framework。DLINQ中实体类的属性[Table]就算是一种中继数据。 使用ORM的利弊优点 开发速度更快。 学习成本降低。 在小型项目上效率较高。 支持异构的数据库。 缺点 固定生成sql，对sql优化比较困难。 反射造成性能损失。 容易造成不当的缓存使用。","path":"2018/01/16/Orm/","date":"01-16","excerpt":""},{"title":"CSS选择器","text":"css选择器列表 选择器 例子 例子描述 CSS .class .intro 选择 class=”intro” 的所有元素。 1 #id #firstname 选择 id=”firstname” 的所有元素。 1 * * 选择所有元素。 2 element p 选择所有 p 元素。 1 element,element div,p 选择所有 div 元素和所有 p 元素。 1 element element div p 选择 div 元素内部的所有 p 元素。 1 element&gt;element div&gt;p 选择父元素为 div 元素的所有 p 元素。 2 element+element div+p 选择紧接在 div 元素之后的所有 p 元素。 2 [attribute] [target] 选择带有 target 属性所有元素。 2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 [attribute丨=value] [lang丨=en] 选择 lang 属性值以 “en” 开头的所有元素。 2 :link a:link 选择所有未被访问的链接。 1 :visited a:visited 选择所有已被访问的链接。 1 :active a:active 选择活动链接。 1 :hover a:hover 选择鼠标指针位于其上的链接。 1 :focus input:focus 选择获得焦点的 input 元素。 2 :first-letter p:first-letter 选择每个 p 元素的首字母。 1 :first-line p:first-line 选择每个 p 元素的首行。 1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 p 元素。 2 :before p:before 在每个 p 元素的内容之前插入内容。 2 :after p:after 在每个 p 元素的内容之后插入内容。 2 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 p 元素。 2 element1~element2 p~ul 选择前面有 p 元素的每个 ul 元素。 3 [attribute^=value] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 a 元素。 3 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 a 元素。 3 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 a 元素。 3 :first-of-type p:first-of-type 选择属于其父元素的首个 p 元素的每个 p 元素。 3 :last-of-type p:last-of-type 选择属于其父元素的最后 p 元素的每个 p 元素。 3 :only-of-type p:only-of-type 选择属于其父元素唯一的 p 元素的每个 p 元素。 3 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 p 元素。 3 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 p 元素。 3 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 p 元素的每个 p 元素。 3 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 p 元素。 3 :root :root 选择文档的根元素。 3 :empty p:empty 选择没有子元素的每个 p 元素（包括文本节点）。 3 :target #news:target 选择当前活动的 #news 元素。 3 :enabled input:enabled 选择每个启用的 imput 元素。 3 :disabled input:disabled 选择每个禁用的 imput 元素 3 :checked input:checked 选择每个被选中的 imput 元素。 3 :not(selector) :not(p) 选择非 p 元素的每个元素。 3 ::selection ::selection 选择被用户选取的元素部分。 3 为了兼容老版本的写法：-moz代表firefox浏览器私有属性，-ms代表ie浏览器私有属性，-webkit代表safari、chrome私有属性。现在比较流行的一个概念就是：不太关键的样式，可以不考虑兼容，如果客户浏览器太旧，就让他看到旧的效果就是，一定要看到新效果，只能建议客户升级浏览器。","path":"2017/12/17/cssSelector/","date":"12-17","excerpt":""},{"title":"Javascript 面向对象","text":"js中创建对象的三种方式使用Object 使用new Object()创建对象。 然后可以为对象设置属性和值 var student=new Object(); student.name = '张三'; student.age =28; 使用构造函数 定义函数，参数为需要创建的对象的属性值。 函数内使用this关键字设置属性。 创建对象时使用new 函数名(参数值)来创建对象。 function Student(name,age) { this.name=name, this.age=age }; var stu1 = new Student('张三',25); var stu2 = new Student('李四',23); 构造函数和普通函数的区别 this的指向，构造函数的this指向使用该构造函数创建的实例；普通函数指向的是函数的调用者。 调用方式，构造函数使用new关键字。 命名规范，构造函数首字母大写帕斯卡命名法，普通函数使用驼峰命名法。 使用字面量即用类似于json的方式来创建对象，创建空对象可用:var obj = {}。 var student = { name:'张三', age:23, study:function(){} }; //调用方式 student.study(); for循环和each的区别var arr = [1,2,3,4,5,6,7,8,9,10]; $.each(arr, function (index, item) { //item是当前项，index是索引 console.log(item); }); //for循环同步，each异步。each无法使用break,continue 判断对象是否存在某一个属性://使用 hasOwnProperty var o = { a: 1, b: 2, c: 3 }; if (o.hasOwnProperty('a')) { console.log('ok'); } //或者 if (o.a != undefined) { console.log('ok'); }","path":"2017/12/12/JavaScriptOO/","date":"12-12","excerpt":""},{"title":"JavaScript绘制图片验证码","text":"步骤 在html中加入canvas标签。 在js中绘制一个矩形框。 绘制随机文字并随机颜色，随机倾斜一定角度。 绘制干扰线、干扰点。 在倾斜验证码时，倾斜的只会是画布，文字不会跟随。因此，可以把画布的起始位置移动到绘制文字的位置，然后将画布倾斜一定角度，然后再绘制文字，第一个文字绘制完成后将画布归位，继续绘制第二个文字。画布倾斜的单位是弧度。 代码HTML： &lt;html> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;script src=\"js/demo.js\">&lt;/script> &lt;link rel=\"stylesheet\" href=\"css/demo.css\"> &lt;/head> &lt;body> &lt;canvas id=\"validate\">&lt;/canvas> &lt;a href=\"javascript:;\">换 一 个&lt;/a> &lt;/body> &lt;/html> CSS： a { text-decoration: none; height: 30px; width: 200px; display: block; border-radius: 5px; margin-top: 2px; text-align: center; background-color: rgb(126, 45, 255); font-family: \"微软雅黑\"; font-size: 18px; line-height: 30px; color: white; } JavaScript: window.onload = function() { draw(); var aTag = document.getElementsByTagName(\"a\"); console.log(aTag); aTag[0].onclick=function() { draw(); }; } function draw() { var width = 200; var height = 60; drawImage(width, height); } /**生成一个随机数**/ function randomNum(min, max) { return Math.floor(Math.random() * (max - min) + min); } /**生成一个随机色**/ function randomColor(min, max) { var r = randomNum(min, max); var g = randomNum(min, max); var b = randomNum(min, max); return \"rgb(\" + r + \",\" + g + \",\" + b + \")\"; } function drawImage(width, height) { //获取dom对象 var dom = document.getElementById(\"validate\"); dom.height = height; dom.width = width; //获取绘图对象 var context = dom.getContext(\"2d\"); //绘制矩形框 context.strokeStyle = \"black\"; context.strokeRect(0, 0, width, height); var str = \"0123456789abcdefghijklmnpqrstuvwxyz\".toUpperCase(); for (var i = 0; i &lt; 5; i++) { var index = Math.floor(Math.random() * 35) var size = Math.floor(Math.random() * 20); //绘制文字 context.font = \"30px 微软雅黑\"; context.fillStyle = randomColor(50, 160); var deg = randomNum(-45, 45); var x=i * 35 + 20; var y=size + 30; //修改坐标原点和旋转弧度 context.translate(x, y); context.rotate(deg * Math.PI / 180); context.fillText(str[index], 0, 0); context.stroke(); //恢复坐标原点和旋转角度 context.rotate(-deg * Math.PI / 180); context.translate(-x, -y); } //绘制干扰线 for (var i = 0; i &lt; 20; i++) { var startX = randomNum(0, width) var startY = Math.floor(Math.random() * height / 2) var endX = Math.floor(Math.random() * width) var endY = Math.floor(Math.random() * height) context.strokeStyle = randomColor(0, 255); context.beginPath(); context.moveTo(startX, startY); context.lineTo(endX, endY); context.stroke(); } //绘制干扰点 for (var i = 0; i &lt; 100; i++) { var startX = Math.floor(Math.random() * 200) var startY = Math.floor(Math.random() * 60) context.moveTo(startX, startY); context.lineTo(startX + 2, startY + 2); context.strokeStyle = randomColor(50, 160); context.stroke(); } }","path":"2017/10/22/validateImage/","date":"10-22","excerpt":""},{"title":"工具及、知识点及外链收集","text":"苏飞论坛–生成http请求代码,json校验,在线生成二维码，在线执行JS,长字符串拼接代码，URL分析，IP归属地查询，JSON生成C#类代码; Hexo博客个性化设置 Hexo-Material主题设置 ABP系列文章 GIS相关文章-我也是个傻瓜 搭建Hexo博客 酷播云-网页播放器、各种技术教程 网页播放器源码 js播放器插件 Media Element 孟坤实验室-好玩的 Html 作品 孟坤博客 完美者-各种精品软件、文章 在docker中运行ASP.NET Core Web API应用程序","path":"2017/10/14/ToolsNotes/","date":"10-14","excerpt":""},{"title":"爬虫初探","text":"爬虫简介网络爬虫(又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者)，是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁，自动索引，模拟程序或者蠕虫。 下载htmlhtmlHelper: using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Net; using System.Text; using System.Threading.Tasks; namespace Ruanmou.Crawler { /// &lt;summary> /// /// &lt;/summary> public class HttpHelper { private static Logger logger = new Logger(typeof(HttpHelper)); /// &lt;summary> /// 根据url下载内容 之前是GB2312 /// &lt;/summary> /// &lt;param name=\"url\">&lt;/param> /// &lt;returns>&lt;/returns> public static string DownloadUrl(string url) { return DownloadHtml(url, Encoding.UTF8); } /// &lt;summary> /// 下载html /// HttpWebRequest功能比较丰富，WebClient使用比较简单 /// &lt;/summary> /// &lt;param name=\"url\">&lt;/param> /// &lt;returns>&lt;/returns> public static string DownloadHtml(string url, Encoding encode) { string html = string.Empty; try { HttpWebRequest request = HttpWebRequest.Create(url) as HttpWebRequest;//模拟请求 request.Timeout = 30 * 1000;//设置30s的超时 request.UserAgent = \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\"; request.ContentType = \"text/html; charset=utf-8\"; using (HttpWebResponse response = request.GetResponse() as HttpWebResponse)//发起请求 { if (response.StatusCode != HttpStatusCode.OK) { logger.Warn(string.Format(\"抓取{0}地址返回失败,response.StatusCode为{1}\", url, response.StatusCode)); } else { try { StreamReader sr = new StreamReader(response.GetResponseStream(), encode); html = sr.ReadToEnd();//读取数据 sr.Close(); } catch (Exception ex) { logger.Error(string.Format($\"DownloadHtml抓取{url}失败\"), ex); html = null; } } } } catch (System.Net.WebException ex) { if (ex.Message.Equals(\"远程服务器返回错误: (306)。\")) { logger.Error(\"远程服务器返回错误: (306)。\", ex); html = null; } } catch (Exception ex) { logger.Error(string.Format(\"DownloadHtml抓取{0}出现异常\", url), ex); html = null; } return html; } } } HtmlAgilityPack解析Html商品抓取 using HtmlAgilityPack; using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Net; using System.Text; using System.Threading.Tasks; using Newtonsoft.Json; using Ruanmou.Crawler.DataService; using Ruanmou.Crawler.Model; namespace Ruanmou.Crawler { /// &lt;summary> /// 商品抓取 /// http://www.w3school.com.cn/xpath/index.asp XPATH语法 /// &lt;/summary> public class CommoditySearch : ISearch { private Logger logger = new Logger(typeof(CommoditySearch)); private WarnRepository warnRepository = new WarnRepository(); private CommodityRepository commodityRepository = new CommodityRepository(); private Category category = null; public CommoditySearch(Category _category) { category = _category; } public void Crawler() { try { if (string.IsNullOrEmpty(category.Url)) { warnRepository.SaveWarn(category, string.Format(\"Url为空,Name={0} Level={1} Url={2}\", category.Name, category.CategoryLevel, category.Url)); return; } string html = HttpHelper.DownloadUrl(category.Url);//下载html HtmlDocument doc = new HtmlDocument(); doc.LoadHtml(html);//加载html string pageNumberPath = @\"//*[@id='J_topPage']/span/i\"; HtmlNode pageNumberNode = doc.DocumentNode.SelectSingleNode(pageNumberPath); if (pageNumberNode != null) { string sNumber = pageNumberNode.InnerText; for (int i = 1; i &lt; int.Parse(sNumber) + 1; i++) { string pageUrl = string.Format(\"{0}&amp;page={1}\", category.Url, i); try { List&lt;Commodity> commodityList = GetCommodityList(category, pageUrl.Replace(\"&amp;page=1&amp;\", string.Format(\"&amp;page={0}&amp;\", i))); //commodityRepository.SaveList(commodityList); } catch (Exception ex)//保证一页的错误不影响另外一页 { logger.Error(\"Crawler的commodityRepository.SaveList(commodityList)出现异常\", ex); } } } //string fristPath = \"//*[@id='J_bottomPage']/span[1]/a\"; //HtmlNodeCollection noneNodeList = doc.DocumentNode.SelectNodes(fristPath);//xPath分析 //if (noneNodeList == null) //{ // warnRepository.SaveWarn(category, string.Format(\"分页数据为空,Name={0} Level={1} Url={2}\", category.Name, category.CategoryLevel, category.Url)); // return; //} //string pageUrl = null; //foreach (var node in noneNodeList) //{ // string sNum = node.InnerHtml; // if (sNum.Equals(\"1\")) // { // pageUrl = node.Attributes[\"href\"].Value.Replace(\"&amp;amp;\", \"&amp;\"); // if (!pageUrl.StartsWith(\"http://\")) // pageUrl = string.Format(\"http://list.jd.com{0}\", pageUrl); // break; // } //} //string sMaxPageNumPath = \"//*[@id='J_bottomPage']/span[2]/em[1]/b\"; //HtmlNode sMaxPageNumPathNode = doc.DocumentNode.SelectSingleNode(sMaxPageNumPath); //string sMaxPageNum = sMaxPageNumPathNode.InnerHtml; //for (int i = 1; i &lt; int.Parse(sMaxPageNum) + 1; i++) //{ // try // { // List&lt;Commodity> commodityList = GetCommodityList(category, pageUrl.Replace(\"&amp;page=1&amp;\", string.Format(\"&amp;page={0}&amp;\", i))); // commodityRepository.SaveList(commodityList); // } // catch (Exception ex)//保证一页的错误不影响另外一页 // { // logger.Error(\"Crawler的commodityRepository.SaveList(commodityList)出现异常\", ex); // } //} } catch (Exception ex) { logger.Error(\"CrawlerMuti出现异常\", ex); warnRepository.SaveWarn(category, string.Format(\"出现异常,Name={0} Level={1} Url={2}\", category.Name, category.CategoryLevel, category.Url)); } } private List&lt;Commodity> GetCommodityList(Category category, string url) { string html = HttpHelper.DownloadUrl(url); List&lt;Commodity> commodityList = new List&lt;Commodity>(); try { if (string.IsNullOrEmpty(html)) return commodityList; HtmlDocument doc = new HtmlDocument(); doc.LoadHtml(html); string liPath = \"//*[@id='plist']/ul/li\"; HtmlNodeCollection noneNodeList = doc.DocumentNode.SelectNodes(liPath); if (noneNodeList == null || noneNodeList.Count == 0) { warnRepository.SaveWarn(category, string.Format(\"GetCommodityList商品数据为空,Name={0} Level={1} category.Url={2} url={3}\", category.Name, category.CategoryLevel, category.Url, url)); return commodityList; } foreach (var node in noneNodeList) { HtmlDocument docChild = new HtmlDocument(); docChild.LoadHtml(node.OuterHtml); Commodity commodity = new Commodity() { CategoryId = category.Id }; string urlPath = \"//*[@class='p-name']/a\"; HtmlNode urlNode = docChild.DocumentNode.SelectSingleNode(urlPath); if (urlNode == null) { continue; } commodity.Url = urlNode.Attributes[\"href\"].Value; if (!commodity.Url.StartsWith(\"http:\")) commodity.Url = \"http:\" + commodity.Url; string sId = Path.GetFileName(commodity.Url).Replace(\".html\", \"\"); commodity.ProductId = long.Parse(sId); //*[@id=\"plist\"]/ul/li[1]/div/div[3]/a/em string titlePath = \"//*[@class='p-name']/a/em\"; HtmlNode titleNode = docChild.DocumentNode.SelectSingleNode(titlePath); if (titleNode == null) { //Log.Error(titlePath); continue; } commodity.Title = titleNode.InnerText; string iamgePath = \"//*[@class='p-img']/a/img\"; HtmlNode imageNode = docChild.DocumentNode.SelectSingleNode(iamgePath); if (imageNode == null) { continue; } //前后不一 if (imageNode.Attributes.Contains(\"src\")) commodity.ImageUrl = imageNode.Attributes[\"src\"].Value; else if (imageNode.Attributes.Contains(\"original\")) commodity.ImageUrl = imageNode.Attributes[\"original\"].Value; else if (imageNode.Attributes.Contains(\"data-lazy-img\")) commodity.ImageUrl = imageNode.Attributes[\"data-lazy-img\"].Value; else { continue; } if (!commodity.ImageUrl.StartsWith(\"http:\")) commodity.ImageUrl = \"http:\" + commodity.ImageUrl; string pricePath = \"//*[@class='p-price']/strong/i\"; HtmlNode priceNode = docChild.DocumentNode.SelectSingleNode(pricePath); if (priceNode == null) { continue; } else { } commodityList.Add(commodity); } Console.WriteLine(\"{0}一共获取了{1}条数据\", url, commodityList.Count); } catch (Exception ex) { logger.Error(string.Format(\"GetCommodityList出现异常,url={0}\", url), ex); } return GetCommodityPrice(category, commodityList); } /// &lt;summary> /// 获取商品价格 /// &lt;/summary> /// &lt;param name=\"commodityList\">&lt;/param> /// &lt;returns>&lt;/returns> private List&lt;Commodity> GetCommodityPrice(Category category, List&lt;Commodity> commodityList) { try { if (commodityList == null || commodityList.Count() == 0) return commodityList; StringBuilder sb = new StringBuilder(); //sb.Append(@\"http://p.3.cn/prices/mgets?my=list_price&amp;type=1&amp;area=1_72_4137&amp;skuIds=\"); //sb.Append(string.Join(\"%2C\", commodityList.Select(c => string.Format(\"J_{0}\", c.ProductId)))); // sb.AppendFormat(\"http://p.3.cn/prices/mgets?callback=jQuery1069298&amp;type=1&amp;area=1_72_4137_0&amp;skuIds={0}&amp;pdbp=0&amp;pdtk=&amp;pdpin=&amp;pduid=1945966343&amp;_=1469022843655\", string.Join(\"%2C\", commodityList.Select(c => string.Format(\"J_{0}\", c.ProductId)))); string html = HttpHelper.DownloadUrl(sb.ToString()); if (string.IsNullOrWhiteSpace(html)) { logger.Warn(string.Format(\"获取url={0}时获取的html为空\", sb.ToString())); } html = html.Substring(html.IndexOf(\"(\") + 1); html = html.Substring(0, html.LastIndexOf(\")\")); List&lt;CommodityPrice> priceList = JsonConvert.DeserializeObject&lt;List&lt;CommodityPrice>>(html); commodityList.ForEach(c => c.Price = priceList.FirstOrDefault(p => p.id.Equals(string.Format(\"J_{0}\", c.ProductId))).p); //commodityList.ForEach(c => Console.WriteLine(\" Title={0} ImageUrl={1} Url={2} Price={3} Id={4}\", c.Title, c.ImageUrl, c.Url, c.Price, c.Id)); } catch (Exception ex) { logger.Error(\"GetCommodityPrice出现异常\", ex); } return commodityList; } } } 完整项目地址","path":"2017/10/14/Crawler/","date":"10-14","excerpt":""},{"title":"使用远程Git仓库","text":"学习自廖雪峰的Git教程 创建远程仓库由于githbub创建私有库是收费的,所以我使用了码云来创建私有库。 在码云创建好仓库后将要进行以下操作: 创建ssh-key: ssh-keygen -t rsa -C \"youremail@example.com\" 替换为自己的邮箱即可，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 在码云添加key 登录码云，在右上角头像的地方点击设置，选择SSH公钥,填上任意标题，在公钥文本框里粘贴id_rsa.pub文件的内容，添加ssh key。 关联远程仓库执行如下命令: $ git remote add origin git@gitee.com:用户名/仓库名.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，假如有两个远程库，比如既想推送到码云，又想推送到github就可以用不同的名称区分。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从远程仓库克隆假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 创建好远程仓库后，使用如下命令克隆: $ git clone git@gitee.com:用户名/仓库名.git Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。","path":"2017/09/28/remotegit/","date":"09-28","excerpt":""},{"title":"Git使用过程中遇到的问题","text":"提示 Please tell me who you are. 需要识别用户名和邮箱，必要时可在config后面加上--global设置全局 git config user.name \"someone\" git config user.email \"someone@someplace.com\" HttpRequestException encountered解决方法 网上查了一下发现是Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器，才行。https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/","path":"2017/09/26/GitErrors/","date":"09-26","excerpt":""},{"title":"创建本地版本库及新增、修改、提交和回退","text":"学习自廖雪峰的Git教程 创建版本库 创建目录 $ mkdir mygit $ cd mygit 初始化git仓库 $ git init 添加文件到版本库 新建一个文本文件readme.txt并写入内容: 新建ReadMe文件 执行命令添加到暂存区: $ git add readme.txt 提交文件到本地仓库: $ git commit -m \"学习git\" git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 版本回退与前进修改文件将readme.txt文件内容修改为: 第一次修改ReadMe文件 执行命令添加到暂存区: $ git add readme.txt 查看仓库状态执行git status查看仓库状态: $ git status # On branch master # Changes not staged for commit: # (use \"git add &lt;file>...\" to update what will be committed) # (use \"git checkout -- &lt;file>...\" to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use \"git add\" and/or \"git commit -a\") 上面显示的结果表示readme.txt被修改,已经添加到暂存区但还未提交. 查看修改内容执行命令： $ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -新建ReadMe文件 +第一次修改ReadMe文件 提交修改内容： $ git commit -m \"提交第一次修改\" 版本回退再修改一次readme.txt文件内容为: 第二次修改了 直接提交: $ git add readme.txt $ git commit -m \"提交第二次修改\" 查看版本历史记录$ git log commit 20854f06f31ab068ff622d84105af477c7d4b05f Author: TaffyBlog &lt;738840255@qq.com> Date: Tue Sep 26 21:39:38 2017 +0800 提交第二次修改 commit a85095bb608839338c5dc4e38d849ad5e27aabee Author: TaffyBlog &lt;738840255@qq.com> Date: Tue Sep 26 21:28:25 2017 +0800 提交第一次修改 commit da836ac4bd5085f7559aa41298cef47c6108f1c1 Author: TaffyBlog &lt;738840255@qq.com> Date: Tue Sep 26 21:27:44 2017 +0800 学习git git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是“提交第二次修改”，上一次是“提交第一次修改”，最早的一次是“学习git”。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： $ git log --pretty=oneline 20854f06f31ab068ff622d84105af477c7d4b05f 提交第二次修改 a85095bb608839338c5dc4e38d849ad5e27aabee 提交第一次修改 da836ac4bd5085f7559aa41298cef47c6108f1c1 学习git 需要友情提示的是，你看到的一大串类似20854f…..d4b05f的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别 回退到上一个版本$ git reset --hard HEAD^ HEAD is now at a85095b 提交第一次修改 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交20854f0…..7d4b05f，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 版本前进 查看commitid $ git reflog a85095b HEAD@{0}: reset: moving to HEAD^ 20854f0 HEAD@{1}: commit: 提交第二次修改 a85095b HEAD@{2}: commit: 提交第一次修改 da836ac HEAD@{3}: commit: 学习git 可以看到最后一次修改的commitid是20854f0,那么就可以将当前版本指向此版本了:$ git reset --hard 20854f0 HEAD is now at 20854f0 提交第二次修改 这样，被回退的版本就又回来了。 撤销修改未添加到暂存区 将readme.txt文件内容修改为: 第二次修改了呵呵呵 执行命令撤销工作区的修改: $ git checkout -- readme.txt 再查看readme.txt文件内容:第二次修改了 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 已添加到暂存区未提交执行命令： $ git reset HEAD readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 已提交使用前面的版本回退 文件删除删除readme.txt文件： $ rm readme.txt $ git add readme.txt $ git commit -m \"删除readme\" 现在只是删除还未提交，如果是误删，则使用git checkout -- readme.txt命令将版本库的文件放回来,如果已提交则使用版本回退。","path":"2017/09/26/locationgit/","date":"09-26","excerpt":""},{"title":"关于WebAPI的创建、调用、权限验证和跨域问题","text":"路由配置WebApi的路由配置位于项目文件夹App_Start下的WebApiConfig文件中,以下是默认的配置: public static class WebApiConfig { public static void Register(HttpConfiguration config) { // Web API 配置和服务 // Web API 路由 config.MapHttpAttributeRoutes(); config.Routes.MapHttpRoute( name: \"DefaultApi\", routeTemplate: \"api/{controller}/{id}\", defaults: new { id = RouteParameter.Optional } ); } } 可以看出，WebApi默认的路由配置和MVC默认的路由配置有所不同，没有了{action}配置节点，这是因为WebApi默认遵循Restfull风格，例如默认的ValuesController: public class ValuesController : ApiController { // GET api/values public IEnumerable&lt;string> Get() { return new string[] { \"value1\", \"value2\" }; } // GET api/values/5 public string Get(int id) { return \"value\"; } // POST api/values public void Post([FromBody]string value) { } // PUT api/values/5 public void Put(int id, [FromBody]string value) { } // DELETE api/values/5 public void Delete(int id) { } } 此控制器有:Get、Post、Put、Delete方法，也正好对应了Http请求的这四种谓词，以及数据的查询、修改、新增、删除。因此在默认配置中也就将其省略了，不过我们也可以按照自己的习惯修改配置。 JS调用WebApiGet请求普通方法调用public string Get(string userName) { return \"返回结果:\"+userName; } 前台代码: &lt;input id=\"btnGet1\" type=\"button\" value=\"button\" /> &lt;script type=\"text/javascript\"> $(function () { $(\"#btnGet1\").click(function () { $.ajax({ url: \"/api/mywebapi/\", type: \"get\", data: { \"userName\": \"这是名字\" }, success: function (data) { console.log(data); }, dataType: \"json\" }) }); }); &lt;/script> 输出结果: jscommon.js:1 Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user's experience. For more help, check https://xhr.spec.whatwg.org/. send @ jscommon.js:1 ajax @ jscommon.js:1 (anonymous) @ content.js:10 返回结果:这是名字 传递对象调用后台代码: public string Get([FromUri]User user) { return \"返回结果:\" + user.UserId+\"\\n\"+user.UserName+\"\\n\"+user.Age; } js: &lt;script type=\"text/javascript\"> $(function () { var user = { UserName: \"张三\", UserId:1,Age:18}; $(\"#btnGet1\").click(function () { $.ajax({ url: \"/api/mywebapi/\", type: \"get\", data: { user }, success: function (data) { console.log(data); }, dataType: \"json\" }) }); }); &lt;/script> 输出结果: Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user's experience. For more help, check https://xhr.spec.whatwg.org/. send @ jscommon.js:1 ajax @ jscommon.js:1 (anonymous) @ content.js:10 返回结果:1 张三 18 后台除了用FromUri，也可以用Request.QueryString接收。 Post请求后台方法: [HttpPost] public string Post([FromBody]int id) { return \"传入的Id值为:\"+id; } 前台调用: &lt;script src=\"~/Scripts/jquery-1.10.2.min.js\">&lt;/script> &lt;script type=\"text/javascript\"> $(function () { $(\"#btnGet1\").click(function () { $.ajax({ url: \"/api/mywebapi/\", type: \"post\", data: { \"\":5 }, success: function (data) { console.log(data); }, dataType: \"json\" }) }); }); &lt;/script> &lt;input id=\"btnGet1\" type=\"button\" value=\"调用\" /> 注意事项 对于Get请求，要么方法名以Get开头，要么给方法加上HttpGet特性，否则方法不会被识别为Get请求方法。 对于Post请求，如果只有一个参数传入，那么在构造传入参数时不能设置Key（示例在上面）,在后台接收时也必须加上FromBody才能自动匹配接收，否则就只能通过Request.Form来接收。 权限验证basic认证步骤定义一个特性继承自AuthorizeAttribute,并覆写两个方法 public class MyAuthorizeAttribute:AuthorizeAttribute { // // 摘要: // 为操作授权时调用。 // // 参数: // actionContext: // 上下文。 // // 异常: // T:System.ArgumentNullException: // 上下文参数为 null。 public override void OnAuthorization(HttpActionContext actionContext) { var authorization = actionContext.Request.Headers.Authorization; if (actionContext.ActionDescriptor.GetCustomAttributes&lt;AllowAnonymousAttribute>(true).Count != 0 || actionContext.ActionDescriptor.ControllerDescriptor.GetCustomAttributes&lt;AllowAnonymousAttribute>(true).Count != 0) { base.OnAuthorization(actionContext); } else if (authorization != null &amp;&amp; authorization.Parameter != null) { //用户验证逻辑 if (ValidateTicket(authorization.Parameter)) { base.IsAuthorized(actionContext); } else { this.HandleUnauthorizedRequest(actionContext); } } else { this.HandleUnauthorizedRequest(actionContext); } } // // 摘要: // 处理授权失败的请求。 // // 参数: // actionContext: // 上下文。 protected override void HandleUnauthorizedRequest(System.Web.Http.Controllers.HttpActionContext actionContext) { var challengeMessage = new System.Net.Http.HttpResponseMessage(System.Net.HttpStatusCode.Unauthorized);//告诉浏览器要验证 challengeMessage.Headers.Add(\"WWW-Authenticate\", \"Basic\");//权限信息放在basic //throw new System.Web.Http.HttpResponseException(challengeMessage); base.HandleUnauthorizedRequest(actionContext);//返回没有授权 } private bool ValidateTicket(string encryptTicket) { //解密Ticket var strTicket = FormsAuthentication.Decrypt(encryptTicket).UserData; return string.Equals(strTicket, string.Format(\"{0}&amp;{1}\", \"Admin\", \"123456\"));//应该分拆后去数据库验证 } } 在需要权限验证的类或者方法上加上此特性每次调用此类的方法时就会进入MyAuthorizeAttribute的OnAuthorization方法。 [MyAuthorize] public class MyWebApiController : ApiController { public string Get(string userName) { return \"返回结果:\"+userName; } public string Get([FromUri]User user) { return \"返回结果:\" + user.UserId+\"\\n\"+user.UserName+\"\\n\"+user.Age; } [HttpPost] public string Post([FromBody]int id) { return \"传入的Id值为:\"+id; } } 定义用户登录方法 #region 用户登陆 [AllowAnonymous] [HttpGet] public string Login(string account, string password) { if (account.Equals(\"Admin\") &amp;&amp; password.Equals(\"123456\")) { FormsAuthenticationTicket ticketObject = new FormsAuthenticationTicket(0, account, DateTime.Now, DateTime.Now.AddHours(1), true, string.Format(\"{0}&amp;{1}\", account, password), FormsAuthentication.FormsCookiePath); var result = new { Result = true, Ticket = FormsAuthentication.Encrypt(ticketObject) }; return JsonConvert.SerializeObject(result); } else { var result = new { Result = false }; return JsonConvert.SerializeObject(result); } } #endregion 对于不需要权限验证的方法加上[AllowAnonymous]特性。测试调用不登陆直接调用方法结果如下: 登录后调用前台登录代码: &lt;script type=\"text/javascript\"> $(function () { var ticket = \"\"; $(\"#btnLogin\").click(function () { $.ajax({ url: \"/api/mywebapi/Login\", type: \"get\", data: { \"Account\": \"Admin\", \"Password\": \"123456\" }, success: function (data) { var result = JSON.parse(data); if (result.Result) { ticket = result.Ticket; alert(result.Ticket); } else { alert(\"failed\"); } }, dataType: \"json\" }) }); $(\"#btnGet1\").click(function () { $.ajax({ url: \"/api/mywebapi/\", type: \"post\", data: { \"\": 5 }, beforeSend: function (XHR) { //注意BasicAuth后面有空格，在后台被拆分为AuthorizationHeaderValue的两个属性 XHR.setRequestHeader(\"Authorization\", \"BasicAuth \" + ticket) }, success: function (data) { console.log(data); }, dataType: \"json\" }) }); }); &lt;/script> &lt;input id=\"btnLogin\" type=\"button\" value=\"登录\" /> &lt;input id=\"btnGet1\" type=\"button\" value=\"调用\" /> 登录的效果： 登录后调用的效果: 配置跨域访问前台前台只需加上一个标识即可: //允许跨域 jQuery.support.cors = true; 后台在配置WebApi路由的地方加上如下配置: //表示允许所有的跨域访问 config.EnableCors(new EnableCorsAttribute(\"*\",\"*\",\"*\")); 需要引用命名空间：System.Web.Http.Cors。","path":"2017/09/20/webapi/","date":"09-20","excerpt":""},{"title":"HTTP协议与WebSocket","text":"HTTP协议简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP协议是无状态协议。 HTTP消息结构请求消息结构 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本. 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息,从第二行起为请求头部,HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的3. 浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的,即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 结构图如下: 示例如下: GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi 此示例中无数据部分 响应消息结构HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成，第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息，空行后面的部分为响应正文。 结构图如下: 示例如下: HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: Apache Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: \"34aa387-d-1568eb00\" Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain 输出结果： Hello World! My payload includes a trailing CRLF. Http协议特点 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快，不过也可以实现服务器集群，不同的服务器都可以以相同的逻辑处理相同的请求。 WebSocket协议有时候需要服务器与浏览器实现双工通信；即除了浏览器主动向服务器请求之外，服务器也需要主动向客户端发送消息，而http协议是无连接、无状态的，在一次请求结束后服务器和客户端就会断开连接，因此，通过http协议通常是用ajax轮询以及LongPool，过一段时间又向服务器询问是否需要改变界面数据。 这种方式比较消耗服务器资源。 使用WebSocket浏览器必须支持Html5,服务器必须是IIS8以上。 用WebSocket实现的简单聊天室前台代码如下: &lt;div class=\"jumbotron\"> &lt;input id=\"txt_Ip\" type=\"text\" />&amp;nbsp; &lt;input id=\"btnConnect\" class=\"btn btn-primary btn-lg\" type=\"button\" value=\"连接\" /> &lt;input id=\"btnClose\" type=\"button\" value=\"关闭\" />&lt;br /> &lt;span id=\"tips\">&lt;/span> &lt;input id=\"txt_Message\" type=\"text\" />&amp;nbsp; &lt;input id=\"btnSend\" class=\"btn btn-primary btn-lg\" type=\"button\" value=\"发送\" /> &lt;/div> &lt;div id=\"view\"> &lt;ul>&lt;/ul> &lt;/div> &lt;script type=\"text/javascript\"> $(function () { var url = \"ws://localhost:63151/MyWebSocketHandler.ashx\"; var ws; function connect() { var userName = $(\"#txt_Ip\").val(); url = url + \"?UserName=\" + userName; $(\"#tips\").val(\"正在连接...\"); ws = new WebSocket(url); //连接打开 ws.onopen = function () { $(\"#tips\").val(\"已连接\"); } //接收到消息 ws.onmessage = function (evt) { $(\"#view ul\").append(\"&lt;li>\" + evt.data + \"&lt;/li>\"); }; //发生异常 ws.onerror = function (evt) { $(\"#tips\").val(JSON.stringify(evt)); } //关闭 ws.onclose = function () { $(\"#tips\").val(\"已经关闭\"); } } $(\"#btnSend\").click(function () { if (ws.readyState == WebSocket.OPEN) { ws.send($(\"#txt_Message\").val()); } else { $(\"#tips\").val(\"已经关闭\"); } }); $(\"#btnClose\").click(function () { ws.close(); }); $(\"#btnConnect\").click(function () { connect(); }); }); &lt;/script> 后台一般处理程序代码如下: public class MyWebSocketHandler : IHttpHandler, System.Web.SessionState.IRequiresSessionState { private string _UserName = \"\"; public void ProcessRequest(HttpContext context) { //是否是AspNetWebSocket请求 if (context.IsWebSocketRequest) { this._UserName = context.Request.QueryString[\"UserName\"]; //传入委托处理AspNetWebSocket请求 context.AcceptWebSocketRequest(ProcessChat); } else { context.Response.Write(\"Test Handler\"); } } private async Task ProcessChat(AspNetWebSocketContext context) { WebSocket socket = context.WebSocket; CancellationToken cancellationToken = new CancellationToken(); ChatManager.AddUser(_UserName, socket); //某人登陆后，给群里其他人发 登陆消息 await ChatManager.SendMessage(cancellationToken, $\"{DateTime.Now.ToString(\"yyyyMMdd-HHmmss:fff\")} {this._UserName} 进入聊天室\"); while (socket.State == WebSocketState.Open) { ArraySegment&lt;byte> buffer = new ArraySegment&lt;byte>(new byte[2048]); WebSocketReceiveResult result = await socket.ReceiveAsync(buffer, cancellationToken); if (result.MessageType == WebSocketMessageType.Close) //如果输入帧为取消帧，发送close命令 { //放在前面移除和发消息， 因为直接关浏览器会导致CloseAsync异常 ChatManager.RemoveUser(_UserName); await ChatManager.SendMessage(cancellationToken, $\"{DateTime.Now.ToString(\"yyyyMMdd-HHmmss:fff\")} {this._UserName} 离开聊天室\"); await socket.CloseAsync(WebSocketCloseStatus.NormalClosure, String.Empty, cancellationToken); } else//获取字符串 { string userMsg = Encoding.UTF8.GetString(buffer.Array, 0, result.Count); string content = $\"{DateTime.Now.ToString(\"yyyyMMdd-HHmmss:fff\")} {this._UserName} 发送了：{userMsg}\"; await ChatManager.SendMessage(cancellationToken, content); } } } public bool IsReusable { get { return false; } } } public class ChatManager { private static ConcurrentDictionary&lt;string, WebSocket> _UserDictionary = new ConcurrentDictionary&lt;string, WebSocket>(); public static void AddUser(string name, WebSocket socket) { _UserDictionary[name] = socket; } public static void RemoveUser(string name) { WebSocket socket = null; //_UserDictionary.TryRemove(name, out WebSocket socket); _UserDictionary.TryRemove(name, out socket); } public static async Task SendMessage(CancellationToken cancellationToken, string content) { ArraySegment&lt;byte> buffer = new ArraySegment&lt;byte>(new byte[2048]); buffer = new ArraySegment&lt;byte>(Encoding.UTF8.GetBytes(content)); foreach (var socket in _UserDictionary.Select(d => d.Value)) { await socket.SendAsync(buffer, WebSocketMessageType.Text, true, cancellationToken); } } } 效果图:","path":"2017/09/17/httpAndWebSocket/","date":"09-17","excerpt":""},{"title":"lambda表达式树解析并拼装Sql","text":"自定义解析器在ef中，我们可以使用lambda表达式进行数据库操作，但是最后到数据库执行的一定是sql语句，而表达式树解析正好可以满足这个需求。 示例如下: 解析器需要继承ExpressionVisitor,这是一个抽象类，定义了许多虚方法以供我们重写，本例中重写了VisitBinary、VisitMember、VisitMethodCall方法；每个表达式解析完成后自动解析下一个表达式，直到遍历解析完整个表达式树。 public class ConditionBuilderVisitor : ExpressionVisitor { private Stack&lt;string> _StringStack = new Stack&lt;string>(); public string Condition() { string condition = string.Concat(this._StringStack.ToArray()); this._StringStack.Clear(); return condition; } /// &lt;summary> /// 如果是二元表达式 /// &lt;/summary> /// &lt;param name=\"node\">&lt;/param> /// &lt;returns>&lt;/returns> protected override Expression VisitBinary(BinaryExpression node) { if (node == null) throw new ArgumentNullException(\"BinaryExpression\"); this._StringStack.Push(\")\"); base.Visit(node.Right);//解析右边 this._StringStack.Push(\" \" + node.NodeType.ToSqlOperator() + \" \"); base.Visit(node.Left);//解析左边 this._StringStack.Push(\"(\"); return node; } /// &lt;summary> /// 如果是属性或字段 /// &lt;/summary> /// &lt;param name=\"node\">&lt;/param> /// &lt;returns>&lt;/returns> protected override Expression VisitMember(MemberExpression node) { if (node == null) throw new ArgumentNullException(\"MemberExpression\"); this._StringStack.Push(\" [\" + node.Member.Name + \"] \"); return node; } /// &lt;summary> /// 常量表达式 /// &lt;/summary> /// &lt;param name=\"node\">&lt;/param> /// &lt;returns>&lt;/returns> protected override Expression VisitConstant(ConstantExpression node) { if (node == null) throw new ArgumentNullException(\"ConstantExpression\"); this._StringStack.Push(\" '\" + node.Value + \"' \"); return node; } /// &lt;summary> /// 方法表达式 /// &lt;/summary> /// &lt;param name=\"m\">&lt;/param> /// &lt;returns>&lt;/returns> protected override Expression VisitMethodCall(MethodCallExpression m) { if (m == null) throw new ArgumentNullException(\"MethodCallExpression\"); string format; switch (m.Method.Name) { case \"StartsWith\": format = \"({0} LIKE {1}+'%')\"; break; case \"Contains\": format = \"({0} LIKE '%'+{1}+'%')\"; break; case \"EndsWith\": format = \"({0} LIKE '%'+{1})\"; break; case \"Equals\": format = \"({0} = '{1}')\"; break; default: throw new NotSupportedException(m.NodeType + \" is not supported!\"); } this.Visit(m.Object); this.Visit(m.Arguments[0]); string right = this._StringStack.Pop(); string left = this._StringStack.Pop(); this._StringStack.Push(String.Format(format, left, right)); return m; } } 扩展方法类: internal static class SqlOperator { /// &lt;summary> /// 扩展方法 转换运算符 /// &lt;/summary> /// &lt;param name=\"type\">&lt;/param> /// &lt;returns>&lt;/returns> internal static string ToSqlOperator(this ExpressionType type) { switch (type) { case (ExpressionType.AndAlso): case (ExpressionType.And): return \"AND\"; case (ExpressionType.OrElse): case (ExpressionType.Or): return \"OR\"; case (ExpressionType.Not): return \"NOT\"; case (ExpressionType.NotEqual): return \"&lt;>\"; case ExpressionType.GreaterThan: return \">\"; case ExpressionType.GreaterThanOrEqual: return \">=\"; case ExpressionType.LessThan: return \"&lt;\"; case ExpressionType.LessThanOrEqual: return \"&lt;=\"; case (ExpressionType.Equal): return \"=\"; default: throw new Exception(\"不支持该方法\"); } } } 测试一下: Expression&lt;Func&lt;StudentInfo, bool>> stuExpression = (stu) => stu.StuId > 10 &amp;&amp; stu.Address.Equals(\"北京\"); ConditionBuilderVisitor myVisitor = new ConditionBuilderVisitor(); myVisitor.Visit(stuExpression); Console.Write(myVisitor.Condition()); 输出结果为: (( [StuId] > 10 ) AND ( [Address] = ' 北京 '))","path":"2017/09/02/ExpressionVisitor/","date":"09-02","excerpt":""},{"title":"第一个.Net Core程序","text":"第一个.Net Core控制台应用程序 创建名为myapp的控制台应用程序 dotnet new console -o myapp 启动应用程序 dotnet run 执行结果如下: hello word 第一个ASP.NET Core应用程序 创建名为myapp的控制台应用程序 dotnet new mvc -o myapp 启动应用程序dotnet run 输出如下: warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[35] No XML encryptor configured. Key {78bfca8c-6031-4f57-acd4-9c7181ead0ee} may be persisted to storage in unencrypted form. Hosting environment: Production Content root path: /home/ytf/myapp Now listening on: http://localhost:5000 Application started. Press Ctrl+C to shut down. 访问http://localhost:5000即可进入此网站。 使用Visual Studio Code调试.Net Core程序 在联网状态下启动vscode,会自动安装OmniSharp和.NET Core Debugger。 打开调试面板，点击启动调试;会在项目中新建一个.vscode文件夹，以及launch.json、tasks.json两个配置文件。 配置launch.json 配置program节点:&quot;program&quot;: &quot;${workspaceRoot}/bin/Debug/netcoreapp2.0/项目名.dll&quot; 配置args节点用于测试：&quot;args&quot;: [&quot;哈哈哈哈&quot;]，args节点是Main函数的参数。","path":"2017/08/31/FirstCoreApp/","date":"08-31","excerpt":""},{"title":"lambda表达式树拼装","text":"lambda表达式树C# Lambda表达式树允许我们像处理数据（比如读取，修改）一样来处理Lambda表达式。也就是说我们可以动态地拼装和解析lambda表达式了。 拼装简单表达式树先拼装一个简单的表达式树： Expression&lt;Func&lt;int, int, int>> expression = (m, n) => m * n + 2; 按照运算符的优先级，此表达式计算的顺序应该是先mn，然后是mn的结果加2。在表达式树中，每一个二元运算符产生的结果是一个二元表达式(BinaryExpression),每一个参数都是参数表达式（ParameterExpression），常量是常量表达式(ConstantExpression)。 示意图如下: //参数 ParameterExpression parameterM = Expression.Parameter(typeof(int),\"m\"); ParameterExpression parameterN = Expression.Parameter(typeof(int),\"n\"); //m*n BinaryExpression binaryExpression = Expression.Multiply(parameterM, parameterN); //常量表达式 2 ConstantExpression constantExpression = Expression.Constant(2); //m*n + 2 BinaryExpression binary= Expression.Add(binaryExpression, constantExpression); //按照得到的表达式树创建lambda表达式 var lambda = Expression.Lambda&lt;Func&lt;int,int,int>>(binary, parameterM, parameterN); 得到的lambda结果为:(m, n) =&gt; ((m * n) + 2)。 对lambda调用Compile方法即可获取此表达式树对应的委托，调用Invoke方法即可执行。 int result = lambda.Compile()(5,8); 带属性、方法的表达式拼装建立一个StudentInfo类： public class StudentInfo { public int StuId { get; set; } public string StuName { get; set; } public string Address { get; set; } } 初始化一个StudentInfo,以及需要拼装的表达式为: StudentInfo studentInfo = new StudentInfo{StuId=11,StuName=\"呵呵大\",Address=\"北京\" }; Expression&lt;Func&lt;StudentInfo, bool>> stuExpression = (stu) => stu.StuId > 10&amp;&amp;stu.Address.Equals(\"北京\"); 按照运算符的优先级，此表达式先计算stu.StuId &gt; 10和stu.Address.Equals(&quot;北京&quot;)得到一个二元表达式和一个方法调用的表达式，然后计算AndAlso，得到最终的二元表达式。 具体步骤如下: //参数 stu ParameterExpression parameterExpression = Expression.Parameter(typeof(StudentInfo), \"stu\"); //属性 StuId MemberExpression memberExpression = Expression.Property(parameterExpression, \"StuId\"); //常量 10 ConstantExpression constantExpression = Expression.Constant(10); //stu.StuId > 10 BinaryExpression binaryExpression = Expression.GreaterThan(memberExpression,constantExpression); //属性 Address MemberExpression memberAddress = Expression.Property(parameterExpression, \"Address\"); //常量 北京 ConstantExpression constantAddress = Expression.Constant(\"北京\"); //调用方法 Equals MethodCallExpression methodCallExpression = Expression.Call(memberAddress, typeof(StudentInfo).GetMethod(\"Equals\"),constantAddress); //stu.StuId > 10 &amp;&amp; stu.Address.Equals(\"北京\") BinaryExpression expression = Expression.AndAlso(binaryExpression, methodCallExpression); //得到lambda表达式 var lambda = Expression.Lambda&lt;Func&lt;StudentInfo, bool>>(expression, parameterExpression).Compile(); 表达式树拼装实战用表达式树复制对象有StudentInfo和StudentInfoCopy类，属性都一样，现有一个StudentInfo类的一个实例，需要得到一个StudentInfoCopy类的实例： 硬编码 StudentInfo studentInfo = new StudentInfo{StuId=11,StuName=\"呵呵大\",Address=\"北京\" }; StudentInfoCopy studentInfoCopy = new StudentInfoCopy() { StuId=studentInfo.StuId, StuName=studentInfo.StuName, Address=studentInfo.Address }; 用反射 public class ReflectionMapper { /// &lt;summary> /// 反射 /// &lt;/summary> /// &lt;typeparam name=\"TIn\">&lt;/typeparam> /// &lt;typeparam name=\"TOut\">&lt;/typeparam> /// &lt;param name=\"tIn\">&lt;/param> /// &lt;returns>&lt;/returns> public static TOut Trans&lt;TIn, TOut>(TIn tIn) { TOut tOut = Activator.CreateInstance&lt;TOut>(); foreach (var itemOut in tOut.GetType().GetProperties()) { foreach (var itemIn in tIn.GetType().GetProperties()) { if (itemOut.Name.Equals(itemIn.Name)) { itemOut.SetValue(tOut, itemIn.GetValue(tIn)); break; } } } foreach (var itemOut in tOut.GetType().GetFields()) { foreach (var itemIn in tIn.GetType().GetFields()) { if (itemOut.Name.Equals(itemIn.Name)) { itemOut.SetValue(tOut, itemIn.GetValue(tIn)); break; } } } return tOut; } } 用序列化反序列化方式public class SerializeMapper { /// &lt;summary> /// 序列化反序列化方式 /// &lt;/summary> /// &lt;typeparam name=\"TIn\">&lt;/typeparam> /// &lt;typeparam name=\"TOut\">&lt;/typeparam> public static TOut Trans&lt;TIn, TOut>(TIn tIn) { return JsonConvert.DeserializeObject&lt;TOut>(JsonConvert.SerializeObject(tIn)); } } 使用表达式树方式/// &lt;summary> /// 生成表达式目录树 泛型缓存 /// &lt;/summary> /// &lt;typeparam name=\"TIn\">&lt;/typeparam> /// &lt;typeparam name=\"TOut\">&lt;/typeparam> public class ExpressionGenericMapper&lt;TIn, TOut>//ExpressionGenericMapper`2 { private static Func&lt;TIn, TOut> _FUNC = null; static ExpressionGenericMapper() { ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), \"p\"); List&lt;MemberBinding> memberBindingList = new List&lt;MemberBinding>(); foreach (var item in typeof(TOut).GetProperties()) { MemberExpression property = Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name)); MemberBinding memberBinding = Expression.Bind(item, property); memberBindingList.Add(memberBinding); } foreach (var item in typeof(TOut).GetFields()) { MemberExpression property = Expression.Field(parameterExpression, typeof(TIn).GetField(item.Name)); MemberBinding memberBinding = Expression.Bind(item, property); memberBindingList.Add(memberBinding); } MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray()); Expression&lt;Func&lt;TIn, TOut>> lambda = Expression.Lambda&lt;Func&lt;TIn, TOut>>(memberInitExpression, new ParameterExpression[] { parameterExpression }); _FUNC = lambda.Compile();//拼装是一次性的 } public static TOut Trans(TIn t) { return _FUNC(t); } } 其中，硬编码效率最高但是不灵活，反射和序列化效率低，因此表达式树方式最好。","path":"2017/08/31/Expression/","date":"08-31","excerpt":""},{"title":"在Ubuntu 16.04安装.Net Core","text":"安装步骤 切换到root用户 su - root 注册Microsoft Product key为可信任`bashcurl https://packages.microsoft.com/keys/microsoft.asc | gpg –dearmor &gt; microsoft.gpg sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg 3. ```bash sudo sh -c &#39;echo &quot;deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-xenial-prod xenial main&quot; &gt; /etc/apt/sources.list.d/dotnetdev.list&#39; 更新软件包 sudo apt-get update 安装.Net Core2.0 sudo apt-get install dotnet-sdk-2.0.0 执行命令dotnet --info可查看安装的.Net Core信息，也可检查安装是否成功 ~$ dotnet --info .NET Command Line Tools (2.0.0) Product Information: Version: 2.0.0 Commit SHA-1 hash: cdcd1928c9 Runtime Environment: OS Name: ubuntu OS Version: 16.04 OS Platform: Linux RID: ubuntu.16.04-x64 Base Path: /usr/share/dotnet/sdk/2.0.0/ Microsoft .NET Core Shared Framework Host Version : 2.0.0 Build : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d","path":"2017/08/30/installCore/","date":"08-30","excerpt":""},{"title":"控制反转/依赖注入（Unity容器使用）","text":"控制反转(IOC)概念控制反转(Inversion of Control，英文缩写为IoC)是一个重要的面向对象编程的法则来削减计算机程序的耦合问题，也是轻量级的Spring框架的核心。 控制反转一般分为两种类型，依赖注入(Dependency Injection，简称DI)和依赖查找(Dependency Lookup)。依赖注入应用比较广泛。是一种设计模式。 原理IOC模式，系统中通过引入实现了IOC模式的IOC容器，即可由IOC容器来管理对象的生命周期、依赖关系等，从而使得应用程序的配置和依赖性规范与实际的应用程序代码分开。其中一个特点就是通过文本的配置文件进行应用程序组件间相互关系的配置，而不用重新修改并编译具体的代码。 依赖注入组件不做定位查询，只提供普通的方法让容器去决定依赖关系。容器全权负责的组件的装配，它会把符合依赖关系的对象通过属性或者构造函数传递给需要的对象。通过属性注射依赖关系的做法称为设值方法注入或属性注入(Setter Injection)；将依赖关系作为构造函数参数传入的做法称为构造函数注入（Constructor Injection） Unity容器 示例介绍 项目结构如下图: 接口:IPhone(手机)、IPower（电源）、IMicrophone（麦克风）、IHeadphone（耳机） AndroidPhone、ApplePhone实现接口IPhone，Headphone、Microphone、Power类实现各自的接口 关键代码预览 IPhone: namespace Ioc.Interface { public interface IPhone { void Call(); IMicrophone iMicrophone { get; set; } IHeadphone iHeadphone { get; set; } IPower iPower { get; set; } } } IPower（电源）、IMicrophone（麦克风）、IHeadphone（耳机）： namespace Ioc.Interface { /// &lt;summary> /// 耳机 /// &lt;/summary> public interface IHeadphone { } /// &lt;summary> /// 麦克风 /// &lt;/summary> public interface IMicrophone { } /// &lt;summary> /// 电源 /// &lt;/summary> public interface IPower { } } AndroidPhone: namespace IocTest.Service { public class AndroidPhone:IPhone { [Dependency]//属性注入 public IMicrophone iMicrophone { get; set; } public IHeadphone iHeadphone { get; set; } public IPower iPower { get; set; } public AndroidPhone() { Console.WriteLine(\"{0}构造函数\", this.GetType().Name); } //[InjectionConstructor]//构造函数注入：默认找参数最多的构造函数 public AndroidPhone(IHeadphone headphone) { this.iHeadphone = headphone; Console.WriteLine(\"{0}带参数构造函数\", this.GetType().Name); } public void Call() { Console.WriteLine(\"{0}打电话\", this.GetType().Name); ; } [InjectionMethod]//方法注入 public void Init1234(IPower power) { this.iPower = power; } } } ApplePhone： namespace IocTest.Service { public class ApplePhone : IPhone { public ApplePhone() { Console.WriteLine($\"{this.GetType().Name}构造函数\"); } public IMicrophone iMicrophone { get; set; } public IHeadphone iHeadphone { get; set; } public IPower iPower { get; set; } public void Call() { Console.WriteLine($\"{this.GetType().Name}打电话\"); } } } Headphone、Microphone、Power: namespace IocTest.Service { public class Headphone : IHeadphone { public Headphone() { Console.WriteLine(\"Headphone 被构造\"); } } public class Microphone : IMicrophone { public Microphone() { Console.WriteLine(\"Microphone 被构造\"); } } public class Power : IPower { public Power() { Console.WriteLine(\"Power 被构造\"); } } } 以上代码中，仅在AndroidPhone类中使用了依赖注入。 代码直接注册方式直接在代码中使用Unity的方式如下: static void Main(string[] args) { //实例化容器 IUnityContainer container = new UnityContainer(); //注册类型 container.RegisterType&lt;IPhone, ApplePhone>(); container.RegisterType&lt;IHeadphone, Headphone>(); container.RegisterType&lt;IMicrophone, Microphone>(); container.RegisterType&lt;IPower, Power>(); //同一接口的不同实现取名以区分 container.RegisterType&lt;IPhone, AndroidPhone>(\"Android\"); //获取对象 var iphone = container.Resolve&lt;IPhone>(\"Android\"); iphone.Call(); } 使用依赖注入容器后，只要用特性标记为属性注入的，该属性会从已注册类型中创建实例给该属性； 标记为方法注入的则会调用该方法并从已注册类型中创建实例并赋值给参数传递；标记为构造函数注入或不标记的，都会调用Resolve方法所指向的已注册类型中构造函数参数最多的一个调用，并从已注册类型中初始化参数 推荐使用构造函数注入，因为这样避免了对代码的侵入性。 以上代码中在注册类型时依然有对实现类的依赖，因此这种方式使用依赖注入容器意义不大。 配置文件注册方式本例配置文件格式如下，核心在containers配置节，配置了注册的类型： &lt;configuration> &lt;configSections> &lt;section name=\"unity\" type=\"Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Microsoft.Practices.Unity.Configuration\"/> &lt;/configSections> &lt;unity> &lt;sectionExtension type=\"Microsoft.Practices.Unity.InterceptionExtension.Configuration.InterceptionConfigurationExtension, Microsoft.Practices.Unity.Interception.Configuration\"/> &lt;containers> &lt;container name=\"testContainer\"> &lt;register type=\"IocTest.Interface.IPhone,IocTest.Interface\" mapTo=\"IocTest.Service.ApplePhone, IocTest.Service\"/> &lt;register type=\"IocTest.Interface.IPhone,IocTest.Interface\" mapTo=\"IocTest.Service.AndroidPhone, IocTest.Service\" name=\"Android\"/> &lt;register type=\"IocTest.Interface.IMicrophone, IocTest.Interface\" mapTo=\"IocTest.Service.Microphone, IocTest.Service\"/> &lt;register type=\"IocTest.Interface.IHeadphone, IocTest.Interface\" mapTo=\"IocTest.Service.Headphone, IocTest.Service\"/> &lt;register type=\"IocTest.Interface.IPower, IocTest.Interface\" mapTo=\"IocTest.Service.Power, IocTest.Service\"/> &lt;/container> &lt;/containers> &lt;/unity> &lt;/configuration> 代码内容： ExeConfigurationFileMap fileMap = new ExeConfigurationFileMap(); //找配置文件的路径 fileMap.ExeConfigFilename = Path.Combine(AppDomain.CurrentDomain.BaseDirectory + \"Config\\\\UnityConfig.xml\"); Configuration configuration = ConfigurationManager.OpenMappedExeConfiguration(fileMap, ConfigurationUserLevel.None); //获取指定名称的配置节 UnityConfigurationSection section = (UnityConfigurationSection)configuration.GetSection(UnityConfigurationSection.SectionName); //实例化容器 IUnityContainer container = new UnityContainer(); section.Configure(container, \"testContainer\"); container.AddNewExtension&lt;Interception>().Configure&lt;Interception>() .SetInterceptorFor&lt;IPhone>(new InterfaceInterceptor()); IPhone phone = container.Resolve&lt;IPhone>(\"Android\"); phone.Call(); 运行结果: Headphone 被构造 AndroidPhone带参数构造函数 Microphone 被构造 Power 被构造 AndroidPhone打电话","path":"2017/08/19/Ioc/","date":"08-19","excerpt":""},{"title":"装饰器模式","text":"概述 装饰模式：动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 扩展一个类的功能，动态增加功能，动态撤销。 示例需求 实现普通学员和VIP学员上课。 普通学员需要注册、预习、上课。 VIP学员需要注册、付费、预习、上课、作业、点评。 示例介绍 有一个AbstractStudent抽象类,表示学员的基类。 有StudentFree和StudentVip类，继承自AbstractStudent，表示普通学员和VIP学员。 BaseStudentDecorator继承自AbstractStudent，表示装饰器基类。 StudentRegDecorator、StudentPayDecorator、StudentPreviewDecorator、StudentHomeworkDecorator、StudentCommentDecorator,都继承自AbstractStudent类，分别表示学员注册、付费、预习、作业巩固练习、作业点评。 代码AbstractStudent类: public abstract class AbstractStudent { public int Id { get; set; } public string Name { get; set; } public abstract void Study(); } StudentFree和StudentVip类: /// &lt;summary> /// 一个普通的公开课学员,学习公开课 /// &lt;/summary> public class StudentFree : AbstractStudent { public override void Study() { Console.WriteLine(\"{0} is a free student studying .net Free\", base.Name); } } /// &lt;summary> /// 一个普通的vip学员,学习vip课程 /// &lt;/summary> public class StudentVip : AbstractStudent { /// &lt;summary> /// 付费 上课前要预习 /// 上课学习 /// &lt;/summary> public override void Study() { Console.WriteLine(\"{0} is a vip student studying .net Vip\", base.Name); } } BaseStudentDecorator类: /// &lt;summary> /// 装饰器的基类 /// 也是一个学员，继承了抽象类 /// &lt;/summary> public class BaseStudentDecorator : AbstractStudent { private AbstractStudent _Student = null;//用了组合加继承 public BaseStudentDecorator(AbstractStudent student) { this._Student = student; } public override void Study() { this._Student.Study(); //Console.WriteLine(\"****************\"); //基类装饰器必须是个空的行为 会重复 } } 各装饰器类如下: public class StudentRegDecorator : BaseStudentDecorator { public StudentRegDecorator(AbstractStudent student) : base(student)//表示父类的构造函数 { } public override void Study() { Console.WriteLine(\"注册\"); base.Study(); } } public class StudentPayDecorator : BaseStudentDecorator { public StudentPayDecorator(AbstractStudent student) : base(student)//表示父类的构造函数 { } public override void Study() { Console.WriteLine(\"付费\"); base.Study(); } } public class StudentPreviewDecorator : BaseStudentDecorator { public StudentPreviewDecorator(AbstractStudent student) : base(student)//表示父类的构造函数 { } public override void Study() { Console.WriteLine(\"预习\"); base.Study(); } } public class StudentHomeworkDecorator : BaseStudentDecorator { public StudentHomeworkDecorator(AbstractStudent student) : base(student)//表示父类的构造函数 { } public override void Study() { base.Study(); Console.WriteLine(\"巩固练习\"); } } public class StudentCommentDecorator : BaseStudentDecorator { public StudentCommentDecorator(AbstractStudent student) : base(student)//表示父类的构造函数 { } public override void Study() { base.Study(); Console.WriteLine(\"点评\"); } } 调用代码： Console.WriteLine(\"******************普通学员**********************\"); AbstractStudent student = new StudentFree() { Id = 001, Name = \"张三\" }; student = new StudentPreviewDecorator(student); student = new StudentRegDecorator(student); student.Study(); Console.WriteLine(\"*****************VIP学员***********************\"); student = new StudentVip() { Id = 002, Name = \"李四\" }; student = new StudentPreviewDecorator(student);//原有变量 student = new StudentPayDecorator(student); student = new StudentRegDecorator(student); student = new StudentHomeworkDecorator(student); student = new StudentCommentDecorator(student); student.Study(); 输出结果为: ******************普通学员********************** 注册 预习 张三 is a free student studying .net Free *****************VIP学员*********************** 注册 付费 预习 李四 is a vip student studying .net Vip 巩固练习 点评","path":"2017/07/10/DecoratorPattern/","date":"07-10","excerpt":""},{"title":"加密和解密","text":"对称加密和非对称加密对称加密对称加密的思路非常简单，就是含有一个称为密钥的东西，在消息发送前使用密钥对消息进行加密，在对方收到消息之后，使用相同的密钥进行解密。根据密钥来产生加密后的消息（密文）的这一加工过程，由加密算法来完成，加密算法通常是公开的。它的流程如下： 发送方使用密钥对消息进行加密。 接收方使用同样的密钥对消息进行解密。 对称加密存在这样两个问题： 虽然可以通过密钥来保证消息安全地进行传递，但是如何确保密钥安全地进行传递？因为发送者和接收者总有一次初始的通信，用来传递密钥，此时的安全如何保证？ 接收者虽然可以根据密钥来解密消息，但因为存在上面的问题，消息有可能是由第三方（非法获得密钥）发来的，而接收方无法辨别。为了解决上面两个问题，就需要介绍一下非对称加密。 非对称加密非对称加密的接收者和发送者都持有两个密钥，一个是对外公开的，称为公钥，一个是自行保管的，称为私钥。非对称加密的规则是由某人A的公钥加密的消息，只能由A的私钥进行解密；由A的私钥加密的消息只能由A的公钥解密。此时我们可以得出接收方、发送方有两个公钥两个私钥一共四个密钥，我们先看看两种简单的方式，这两种方式都是只使用两个密钥。第一种模式只使用接收方的公钥和私钥，称为加密模式。加密模式在加密模式中，由消息的接收方发布公钥，持有私钥。比如发送方要发送消息“hello,jimmy”到接收方，它的步骤是： 发送方使用接收者的公钥进行加密消息，然后发送。 接收方使用自己的私钥对消息进行解密。 在这种模式下，如果第三方截获了发送者发出的消息，因为他没有接收者的私钥，所以这个消息对他来说毫无意义。可见，它能够满足本文最开始提出的消息安全传递的要点一：消息的发送方能够确定消息只有预期的接收方可以解密(不保证第三方无法获得，但保证第三方无法解密)。除此以外，因为接收方的公钥是公开的，任何人都可以使用这个公钥来加密消息并发往接收者，而接收者无法对消息进行判别，无法知道是由谁发送来的。所以，它不满足我们开始提出的消息安全传递的要点二：消息的接收方可以确定消息是由谁发送的（消息的接收方可以确定消息的发送方）。 认证模式在认证模式中，由消息的发送方发布公钥，持有私钥。比如发送者要发送消息“Welcome to Tracefact.net”到接收者，它的步骤是： 发送者使用自己的私钥对消息进行加密，然后发送。 接收者使用发送者的公钥对消息进行解密。 优缺点对称加密算法的优点是速度快，缺点是密钥管理不方便，要求共享密钥。 非对称加密算法的优点是密钥管理很方便，缺点是速度慢。 MD5不可逆加密算法介绍MD5（单向散列算法）的全称是Message-Digest Algorithm 5（信息-摘要算法），经MD2、MD3和MD4发展而来。MD5算法的使用不需要支付任何版权费用。 MD5功能 输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）； 不同的输入得到的不同的结果（唯一性）； 根据128位的输出结果不可能反推出输入的信息（不可逆）； MD5属不属于加密算法 认为不属于的人是因为他们觉得不能从密文（散列值）反过来得到原文，即没有解密算法，所以这部分人认为MD5只能属于算法，不能称为加密算法； 认为属于的人是因为他们觉得经过MD5处理后看不到原文，即已经将原文加密，所以认为MD5属于加密算法。 MD5的用途防止被篡改 比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。 比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。 SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5. 防止直接看到明文现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码(其实这样是不安全的)。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。） 防止抵赖（数字签名）这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。 DES对称可逆加密DES算法介绍美国国家标准局1973年开始研究除国防部外的其它部门的计算机系统的数据加密标准，于1973年5月15日和1974年8月27日先后两次向公众发出了征求加密算法的公告。加密算法要达到的目的（通常称为DES 密码算法要求）主要为以下四点： 提供高质量的数据保护，防止数据未经授权的泄露和未被察觉的修改； 具有相当高的复杂性，使得破译的开销超过可能获得的利益，同时又要便于理解和掌握； DES密码体制的安全性应该不依赖于算法的保密，其安全性仅以加密密钥的保密为基础； 实现经济，运行有效，并且适用于多种完全不同的应用。1977年1月，美国政府颁布：采纳IBM公司设计的方案作为非机密数据的正式数据加密标准（DES?Data Encryption Standard）。 目前在国内，随着三金工程尤其是金卡工程的启动，DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用，以此来实现关键数据的保密，如信用卡持卡人的PIN的加密传输，IC卡与POS间的双向认证、金融交易数据包的MAC校验等，均用到DES算法。 RSA非对称可逆加密RSA算法介绍它是第一个既能用于数据加密也能用于数字签名的算法。它易于理解和操作，也很流行。算法的名字以发明者的名字命名：Ron Rivest, Adi Shamir 和Leonard Adleman。但RSA的安全性一直未能得到理论上的证明。它经历了各种攻击，至今未被完全攻破。 加密和解密不是用的同一个密钥，其中一个称为公钥（public key），另一个称为私钥（private key）。公钥就是公开的，大家都知道，而私钥只有你自己知道。这两个密钥在数学上是有联系的，用公钥加密的内容只能由相应的私钥来解密，反过来，用私钥加密的内容只能由相应的公钥来解密。另外很重要的一点是， 不能从公钥推导出私钥，或者说很困难。常用的非对称加密算法有RSA，ECC等等。举个例子，你想要把一篇文章发送给你的朋友，但是不想让别人看到这篇文章。除了用上面讲的方法以外，你还可以用非对称加密来实现。在发送之前，你把文章用你朋友的公钥加密（公钥是公开的，每个人都知道），然后把加密过后的文章发送给你的朋友，你的朋友可以用他的私钥来解密。其他人获得了你传送的内容都是没有用的，因为只有你朋友有私钥可以解密。 非对称加密算法的优点是密钥管理很方便，缺点是速度慢。 数字签名数字签名介绍数字签名所用的技术是散列和非对称加密。数字签名的假设是： 只有你自己有你的私钥。根据前面对散列的介绍，我们先为你要签名的信息生成一个Hash字串，Hash1，然后用你的私钥加密得到Encrypted(Hash1)，这就是你对这个文档的数字签名。当别人需要验证某个文档是否是你签名的时候，只需要用你的公钥解密你的签名得到Hash1，并和该文档计算出来的Hash2对比，查看是否一致。如果一致则说明你确实对该文档签过名，否则就是没有。下面来分析一下，数字签名是如何保证上面所讲的签名的特点的。 特点 不可伪造因为只有你有你自己的私钥，所以任何其他人都无法产生用你的私钥加密过的Hash1。 不可移植，复制你对文档A的签名不可能对文档B也有效，因为你对文档B的签名必然和对A的签名不一样，这是由Hash的唯一性保证的。拿你对A的签名去验证B是不可能通过的。 不可否认因为不可伪造，不可移植，不可复制，所以不可否认。 数字证书我们的身份证是由公安机关颁发的，并加有很多防伪技术，不能伪造（或者说很难）。同样的，数字证书也有专门的发证机关（Certificate Authority，简称CA，其实是一些商业公司啦）。比较常见的发证机关是 VeriSign。数字证书的发证机关会对自己发放的证书加上自己的数字签名，以保证证书不能被伪造。那数字证书到底包含了些什么呢？ 持有者姓名（Common Name） 发证机关（Issuer） 有效日期（Validity） 证书持有人的公钥（Subject’s Public Key Info） 扩展信息 （Extension） 用发证机关对该证书的数字签名（Certificate Signature） 前5点信息MD5摘要，然后用CA的私钥(加密下) 证书的验证 验证发证机关 当浏览器拿到一个数字证书，先看发证机关，然后找到相应的发证机关的证书，获得发证机关的公钥，用此公钥解密被加密的MD5，这样就获得了此证书的MD5值，我们称它为Hash1。然后浏览器用MD5算法对此证书重新计算一遍MD5，获得Hash2。然后比较Hash1和Hash2是否相等。如果相等就证明这张证书是由发证机关颁发的，并且没有被篡改过。 验证服务器（所有者） 使用证书所有者（注意，我这里指的是所有者，而不是持有者！）公钥加密一段信息发送给证书的持有者，如果持有者能发送回（可以是被私钥加密，也可以是明文，没有关系）被加密的这段信息的话就证明该持有者拥有该证书对应的私钥，也就是说，该持有者就是该证书的所有者。 验证持有者姓名 SSL基本原理SSL全称是 Secure Sockets Layer，它是一种间于传输层（比如TCP/IP）和应用层（比如HTTP）的协议。 最简单的方法来保证通信安全是用非对称加密。我们前面讲过数字证书的认证，如果双方都认证了对方的数字证书，那么每次传输信息的时候都用对方的公钥加密，这样就只有对方能解密，从而保证了信息的安全，但是对于日常应用（比如网页浏览）有两个问题： 非对称加密速度缓慢，消耗资源如果客户端和服务器之间传输文件用非对称加密的话，速度一定慢的忍无可忍。 不可能要求每个用户都去申请数字证书申请数字证书是一个相当麻烦的过程，要求每个上网的用户都拥有证书是不可能的事情。 SSL通过“握手协议”和“传输协议”来解决上述问题。握手协议是基于非对称加密的，而传输协议是基于对称加密的。根据不同的应用，SSL对证书的要求也是不一样的，可以是单方认证（比如HTTP, FTP），也可以是双方认证（比如网上银行）。通常情况下，服务器端的证书是一定要具备的，客户端的证书不是必须的。下面两张图片显示了SSL握手的过程。 单边认证 双边认证 在通信双方协商出一个对称密钥以后，他们用这个密钥来加密传输的数据。同时为每个消息生成时间戳，用此密钥为消息和相应的时间戳生成消息认证码（MAC）。也就是说，每次发送的内容包括 Encrypt(message) + MAC(message + timestamp)。 这么做有几个好处： 防止消息的篡改所谓消息篡改就是有第三者插在通信双方之间，篡改往来的消息。由于消息是加密的，第三者不能获得消息的内容，但是他可以闭着眼睛瞎改。如果没有MAC的话，接受者就无法判断此消息是否被篡改过。 防止消息重放消息的重放是只第三者记录下通信双方的每一次发送的消息，虽然他不能获得消息的内容。但是它可以通过重新发送客户端或者服务端的信息来把自己装成是客户端或者服务端。如果在MAC里面加上了时间戳，消息接收方验证时间戳就可以阻止消息的重放攻击。SSL的基本思想是用非对称加密来建立链接（握手阶段），用对称加密来传输数据（传输阶段）。这样既保证了密钥分发的安全，也保证了通信的效率。通过上面对SSL的分析，我们可以看到，SSL并不能阻止别人获得你传输的数据，但是由于你传输的数据都是加密过的，别人拿到了毫无用处，一样可以保护信息的安全。还有一点需要强调一下，SSL并不依赖于TCP，它可以建立在任何可靠的传输层协议（比如TCP）之上。也就是说SSL是不能建立在UDP之上的。这是显然的，如果传输都不可靠，偶尔丢两个包或者包的顺序换一换的话，怎么保证安全呢？ 参考链接参考链接","path":"2017/07/02/encryption/","date":"07-02","excerpt":""},{"title":"设计模式(三)--抽象工厂模式","text":"参考链接：风一样的码农 概述对一组具有相同主题的工厂进行封装；提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 例如：生产一台PC机，使用工厂方法模式的话，一般会有cpu工厂，内存工厂，显卡工厂…但是使用抽象工厂模式的话，只有一个工厂就是PC工厂，但是一个PC工厂涵盖了cpu工厂，内存工厂，显卡工厂等要做的所有事； 另外，还有一个产品等级的概念，还是以生产PC机为例，所谓的产品等级指的是不同厂商生产的CPU，如Intel和AMD的CPU,他们是同一个产品等级，如果只涉及产品等级的话，是不需要应用抽象工厂模式，使用工厂方法模式即可；工厂方法模式解决的范畴是产品等级（AMD处理器，Intel处理器等）；抽象工厂模式解决的范畴是产品族等级（联想PC、惠普PC等）； #### 示例代码 与工厂方法模式中的例子类似，这是一个模拟多种数据库访问层封装的代码： 抽象工厂(IDatabaseFactory) public interface IDatabaseFactory { IOracle CreateOracle(); IMysql CreateMysql(); } 具体工厂(Factory) public class Factory:IDatabaseFactory { public IMysql CreateMysql() { return new Mysql(); } public IOracle CreateOracle() { return new Oracle(); } } 抽象产品(IMysql,IOracle) public interface IMysql { void ShowDatabaseName(); } public interface IOracle { void ShowDatabaseName(); } 具体产品(Mysql,Oracle) class Mysql : IMysql { public void ShowDatabaseName() { Console.WriteLine(\"This is Mysql\"); } } class Oracle : IOracle { public void ShowDatabaseName() { Console.WriteLine(\"This is Oracle\"); } } 产品使用者 IDatabaseFactory factory = new Factory(); IOracle oracle= factory.CreateOracle(); IMysql mysql = factory.CreateMysql(); oracle.ShowDatabaseName(); mysql.ShowDatabaseName(); 输出结果为: This is Oracle This is Mysql","path":"2017/06/03/abstractFactory/","date":"06-03","excerpt":""},{"title":"在Linux中安装Oracle数据库","text":"安装前准备修改用户的SHELL的限制，修改/etc/security/limits.conf文件输入命令：vi /etc/security/limits.conf，按i键进入编辑模式，将下列内容加入该文件。 oracle soft nproc 2047 oracle hard nproc 16384 oracle soft nofile 1024 oracle hard nofile 65536 编辑完成后按Esc键，输入:wq存盘退出 修改/etc/pam.d/login 文件输入命令：vi /etc/pam.d/login，按i键进入编辑模式，将下列内容加入该文件。 session required /lib/security/pam_limits.so session required pam_limits.so 修改linux内核修改/etc/sysctl.conf文件，输入命令: vi /etc/sysctl.conf ，按i键进入编辑模式，将下列内容加入该文件 fs.file-max = 6815744 fs.aio-max-nr = 1048576 kernel.shmall = 2097152 kernel.shmmax = 2147483648 kernel.shmmni = 4096 kernel.sem = 250 32000 100 128 net.ipv4.ip_local_port_range = 9000 65500 net.core.rmem_default = 4194304 net.core.rmem_max = 4194304 net.core.wmem_default = 262144 net.core.wmem_max = 1048576 使 /etc/sysctl.conf 更改立即生效 输入：sysctl -p 显示如下： net.ipv4.icmp_echo_ignore_broadcasts = 1 net.ipv4.conf.all.rp_filter = 1 fs.file-max = 6815744 fs.aio-max-nr = 1048576 kernel.shmall = 2097152 kernel.shmmax = 2147483648 kernel.shmmni = 4096 kernel.sem = 250 32000 100 128 net.ipv4.ip_local_port_range = 9000 65500 net.core.rmem_default = 4194304 net.core.rmem_max = 4194304 net.core.wmem_default = 262144 net.core.wmem_max = 1048576 编辑 /etc/profile输入命令：vi /etc/profile，按i键进入编辑模式，将下列内容加入该文件。 if [ $USER = “oracle” ]; then if [ $SHELL = “/bin/ksh” ]; then ulimit -p 16384 ulimit -n 65536 else ulimit -u 16384 -n 65536 fi fi 创建相关用户和组，作为软件安装和支持组的拥有者。创建Oracle用户和密码,输入命令： useradd -g oinstall -g dba -m oracle passwd oracle 创建数据库软件目录和数据文件存放目录目录的位置，根据自己的情况来定，注意磁盘空间即可，这里我把其放到oracle用户下,例如： 输入命令： mkdir /home/oracle/app mkdir /home/oracle/app/oracle mkdir /home/oracle/app/oradata mkdir /home/oracle/app/oracle/product 更改目录属主为Oracle用户所有输入命令： chown -R oracle:oinstall /home/oracle/app 配置oracle用户的环境变量首先，切换到新创建的oracle用户下, 输入：su – oracle ，然后直接输入 ： vi .bash_profile 按i编辑 .bash_profile,进入编辑模式，增加以下内容： export ORACLE_BASE=/home/oracle/app export ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/dbhome_1 export ORACLE_SID=orcl export PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/lib 开始安装当上述系统要求操作全部完成后，注销系统，在图形界面以Oracle用户登陆。首先将下载的Oracle安装包复制到linux中，用SSH其他ftp工具拷贝。 解压打开一个终端，运行unzip命令解压oracle安装文件，如： 输入命令： unzip linux.x64_11gR2_database_1of2.zip unzip linux.x64_11gR2_database_2of2.zip 输入命令：cd database 执行安装输入命令：./runInstaller 注意事项：./runInstaller -jreLoc jdk路径 ———解决弹框显示不全exprot LANG=en_US 解决安装界面显示为方框exprot DISPLAY=:0.0 不行就到root下设置然后输入命令xhost+ 解决图形界面不弹出问题 输入dbca命令可打开创建数据库实例的窗口 定位jdk安装路径which java假设输出为：/usr/bin/java ls -lrt /usr/bin/java假设输出为：lrwxrwxrwx. 1 root root 22 Aug 17 15:12 /usr/bin/java -&gt; /etc/alternatives/javals -lrt /etc/alternatives/java假设输出为：lrwxrwxrwx. 1 root root 46 Aug 17 15:12 /etc/alternatives/java -&gt; /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/javajdk安装路径即为：/usr/lib/jvm/jre-1.7.0-openjdk.x86_64 参考链接","path":"2017/05/29/linuxInstallOracle/","date":"05-29","excerpt":""},{"title":"汇编学习(四)--位运算之四则运算","text":"位运算之运算符 &amp; 与 | 或 ^ 异或 ~ 非 &lt;&lt; 左移 >> 右移 与运算符假设对两个·二进制数做与运算如下: 0&amp;0=0 0&amp;1=0 1&amp;0=0 1&amp;1=1 即两个操作数都为1时结果才为1，否则为0 或运算符假设对两个二进制数做或运算如下: 0|0=0 0|1=1 1|0=1 1|1=1 即两个操作数只要有一个为1则结果为1。 异或运算符假设对两个二进制数做异或运算如下: 0^0=0 0^1=1 1^0=1 1^1=0 即两个操作数不相同时结果为1，否则为0。 非运算符只有一个操作数，即取当前操作数的反码。参考有符号数和无符号数 左移和右移运算符右： 位右移运算将整个数按位右移若干位，右移后空出的部分补0。比如：8位的二进制数 01100101 将其右移3位，结果是00001100。 左： 位左移运算将整个数按位左移若干位，左移后空出的部分补0。比如：8位的二进制数01100101),将其左移3位，结果是00101000。 加法运算加法运算的原理假设两个数num1、num2，求num1+num2，步骤如下： 异或运算，num1^num2 用与运算判断是否有进位，num1&amp;num2。 如果第二步得到的结果为0，则num1+num2=num1^num2得到结果;如果第二步得到的结果不为0，将第二步得到的结果向左移一位(num1&amp;num2)&lt;&lt;1。 将第一步得到的结果与第三步得到的结果进行或异运算并判断是否有进位。 循环至第三步，直至没有进位为止。 代码示例int Add(int num1, int num2) { int sum = 0; while (num2 != 0) { //进行异或运算 sum = num1 ^ num2; //使用与运算判断是否有进位，与运算的结果为0则没有进位。然后向左移一位。 num2 = (num1 &amp; num2) &lt;&lt; 1; //将异或运算结果给第一个操作数进行进位后的运算 num1 = sum; }while (num2 != 0); return num1; } 减法运算减法运算的原理减法和运算可以转化为加法，如:4-5=4+(-5);减法就是将减数取补码，然后和被减数相加。 代码示例 int Sub(int num1,int num2) { return Add(num1, Complement(num2)); } int Complement(int num) //取补码,,反码加1 { return Add(~num,1); } 乘法运算乘法运算的原理乘法就是将乘数写成(2^0)*k0 + (2^1)*k1 + (2 ^2)*k2 + … + (2^31)*k31，其中ki为0或1，然后利用位运算和加法就可以了。 //正数乘法运算 int Pos_Multiply(int a,int b) { int ans = 0; while(b) { if(b&amp;1) ans = Add(ans, a); a = (a&lt;&lt;1); b = (b>>1); } return ans; } //乘法运算 int Multiply(int a,int b) { if( iszero(a) || iszero(b) ) return 0; if( ispos(a) &amp;&amp; ispos(b) ) return Pos_Multiply(a, b); if( isneg(a) ) { if( isneg(b) ) { return Pos_Multiply( negtive(a), negtive(b) ); } return negtive( Pos_Multiply( negtive(a), b ) ); } return negtive( Pos_Multiply(a, negtive(b)) ); } 除法运算原理除法就是由乘法的过程逆推，依次减掉（如果x够减）y^(2^31),y^(2^30),…y^8,y^4,y^2,y^1。减掉相应数量的y就在结果加上相应的数量。 int Pos_Div(int x,int y) { int ans=0; for(int i=31;i>=0;i--) { //比较x是否大于y的(1&lt;&lt;i)次方，避免将x与(y&lt;&lt;i)比较，因为不确定y的(1&lt;&lt;i)次方是否溢出 if((x>>i)>=y) { ans+=(1&lt;&lt;i); x-=(y&lt;&lt;i); } } return ans; } 代码参考文章","path":"2017/05/24/bitoperator/","date":"05-24","excerpt":""},{"title":"汇编学习(三)--有符号数和无符号数","text":"原码、反码、补码 原码：如果机器字长为n，那么一个数的原码就是用一个n位的二进制数表示。反码：正数与原码相同，负数在原码的基础上，符号位为1其他位按位取反(就是0变1，1变0)就可以了。补码：正数与原码相同，负数补码就是在反码的基础上按照正常的加法运算加1，位数不够时左边补1。 补充： 移码：不管正负数，只要将其补码的符号位取反即可。 编码规则 原码： 有符号数中最高位为符号位：正数为0，负数为1。剩下的n-1位表示该数的绝对值。无符号数则n位都表示该数，因此无符号数无负数。 反码： 正数：与原码相同 负数：符号位为1，其余位对原码取反。 补码：正数：与原码相同 负数：符号位为1，然后取反码加1。 PS：正数的原、反、补码都一样。 例如：求-5的原码、反码、补码，长度为字节： 原码： 10000101 85 反码： 11111010 FA 补码： 11111011 FB 在计算机中的存储方式：正数原码存储，负数补码存储。 表示范围假设数据的宽度为1Byte(8 Bit),可用下图表示： 假设数据的宽度为1Doubleword(32 Bit),可用下图表示：","path":"2017/05/24/symbolnumber/","date":"05-24","excerpt":""},{"title":"汇编学习(二)--数据宽度","text":"概念数学上的数字，是没有大小限制的，可以无限大，但在计算机中，由于硬件的制约，数据都是有长度限制的(数据宽度)，超过最大宽度的数据将会被丢弃。 计算机中常见的数据宽度 位(Bit) :数0据存储的最小单元。字节(Byte):1Byte=8Bit。字(Word):1Word=16Bit。双字(Doubleword): 1Doubleword=32bit。 储值范围字节:0 ~ 0xFF 即：0000 0000 ~ 1111 1111字：0 ~ 0xFFFF 即: 0000 0000 0000 0000 ~ 1111 1111 1111 1111双字: 0 ~ 0xFFFFFFFF","path":"2017/05/24/datawidth/","date":"05-24","excerpt":""},{"title":"汇编学习(一)--简单理解进制","text":"进制的定义八进制的定义:由八个符号组成，分别是0 1 2 3 4 5 6 7 逢八进一。十进制的定义：由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9 逢十进一。N进制的定义:由N个符号组成，逢N进一。 十进制的定义不一定就是0~9这几个数字，可以是任意的十个符号，满足逢十进一即可。 二进制和十六进制二进制是计算机使用的进制，计算机是需要用电的，电路只有两种状态：1 真（通电）、 0 假（未通电），计算机中储存的任何文件、接收的任何指令都是由0和1组成的。 由于使用二进制书写太麻烦，便使用十六进制作为二进制的简写形式： 0 00001 00012 00103 00114 01005 01016 01107 01118 10009 1001A 1010B 1011C 1100D 1101E 1110F 1111","path":"2017/05/24/jinzhi/","date":"05-24","excerpt":""},{"title":"简单使用NLog进行日志记录","text":"参考链接 NLog安装在Visual Studio的NuGet包管理器中搜索NLog安装即可 NLog配置NLog的配置文件可以嵌入到应用程序配置文件中也可单独配置成NLog.config或NLog.dll.nlog此处介绍NLog.config配置,示例如下: &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?> &lt;configuration> &lt;nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" autoReload=\"true\"> &lt;targets> &lt;!-- Log in a separate thread, possibly queueing up to messages. When the queue overflows, discard any extra messages--> &lt;!-- write logs to file --> &lt;target name=\"file\" xsi:type=\"AsyncWrapper\" queueLimit=\"5000\" overflowAction=\"Discard\"> &lt;target xsi:type=\"File\" fileName=\"${basedir}/logs/${shortdate}.log\" layout=\"${longdate} ${level:uppercase=true} ${message} ${stacktrace}\" /> &lt;/target> &lt;!-- write log message to database --> &lt;target xsi:type=\"Database\" name=\"infomation\" dbProvider=\"Pomelo.Data.MyCat\" useTransactions=\"false\" connectionString=\"server=localhost;port=3306;database=TESTDB;uid=root;pwd=123456;\" keepConnection=\"true\"> &lt;commandText> INSERT INTO Log_Table(testDate,Level,Conent,StackMessage) VALUES(@time_stamp, @level, @message, @stacktrace); &lt;/commandText> &lt;parameter name=\"@time_stamp\" layout=\"${date}\" /> &lt;parameter name=\"@level\" layout=\"${level:uppercase=true}\" /> &lt;parameter name=\"@message\" layout=\"${message}\" /> &lt;parameter name=\"@stacktrace\" layout=\"${stacktrace}\" /> &lt;/target> &lt;!--write log message to Visual Studio Output--> &lt;!--&lt;target name=\"debugger\" xsi:type=\"Debugger\" layout=\"NLog: ${date:format=HH\\:mm\\:ss} | ${level:uppercase=true:padding=-5} | ${message}\" />--> &lt;/targets> &lt;rules> &lt;!--TRACE,DEBUG,INFO,WARN,ERROR,FATAL--> &lt;!--&lt;logger name=\"*\" minlevel=\"Trace\" writeTo=\"debugger\" />--> &lt;!--INFO,WARN,ERROR,FATAL--> &lt;logger name =\"*\" minlevel=\"TRACE\" writeTo=\"file\">&lt;/logger> &lt;logger name=\"*\" minlevel=\"Warn\" writeTo=\"infomation\" /> &lt;!--DEBUG,INFO,WARN,ERROR,FATAL--> &lt;!--&lt;logger name=\"*\" minlevel=\"Debug\" writeTo=\"file\" />--> &lt;/rules> &lt;/nlog> &lt;/configuration> 配置元素 - 定义日志的目标/输出 - 定义日志的路由规则 - 从*.dll加载NLog扩展 - 导入外部配置文件 - 为配置变量赋值 此示例中，重要之处在两个targets配置节，和rules配置节。 日志输出类型 Console 输出到控制台 Debugger 输出到 File 输出到文件 Mail 输出为邮件发送 Network 输出到网络地址 Database 输出到数据库 AsyncWrapper 异步操作 路由规则区域定义了日志的路由规则。实际上它是一个简单的路由表，对每一个日志源/记录者的名称和记录等级的组合，定义了一个日志写入目标列表。 表中的规则是被顺序处理的。每当遇到匹配的规则时，日志信息就会被送到规则中定义的一个或多个目标去。如果一个规则被标识为最后一个，那么其后的规则都不会被执行。 每一个路由表项就是一个元素，它的可以接受的属性有： name - 日志源/记录者的名字 (允许使用通配符*) minlevel - 该规则所匹配日志范围的最低级别 maxlevel - 该规则所匹配日志范围的最高级别 level - 该规则所匹配的单一日志级别 levels - 该规则所匹配的一系列日志级别，由逗号分隔。 writeTo - 规则匹配时日志应该被写入的一系列目标，由逗号分隔。 final - 标记当前规则为最后一个规则。其后的规则即时匹配也不会被运行。 上下文信息NLog最棒的功能之一就是使用布局（layouts）的能力。布局由被一个美元符号$加左大括弧“${”和一个右大括弧“}”为标记所包围的文本所组成。这个标记也就是所谓的“布局生成器（layout renderers），我们可以用它来把一些上下文相关的信息插入到日志信息中。布局可以应用在许多地方，比如可以被用在控制输出到屏幕或写入文件信息的格式，也可以用在控制文件名。接下来我们会更多的了解布局的强大。 假设我们希望每个输出到控制台的信息都包含一些这些信息： 当前的日期和时间产生日志信息的类和方法的名字日志等级日志内容利用Layout来实现很简单： 或者我们可以把每一个日志记录者生成的日志信息输出到一个单独的文件里： 这里我们看到fileName属性的值被设置为布局生成器${logger}，从而使每一条日志信息被写到一个以日志生成者名字命名的一个文件里。上面这个例子将生成如下一系列文件： Name.Space.Class1.txt Name.Space.Class2.txt Name.Space.Class3.txtOther.Name.Space.Class1.txtOther.Name.Space.Class2.txtOther.Name.Space.Class3.txt…有一个常见需求是能够用日期信息来区分日志文件。如果使用${shortdate}布局生成器，这简直太容易了： 那么可以给每一个职员生成一个日志文件吗？答案就是${windows-identity}布局生成器： 这样我们就能够给每一个职员生成一个日志文件了： Administrator.txtMaryManager.txtEdwardEmployee.txt…更复杂的场景也能做到。下面这个例子说明了如何为每个人每天生成一个日志文件。每天的日志文件存放在不同的文件夹里： 这将创建如下文件： 2006-01-01/Administrator.txt2006-01-01/MaryManager.txt2006-01-01/EdwardEmployee.txt2006-01-02/Administrator.txt2006-01-02/MaryManager.txt2006-01-02/EdwardEmployee.txt… 参数","path":"2017/05/22/nlog/","date":"05-22","excerpt":""},{"title":"设计模式(一)--简单工厂模式","text":"简单代码示例接口： public interface IRace { void Show(); } 具体类： public class Orc : IRace { public void Show() { Console.WriteLine(\"this is Orc Show\"); } } public class Human:IRace { public void Show() { Console.WriteLine(\"this is Human Show\"); } } 工厂类: public class Factory { public static IRace CreateInstence(RaceType race) { switch (race) { case RaceType.Human: return new Human(); case RaceType.Orc: return new Orc(); default: return null; } } public enum RaceType { Human, Orc } } 优缺点优点：工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。–上端解耦 缺点： 由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；严重违反单一职责原则 使用场景 工厂类负责创建的对象比较少； 客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心； 由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用 简单工厂改进具体类和接口和前面的一致,添加配置文件: &lt;appSettings> &lt;add key=\"RaceTypeConfig\" value=\"ConsoleApplication2,ConsoleApplication2.Human\"/> &lt;/appSettings> 工厂类做如下改动: private static string RaceTypeConfig = ConfigurationManager.AppSettings[\"RaceTypeConfig\"]; public static IRace CreateInstence() { string[] Races = RaceTypeConfig.Split(','); //CreateInstance // 摘要: // 使用命名的程序集和默认构造函数，创建名称已指定的类型的实例。 // // 参数: // assemblyName: // 将在其中查找名为 typeName 的类型的程序集的名称。有关更多信息，请参见“备注”一节。如果 assemblyName 为 null，则搜索正在执行的程序集。 // // typeName: // 首选类型的完全限定名。 // // 返回结果: // 要访问新创建的实例则必须解包的句柄。 return (IRace)(Activator.CreateInstance(Races[0],Races[1])).Unwrap(); } 如此便做到了程序的可配置和可扩展，扩展只需要得到dll修改配置文件即可;当然，这样做肯定也有缺点，但一种设计模式只是针对一类问题而存在。","path":"2017/05/21/easyfactory/","date":"05-21","excerpt":""},{"title":"设计模式(二)--工厂方法模式","text":"参考文章链接 工厂方法模式概述工厂方法模式：定义一个用于创建的接口，让子类决定让那一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式，又可称作虚拟构造器模式或多态工厂模式。工厂模式是一种类创造型模式。 应用场景什么时候需要工厂模式呢？工厂方法模式可以让一个类的实例化延迟到其子类，就是一开始你还不适合立刻就创建该对象，你还需要一些资源或其它准备工作。整个系统的运行不像单个程序那样，系统需要很多资源和多方面的协同工作。 如果一个类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂方法模式，把创建对象的工作延迟到子类中去实现。 如果一个类本身希望由它的子类来创建所需的对象的时候，应该使用工厂方法模式。 代码示例示例代码为假想的两个数据库访问层的封装，结构如下： 抽象工厂（Creator）：这个抽象类（或接口）声明一个创建对象的工厂方法，用来返回一个Product类型的对象。 具体工厂（ConcreteCreator)：重定义工厂方法，返回一个具体的ConcreteProduct实例。 抽象产品（Product)：定义工厂方法所创建的对象。 具体产品（ConcreteProduct): 具体产品，继承自Product抽象类。 数据库接口IDatabase 即(抽象产品（Product)):public interface IDatabase { void ShowDatabaseName(); } 各数据库具体类 即（具体产品（ConcreteProduct)）： public class OracleDatabase:IDatabase { public void ShowDatabaseName() { Console.WriteLine(\"Oracle\"); } } public class MysqlDatabase : IDatabase { public void ShowDatabaseName() { Console.WriteLine(\"Mysql\"); } } 数据库工厂接口 即（抽象工厂（Creator））： public interface DatabaseFactory { IDatabase CreateDatabase(); } 各数据库的工厂类 即（具体工厂（ConcreteCreator)）： public class OracleFactory:DatabaseFactory { public IDatabase CreateDatabase() { return new OracleDatabase(); } } public class MysqlFactory : DatabaseFactory { public IDatabase CreateDatabase() { return new MysqlDatabase(); } } 调用示例： DatabaseFactory factory; IDatabase database; factory = new MysqlFactory(); database = factory.CreateDatabase(); database.ShowDatabaseName(); 输出结果为： Mysql 模式功能 工厂方法模式主要功能是让父类不知道具体实现情况下，完成自身的功能调用；而具体的实现则延迟到子类来实现。 优缺点优点 ‘可以在不知具体实现的情况下编程，工厂方法模式可以让你在实现功能时，如果需要某个产品对象，只需要使用产品的接口即可，而无需关系具体的实现。选择具体的实现的任务延迟到子类去完成。’ 更容易扩展对象的新版本只需要新加入一个子类来提供新的工厂方法实现，然后在客户端使用这个新的子类即可。 连接平行的类层次结构 缺点 每增加一个产品就需要加一个产品工厂的类，增加了额外的开发量。 工厂方法模式实现时，客户端需要决定实例化哪个工厂来实现对具体产品的构建，选择判断依然存在，也就是说，工厂方法模式将简单工厂的逻辑判断交给客户端去处理。 简单工厂vs工厂方法工厂方法模式与简单工厂模式非常类似，简单工厂模式在工厂类中选择实例化哪个具体类，工厂方法模式则是在客户端来判断。 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移动到了客户端代码来进行。如果要加功能，简单工厂是改工厂类的，而现在是改客户端。","path":"2017/05/21/factorymethod/","date":"05-21","excerpt":""},{"title":"对象序列化","text":"序列化的含义序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。例如，可以序列化一个对象，然后使用 HTTP 通过 Internet 在客户端和服务器之间传输该对象。反之，反序列化根据流重新构造对象。此外还可以将对象序列化后保存到本地，再次运行的时候可以从本地文件中“恢复”对象到序列化之前的状态。 XML序列化XML序列化将对象通过二进制流序列化为XML文件，对象必须指定Serializable特性： Person p = new Person(); using (FileStream stream = new FileStream(\"person.xml\", FileMode.Create)) { XmlSerializer xs = new XmlSerializer(typeof(Person)); xs.Serialize(stream, p); } 序列化得到的XML文档如下: 张三 男 25 序列化数组对数组进行序列化时，必须对需要序列化的对象及其属性设置几个特性： //定义序列化根节点名为people [XmlRoot(\"people\")] public class Person { static string[] f = { \"游泳\",\"跑步\",\"打球\"}; [XmlAttribute] //将Name作为people的一个属性 public string Name { get; set; } = \"张三\"; [XmlIgnore] //不序列化Sex public string Sex { get; set; } = \"男\"; public int Age { get; set; } = 25; //序列化数组为hobbys节点，元素为hobby节点 [XmlArray(\"hobbys\"), XmlArrayItem(\"hobby\")] public string[] Hobby { get; set; }= f; } 调用方式和前面一样，得到的Xml文档如下: &lt;?xml version=\"1.0\"?> &lt;people xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" Name=\"张三\"> &lt;Age>25&lt;/Age> &lt;hobbys> &lt;hobby>游泳&lt;/hobby> &lt;hobby>跑步&lt;/hobby> &lt;hobby>打球&lt;/hobby> &lt;/hobbys> &lt;/people> xml序列化的方式只能保存public的字段和可读写的属性，对于private等类型的字段不能进行序列化 XML反序列化using (FileStream stream = new FileStream(\"person.xml\", FileMode.Open)) { XmlSerializer xs = new XmlSerializer(typeof(Person)); var person= xs.Deserialize(stream) as Person; Console.WriteLine(\"Name :{0} , sex : {1} , age: {2}\", person.Name, person.Sex, person.Age); } 输出结果如下: Name :张三 , sex : 男 , age: 25 soap序列化soap序列化将对象通过二进制流序列化为soap文档，要序列化的对象必须指定Serializable特性： Person p = new Person(); using (FileStream stream = new FileStream(\"soap.xml\", FileMode.Create)) { SoapFormatter sf = new SoapFormatter(); sf.Serialize(stream,p); } 得到的soap文档如下: &lt;SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:clr=\"http://schemas.microsoft.com/soap/encoding/clr/1.0\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"> &lt;SOAP-ENV:Body> &lt;a1:Person id=\"ref-1\" xmlns:a1=\"http://schemas.microsoft.com/clr/nsassem/ConsoleApplication2/ConsoleApplication2%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull\"> &lt;_x003C_Name_x003E_k__BackingField id=\"ref-3\">张三&lt;/_x003C_Name_x003E_k__BackingField> &lt;_x003C_Sex_x003E_k__BackingField id=\"ref-4\">男&lt;/_x003C_Sex_x003E_k__BackingField> &lt;_x003C_Age_x003E_k__BackingField>25&lt;/_x003C_Age_x003E_k__BackingField> &lt;/a1:Person> &lt;/SOAP-ENV:Body> &lt;/SOAP-ENV:Envelope> 使用之前需要应用System.Runtime.Serialization.Formatters.Soap.dll（.net自带的） 简单对象访问协议（Simple Object Access Protocol，SOAP），是一种轻量的、简单的、基于XML的协议，它被设计成在WEB上交换结构化的和固化的信息。 SOAP 可以和现存的许多因特网协议和格式结合使用，包括超文本传输协议（HTTP），简单邮件传输协议（SMTP），多用途网际邮件扩充协议（MIME）。它还支持从消息系统到远程过程调用（RPC）等大量的应用程序。SOAP使用基于XML的数据结构和超文本传输协议(HTTP)的组合定义了一个标准的方法来使用Internet上各种不同操作环境中的分布式对象。调用反序列化之后的结果和XML相同 二进制序列化二进制序列化将对象通过二进制流序列化为文件，要使用二进制序列化的对象必须指定Serializable特性： Person实体类 [Serializable] public class Person { public string Name { get; set; } = \"张三\"; public string Sex { get; set; } = \"男\"; public int Age { get; set; } = 25; } 调用 static void Main(string[] args) { try { Person p = new Person(); using (FileStream stream = new FileStream(\"person.obj\", FileMode.Create)) { // // 摘要: // 以二进制格式将对象或整个连接对象图形序列化和反序列化。 BinaryFormatter binary = new BinaryFormatter(); binary.Serialize(stream, p); Console.WriteLine(\"序列化已成功\"); } } catch (Exception) { throw; } Console.Read(); } BinaryFormatter位于System.Runtime.Serialization.Formatters.Binary命名空间,序列化文件格式自定。 二进制反序列化使用BinaryFormatter下的Deserialize方法进行反序列化: static void Main(string[] args) { try { using (FileStream stream = new FileStream(\"person.obj\", FileMode.Open)) { BinaryFormatter binary = new BinaryFormatter(); var person= binary.Deserialize(stream) as Person; Console.WriteLine(\"Name :{0} , sex : {1} , age: {2}\",person.Name,person.Sex,person.Age); } } catch (Exception) { throw; } Console.Read(); } 输出结果如下: Name :张三 , sex : 男 , age: 25 json序列化json序列化使用.net框架自带的方法封装的操作帮助类如下: /// &lt;summary> /// json转换成集合 /// &lt;/summary> /// &lt;typeparam name=\"T\">&lt;/typeparam> /// &lt;param name=\"JsonStr\">&lt;/param> /// &lt;returns>&lt;/returns> public static List&lt;T> JsonStringToList&lt;T>(this string JsonStr) { //js操作对象 JavaScriptSerializer Serializer = new JavaScriptSerializer(); List&lt;T> objs = Serializer.Deserialize&lt;List&lt;T>>(JsonStr); return objs; } /// &lt;summary> /// 对象转换成json /// &lt;/summary> /// &lt;typeparam name=\"T\">&lt;/typeparam> /// &lt;param name=\"model\">&lt;/param> /// &lt;returns>&lt;/returns> public static string ModelToJsonString&lt;T>(T model) { JavaScriptSerializer serializer = new JavaScriptSerializer(); return serializer.Serialize(model); } /// &lt;summary> /// json转换成对象 /// &lt;/summary> /// &lt;typeparam name=\"T\">&lt;/typeparam> /// &lt;param name=\"JsonStr\">&lt;/param> /// &lt;returns>&lt;/returns> public static T JsonStringToModel&lt;T>(string JsonStr) { JavaScriptSerializer Serializer = new JavaScriptSerializer(); T objs = Serializer.Deserialize&lt;T>(JsonStr); return objs; } /// &lt;summary> /// 集合转换成json /// &lt;/summary> /// &lt;typeparam name=\"T\">&lt;/typeparam> /// &lt;param name=\"list\">&lt;/param> /// &lt;returns>&lt;/returns> public static string ListModelToJsonString&lt;T>(IList&lt;T> list) { JavaScriptSerializer Serializer = new JavaScriptSerializer(); string result = Serializer.Serialize(list); return result; } JavaScriptSerializer位于System.Web.Script.Serialization命名空间下。 使用第三方库Newtonsoft.json使用框架自带的方法并没有Newtonsoft效率高，所以Newtonsoft的使用更为普遍，支持序列化和反序列化DataTable,DataSet,Entity Framework和NHibernate。 安装： 在NunGet中搜索安装 简单使用：序列化使用JsonConvert.SerializeObject()方法，反序列化使用JsonConvert.DeserializeObject方法 更复杂的使用后面再单独做研究。","path":"2017/05/20/serializable/","date":"05-20","excerpt":""},{"title":"使用DbProviderFactory 打造一个通用的数据访问类库","text":"原文地址 类库结构此类库包括ProviderFactory，EntityReader，DbUtility，ColumnNameAttribute五个类。 ProviderFactory工厂类 /// &lt;summary> /// 数据库类型枚举 /// &lt;/summary> public enum DbProviderType : byte { SqlServer, MySql, SQLite, Oracle, ODBC, OleDb, Firebird, PostgreSql, DB2, Informix, SqlServerCe } /// &lt;summary> /// DbProviderFactory工厂类 /// &lt;/summary> public class ProviderFactory { private static Dictionary&lt;DbProviderType, string> providerInvariantNames = new Dictionary&lt;DbProviderType, string>(); private static Dictionary&lt;DbProviderType, DbProviderFactory> providerFactoies = new Dictionary&lt;DbProviderType, DbProviderFactory>(20); static ProviderFactory() { //加载已知的数据库访问类的程序集 providerInvariantNames.Add(DbProviderType.SqlServer, \"System.Data.SqlClient\"); providerInvariantNames.Add(DbProviderType.OleDb, \"System.Data.OleDb\"); providerInvariantNames.Add(DbProviderType.ODBC, \"System.Data.ODBC\"); providerInvariantNames.Add(DbProviderType.Oracle, \"Oracle.DataAccess.Client\"); providerInvariantNames.Add(DbProviderType.MySql, \"MySql.Data.MySqlClient\"); providerInvariantNames.Add(DbProviderType.SQLite, \"System.Data.SQLite\"); providerInvariantNames.Add(DbProviderType.Firebird, \"FirebirdSql.Data.Firebird\"); providerInvariantNames.Add(DbProviderType.PostgreSql, \"Npgsql\"); providerInvariantNames.Add(DbProviderType.DB2, \"IBM.Data.DB2.iSeries\"); providerInvariantNames.Add(DbProviderType.Informix, \"IBM.Data.Informix\"); providerInvariantNames.Add(DbProviderType.SqlServerCe, \"System.Data.SqlServerCe\"); } /// &lt;summary> /// 获取指定数据库类型对应的程序集名称 /// &lt;/summary> /// &lt;param name=\"providerType\">数据库类型枚举&lt;/param> /// &lt;returns>&lt;/returns> public static string GetProviderInvariantName(DbProviderType providerType) { return providerInvariantNames[providerType]; } /// &lt;summary> /// 获取指定类型的数据库对应的DbProviderFactory /// &lt;/summary> /// &lt;param name=\"providerType\">数据库类型枚举&lt;/param> /// &lt;returns>&lt;/returns> public static DbProviderFactory GetDbProviderFactory(DbProviderType providerType) { //如果还没有加载，则加载该DbProviderFactory if (!providerFactoies.ContainsKey(providerType)) { providerFactoies.Add(providerType, ImportDbProviderFactory(providerType)); } return providerFactoies[providerType]; } /// &lt;summary> /// 加载指定数据库类型的DbProviderFactory /// &lt;/summary> /// &lt;param name=\"providerType\">数据库类型枚举&lt;/param> /// &lt;returns>&lt;/returns> private static DbProviderFactory ImportDbProviderFactory(DbProviderType providerType) { string providerName = providerInvariantNames[providerType]; DbProviderFactory factory = null; try { //从全局程序集中查找 factory = DbProviderFactories.GetFactory(providerName); } catch (ArgumentException e) { factory = null; } return factory; } } DbUtility通用数据库访问类 public sealed class DbUtility { public string ConnectionString { get; set; } private DbProviderFactory providerFactory; /// &lt;summary> /// 构造函数 /// &lt;/summary> /// &lt;param name=\"connectionString\">数据库连接字符串&lt;/param> /// &lt;param name=\"providerType\">数据库类型枚举，参见&lt;paramref name=\"providerType\"/>&lt;/param> public DbUtility(string connectionString, DbProviderType providerType) { ConnectionString = connectionString; providerFactory = ProviderFactory.GetDbProviderFactory(providerType); if (providerFactory == null) { throw new ArgumentException(\"Can't load DbProviderFactory for given value of providerType\"); } } /// &lt;summary> /// 对数据库执行增删改操作，返回受影响的行数。 /// &lt;/summary> /// &lt;param name=\"sql\">要执行的增删改的SQL语句&lt;/param> /// &lt;param name=\"parameters\">执行增删改语句所需要的参数&lt;/param> /// &lt;returns>&lt;/returns> public int ExecuteNonQuery(string sql, IList&lt;DbParameter> parameters) { return ExecuteNonQuery(sql, parameters, CommandType.Text); } /// &lt;summary> /// 对数据库执行增删改操作，返回受影响的行数。 /// &lt;/summary> /// &lt;param name=\"sql\">要执行的增删改的SQL语句&lt;/param> /// &lt;param name=\"parameters\">执行增删改语句所需要的参数&lt;/param> /// &lt;param name=\"commandType\">执行的SQL语句的类型&lt;/param> /// &lt;returns>&lt;/returns> public int ExecuteNonQuery(string sql, IList&lt;DbParameter> parameters, CommandType commandType) { using (DbCommand command = CreateDbCommand(sql, parameters, commandType)) { command.Connection.Open(); int affectedRows = command.ExecuteNonQuery(); command.Connection.Close(); return affectedRows; } } /// &lt;summary> /// 执行一个查询语句，返回一个关联的DataReader实例 /// &lt;/summary> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;returns>&lt;/returns> public DbDataReader ExecuteReader(string sql, IList&lt;DbParameter> parameters) { return ExecuteReader(sql, parameters, CommandType.Text); } /// &lt;summary> /// 执行一个查询语句，返回一个关联的DataReader实例 /// &lt;/summary> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;param name=\"commandType\">执行的SQL语句的类型&lt;/param> /// &lt;returns>&lt;/returns> public DbDataReader ExecuteReader(string sql, IList&lt;DbParameter> parameters, CommandType commandType) { DbCommand command = CreateDbCommand(sql, parameters, commandType); command.Connection.Open(); return command.ExecuteReader(CommandBehavior.CloseConnection); } /// &lt;summary> /// 执行一个查询语句，返回一个包含查询结果的DataTable /// &lt;/summary> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;returns>&lt;/returns> public DataTable ExecuteDataTable(string sql, IList&lt;DbParameter> parameters) { return ExecuteDataTable(sql, parameters, CommandType.Text); } /// &lt;summary> /// 执行一个查询语句，返回一个包含查询结果的DataTable /// &lt;/summary> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;param name=\"commandType\">执行的SQL语句的类型&lt;/param> /// &lt;returns>&lt;/returns> public DataTable ExecuteDataTable(string sql, IList&lt;DbParameter> parameters, CommandType commandType) { using (DbCommand command = CreateDbCommand(sql, parameters, commandType)) { using (DbDataAdapter adapter = providerFactory.CreateDataAdapter()) { adapter.SelectCommand = command; DataTable data = new DataTable(); adapter.Fill(data); return data; } } } /// &lt;summary> /// 执行一个查询语句，返回查询结果的第一行第一列 /// &lt;/summary> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;returns>&lt;/returns> public Object ExecuteScalar(string sql, IList&lt;DbParameter> parameters) { return ExecuteScalar(sql, parameters, CommandType.Text); } /// &lt;summary> /// 执行一个查询语句，返回查询结果的第一行第一列 /// &lt;/summary> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;param name=\"commandType\">执行的SQL语句的类型&lt;/param> /// &lt;returns>&lt;/returns> public Object ExecuteScalar(string sql, IList&lt;DbParameter> parameters, CommandType commandType) { using (DbCommand command = CreateDbCommand(sql, parameters, commandType)) { command.Connection.Open(); object result = command.ExecuteScalar(); command.Connection.Close(); return result; } } /// &lt;summary> /// 查询多个实体集合 /// &lt;/summary> /// &lt;typeparam name=\"T\">返回的实体集合类型&lt;/typeparam> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;returns>&lt;/returns> public List&lt;T> QueryForList&lt;T>(string sql, IList&lt;DbParameter> parameters) where T : new() { return QueryForList&lt;T>(sql, parameters, CommandType.Text); } /// &lt;summary> /// 查询多个实体集合 /// &lt;/summary> /// &lt;typeparam name=\"T\">返回的实体集合类型&lt;/typeparam> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;param name=\"commandType\">执行的SQL语句的类型&lt;/param> /// &lt;returns>&lt;/returns> public List&lt;T> QueryForList&lt;T>(string sql, IList&lt;DbParameter> parameters, CommandType commandType) where T : new() { DataTable data = ExecuteDataTable(sql, parameters, commandType); return EntityReader.GetEntities&lt;T>(data); } /// &lt;summary> /// 查询单个实体 /// &lt;/summary> /// &lt;typeparam name=\"T\">返回的实体集合类型&lt;/typeparam> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;returns>&lt;/returns> public T QueryForObject&lt;T>(string sql, IList&lt;DbParameter> parameters) where T : new() { return QueryForObject&lt;T>(sql, parameters, CommandType.Text); } /// &lt;summary> /// 查询单个实体 /// &lt;/summary> /// &lt;typeparam name=\"T\">返回的实体集合类型&lt;/typeparam> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;param name=\"commandType\">执行的SQL语句的类型&lt;/param> /// &lt;returns>&lt;/returns> public T QueryForObject&lt;T>(string sql, IList&lt;DbParameter> parameters, CommandType commandType) where T : new() { return QueryForList&lt;T>(sql, parameters, commandType)[0]; } public DbParameter CreateDbParameter(string name, object value) { return CreateDbParameter(name, ParameterDirection.Input, value); } public DbParameter CreateDbParameter(string name, ParameterDirection parameterDirection, object value) { DbParameter parameter = providerFactory.CreateParameter(); parameter.ParameterName = name; parameter.Value = value; parameter.Direction = parameterDirection; return parameter; } /// &lt;summary> /// 创建一个DbCommand对象 /// &lt;/summary> /// &lt;param name=\"sql\">要执行的查询语句&lt;/param> /// &lt;param name=\"parameters\">执行SQL查询语句所需要的参数&lt;/param> /// &lt;param name=\"commandType\">执行的SQL语句的类型&lt;/param> /// &lt;returns>&lt;/returns> private DbCommand CreateDbCommand(string sql, IList&lt;DbParameter> parameters, CommandType commandType) { DbConnection connection = providerFactory.CreateConnection(); DbCommand command = providerFactory.CreateCommand(); connection.ConnectionString = ConnectionString; command.CommandText = sql; command.CommandType = commandType; command.Connection = connection; if (!(parameters == null || parameters.Count == 0)) { foreach (DbParameter parameter in parameters) { command.Parameters.Add(parameter); } } return command; } } EntityReader实体转换器 public sealed class EntityReader { private const BindingFlags BindingFlag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance; //将类型与该类型所有的可写且未被忽略属性之间建立映射 private static Dictionary&lt;Type, Dictionary&lt;string, PropertyInfo>> propertyMappings = new Dictionary&lt;Type, Dictionary&lt;string, PropertyInfo>>(); //存储Nullable&lt;T>与T的对应关系 private static Dictionary&lt;Type, Type> genericTypeMappings = new Dictionary&lt;Type, Type>(); static EntityReader() { genericTypeMappings.Add(typeof(Byte?), typeof(Byte)); genericTypeMappings.Add(typeof(SByte?), typeof(SByte)); genericTypeMappings.Add(typeof(Char?), typeof(Char)); genericTypeMappings.Add(typeof(Boolean?), typeof(Boolean)); genericTypeMappings.Add(typeof(Guid?), typeof(Guid)); genericTypeMappings.Add(typeof(Int16), typeof(Int16)); genericTypeMappings.Add(typeof(UInt16), typeof(UInt16)); genericTypeMappings.Add(typeof(Int32), typeof(Int32)); genericTypeMappings.Add(typeof(Int32?), typeof(Int32)); genericTypeMappings.Add(typeof(UInt32), typeof(UInt32)); genericTypeMappings.Add(typeof(Int64), typeof(Int64)); genericTypeMappings.Add(typeof(UInt64), typeof(UInt64)); genericTypeMappings.Add(typeof(Single), typeof(Single)); genericTypeMappings.Add(typeof(Single?), typeof(Single)); genericTypeMappings.Add(typeof(Double), typeof(Double)); genericTypeMappings.Add(typeof(Double?), typeof(Double)); genericTypeMappings.Add(typeof(Decimal), typeof(Decimal)); genericTypeMappings.Add(typeof(DateTime), typeof(DateTime)); genericTypeMappings.Add(typeof(DateTime?), typeof(DateTime)); genericTypeMappings.Add(typeof(TimeSpan), typeof(TimeSpan)); genericTypeMappings.Add(typeof(Enum), typeof(Enum)); } /// &lt;summary> /// 将DataTable中的所有数据转换成List&amp;gt;T&amp;lt;集合 /// &lt;/summary> /// &lt;typeparam name=\"T\">DataTable中每条数据可以转换的数据类型&lt;/typeparam> /// &lt;param name=\"dataTable\">包含有可以转换成数据类型T的数据集合&lt;/param> /// &lt;returns>&lt;/returns> public static List&lt;T> GetEntities&lt;T>(DataTable dataTable) where T : new() { if (dataTable == null) { throw new ArgumentNullException(\"dataTable\"); } //如果T的类型满足以下条件：字符串、ValueType或者是Nullable&lt;ValueType> if (typeof(T) == typeof(string) || typeof(T).IsValueType) { return GetSimpleEntities&lt;T>(dataTable); } else { return GetComplexEntities&lt;T>(dataTable); } } /// &lt;summary> /// 将DbDataReader中的所有数据转换成List&amp;gt;T&amp;lt;集合 /// &lt;/summary> /// &lt;typeparam name=\"T\">DbDataReader中每条数据可以转换的数据类型&lt;/typeparam> /// &lt;param name=\"dataTable\">包含有可以转换成数据类型T的DbDataReader实例&lt;/param> /// &lt;returns>&lt;/returns> public static List&lt;T> GetEntities&lt;T>(DbDataReader reader) where T : new() { List&lt;T> list = new List&lt;T>(); if (reader == null) { throw new ArgumentNullException(\"reader\"); } //如果T的类型满足以下条件：字符串、ValueType或者是Nullable&lt;ValueType> if (typeof(T) == typeof(string) || typeof(T).IsValueType) { return GetSimpleEntities&lt;T>(reader); } else { return GetComplexEntities&lt;T>(reader); } } /// &lt;summary> /// 从DataTable中将每一行的第一列转换成T类型的数据 /// &lt;/summary> /// &lt;typeparam name=\"T\">要转换的目标数据类型&lt;/typeparam> /// &lt;param name=\"dataTable\">包含有可以转换成数据类型T的数据集合&lt;/param> /// &lt;returns>&lt;/returns> private static List&lt;T> GetSimpleEntities&lt;T>(DataTable dataTable) where T : new() { List&lt;T> list = new List&lt;T>(); foreach (DataRow row in dataTable.Rows) { list.Add((T)GetValueFromObject(row[0], typeof(T))); } return list; } /// &lt;summary> /// 将指定的 Object 的值转换为指定类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;param name=\"targetType\">要转换的目标数据类型&lt;/param> /// &lt;returns>&lt;/returns> private static object GetValueFromObject(object value, Type targetType) { if (targetType == typeof(string))//如果要将value转换成string类型 { return GetString(value); } else if (targetType.IsGenericType)//如果目标类型是泛型 { return GetGenericValueFromObject(value, targetType); } else//如果是基本数据类型（包括数值类型、枚举和Guid） { return GetNonGenericValueFromObject(value, targetType); } } /// &lt;summary> /// 从DataTable中读取复杂数据类型集合 /// &lt;/summary> /// &lt;typeparam name=\"T\">要转换的目标数据类型&lt;/typeparam> /// &lt;param name=\"dataTable\">包含有可以转换成数据类型T的数据集合&lt;/param> /// &lt;returns>&lt;/returns> private static List&lt;T> GetComplexEntities&lt;T>(DataTable dataTable) where T : new() { if (!propertyMappings.ContainsKey(typeof(T))) { GenerateTypePropertyMapping(typeof(T)); } List&lt;T> list = new List&lt;T>(); Dictionary&lt;string, PropertyInfo> properties = propertyMappings[typeof(T)]; //Dictionary&lt;string, int> propertyColumnOrdinalMapping = GetPropertyColumnIndexMapping(dataTable.Columns, properties); T t; foreach (DataRow row in dataTable.Rows) { t = new T(); foreach (KeyValuePair&lt;string, PropertyInfo> item in properties) { //int ordinal = -1; //if (propertyColumnOrdinalMapping.TryGetValue(item.Key, out ordinal)) //{ // item.Value.SetValue(t, GetValueFromObject(row[ordinal], item.Value.PropertyType), null); //} if (dataTable.Columns.Contains(item.Key)) { item.Value.SetValue(t, GetValueFromObject(row[item.Key], item.Value.PropertyType), null); } } list.Add(t); } return list; } /// &lt;summary> /// 从DbDataReader的实例中读取复杂的数据类型 /// &lt;/summary> /// &lt;typeparam name=\"T\">要转换的目标类&lt;/typeparam> /// &lt;param name=\"reader\">DbDataReader的实例&lt;/param> /// &lt;returns>&lt;/returns> private static List&lt;T> GetComplexEntities&lt;T>(DbDataReader reader) where T : new() { if (!propertyMappings.ContainsKey(typeof(T)))//检查当前是否已经有该类与类的可写属性之间的映射 { GenerateTypePropertyMapping(typeof(T)); } List&lt;T> list = new List&lt;T>(); Dictionary&lt;string, PropertyInfo> properties = propertyMappings[typeof(T)]; //Dictionary&lt;string, int> propertyColumnOrdinalMapping = GetPropertyColumnIndexMapping(reader, properties); T t; while (reader.Read()) { t = new T(); foreach (KeyValuePair&lt;string, PropertyInfo> item in properties) { //int ordinal = -1; //if (propertyColumnOrdinalMapping.TryGetValue(item.Key, out ordinal)) //{ // item.Value.SetValue(t, GetValueFromObject(reader[ordinal], item.Value.PropertyType), null); //} item.Value.SetValue(t, GetValueFromObject(reader[item.Key], item.Value.PropertyType), null); } list.Add(t); } return list; } /// &lt;summary> /// 从DbDataReader的实例中读取简单数据类型（String,ValueType) /// &lt;/summary> /// &lt;typeparam name=\"T\">目标数据类型&lt;/typeparam> /// &lt;param name=\"reader\">DbDataReader的实例&lt;/param> /// &lt;returns>&lt;/returns> private static List&lt;T> GetSimpleEntities&lt;T>(DbDataReader reader) { List&lt;T> list = new List&lt;T>(); while (reader.Read()) { list.Add((T)GetValueFromObject(reader[0], typeof(T))); } return list; } /// &lt;summary> /// 将Object转换成字符串类型 /// &lt;/summary> /// &lt;param name=\"value\">object类型的实例&lt;/param> /// &lt;returns>&lt;/returns> private static object GetString(object value) { return Convert.ToString(value); } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;param name=\"targetType\">&lt;/param> /// &lt;returns>&lt;/returns> private static object GetEnum(object value, Type targetType) { return Enum.Parse(targetType, value.ToString()); } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetBoolean(object value) { if (value is Boolean) { return value; } else { byte byteValue = (byte)GetByte(value); if (byteValue == 0) { return false; } else { return true; } } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetByte(object value) { if (value is Byte) { return value; } else { return byte.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetSByte(object value) { if (value is SByte) { return value; } else { return SByte.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetChar(object value) { if (value is Char) { return value; } else { return Char.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetGuid(object value) { if (value is Guid) { return value; } else { return new Guid(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetInt16(object value) { if (value is Int16) { return value; } else { return Int16.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetUInt16(object value) { if (value is UInt16) { return value; } else { return UInt16.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetInt32(object value) { if (value is Int32) { return value; } else { return Int32.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetUInt32(object value) { if (value is UInt32) { return value; } else { return UInt32.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetInt64(object value) { if (value is Int64) { return value; } else { return Int64.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetUInt64(object value) { if (value is UInt64) { return value; } else { return UInt64.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetSingle(object value) { if (value is Single) { return value; } else { return Single.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetDouble(object value) { if (value is Double) { return value; } else { return Double.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetDecimal(object value) { if (value is Decimal) { return value; } else { return Decimal.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetDateTime(object value) { if (value is DateTime) { return value; } else { return DateTime.Parse(value.ToString()); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定枚举类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;returns>&lt;/returns> private static object GetTimeSpan(object value) { if (value is TimeSpan) { return value; } else { return TimeSpan.Parse(value.ToString()); } } /// &lt;summary> /// 将Object类型数据转换成对应的可空数值类型表示 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;param name=\"targetType\">可空数值类型&lt;/param> /// &lt;returns>&lt;/returns> private static object GetGenericValueFromObject(object value, Type targetType) { if (value == DBNull.Value) { return null; } else { //获取可空数值类型对应的基本数值类型，如int?->int,long?->long Type nonGenericType = genericTypeMappings[targetType]; return GetNonGenericValueFromObject(value, nonGenericType); } } /// &lt;summary> /// 将指定的 Object 的值转换为指定类型的值。 /// &lt;/summary> /// &lt;param name=\"value\">实现 IConvertible 接口的 Object，或者为 null&lt;/param> /// &lt;param name=\"targetType\">目标对象的类型&lt;/param> /// &lt;returns>&lt;/returns> private static object GetNonGenericValueFromObject(object value, Type targetType) { if (targetType.IsEnum)//因为 { return GetEnum(value, targetType); } else { switch (targetType.Name) { case \"Byte\": return GetByte(value); case \"SByte\": return GetSByte(value); case \"Char\": return GetChar(value); case \"Boolean\": return GetBoolean(value); case \"Guid\": return GetGuid(value); case \"Int16\": return GetInt16(value); case \"UInt16\": return GetUInt16(value); case \"Int32\": return GetInt32(value); case \"UInt32\": return GetUInt32(value); case \"Int64\": return GetInt64(value); case \"UInt64\": return GetUInt64(value); case \"Single\": return GetSingle(value); case \"Double\": return GetDouble(value); case \"Decimal\": return GetDecimal(value); case \"DateTime\": return GetDateTime(value); case \"TimeSpan\": return GetTimeSpan(value); default: return null; } } } /// &lt;summary> /// 获取该类型中属性与数据库字段的对应关系映射 /// &lt;/summary> /// &lt;param name=\"type\">&lt;/param> private static void GenerateTypePropertyMapping(Type type) { if (type != null) { PropertyInfo[] properties = type.GetProperties(BindingFlag); Dictionary&lt;string, PropertyInfo> propertyColumnMapping = new Dictionary&lt;string, PropertyInfo>(properties.Length); string description = string.Empty; Attribute[] attibutes = null; string columnName = string.Empty; bool ignorable = false; foreach (PropertyInfo p in properties) { ignorable = false; columnName = string.Empty; attibutes = Attribute.GetCustomAttributes(p); foreach (Attribute attribute in attibutes) { //检查是否设置了ColumnName属性 if (attribute.GetType() == typeof(ColumnNameAttribute)) { columnName = ((ColumnNameAttribute)attribute).ColumnName; ignorable = ((ColumnNameAttribute)attribute).Ignorable; break; } } //如果该属性是可读并且未被忽略的，则有可能在实例化该属性对应的类时用得上 if (p.CanWrite &amp;&amp; !ignorable) { //如果没有设置ColumnName属性，则直接将该属性名作为数据库字段的映射 if (string.IsNullOrEmpty(columnName)) { columnName = p.Name; } propertyColumnMapping.Add(columnName, p); } } propertyMappings.Add(type, propertyColumnMapping); } } } ColumnNameAttribute给实体类的属性设置名称，用作实体转换，如不设置则为定义的属性名 [AttributeUsage(AttributeTargets.Property)] public class ColumnNameAttribute : Attribute { /// &lt;summary> /// 类属性对应的列名 /// &lt;/summary> public string ColumnName { get; set; } /// &lt;summary> /// 指示在从DataTable或者DbDataReader中读取类的属性时是否可以忽略这个属性 /// &lt;/summary> public bool Ignorable { get; set; } /// &lt;summary> /// 构造函数 /// &lt;/summary> /// &lt;param name=\"columnName\">类属性对应的列名&lt;/param> public ColumnNameAttribute(string columnName) { ColumnName = columnName; Ignorable = false; } /// &lt;summary> /// 构造函数 /// &lt;/summary> /// &lt;param name=\"ignorable\">指示在从DataTable或者DbDataReader中读取类的属性时是否可以忽略这个属性&lt;/param> public ColumnNameAttribute(bool ignorable) { Ignorable = ignorable; } /// &lt;summary> /// 构造函数 /// &lt;/summary> /// &lt;param name=\"columnName\">类属性对应的列名&lt;/param> /// &lt;param name=\"ignorable\">指示在从DataTable或者DbDataReader中读取类的属性时是否可以忽略这个属性&lt;/param> public ColumnNameAttribute(string columnName, bool ignorable) { ColumnName = columnName; Ignorable = ignorable; } }","path":"2017/05/19/dbUtility/","date":"05-19","excerpt":""},{"title":"字符串加密类","text":"using System.Security; using System.Security.Cryptography; using System.Web; using System.IO; public class Encryption { //ＭＤ5 不区分大小写的 //type 类型，16位还是32位，16位就是取32位的第8到16位 public string DoMd5Encode(string pwd,string type) { byte[] result = Encoding.Default.GetBytes(pwd); MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); byte[] output = md5.ComputeHash(result); if (type == \"16\") return BitConverter.ToString(output).Replace(\"-\", \"\").ToLower().Substring(8,16); else return BitConverter.ToString(output).Replace(\"-\", \"\").ToLower(); } /// &lt;summary> /// 对字符串进行SHA1加密 /// &lt;/summary> /// &lt;param name=\"strIN\">需要加密的字符串&lt;/param> /// &lt;returns>密文&lt;/returns> public string SHA1_Encrypt(string Source_String) { byte[] StrRes = Encoding.Default.GetBytes(Source_String); HashAlgorithm iSHA = new SHA1CryptoServiceProvider(); StrRes = iSHA.ComputeHash(StrRes); StringBuilder EnText = new StringBuilder(); foreach (byte iByte in StrRes) { EnText.AppendFormat(\"{0:x2}\", iByte); } return EnText.ToString(); } /// &lt;summary> /// SHA256加密，不可逆转 /// &lt;/summary> /// &lt;param name=\"str\">string str:被加密的字符串&lt;/param> /// &lt;returns>返回加密后的字符串&lt;/returns> private string SHA256Encrypt(string str) { System.Security.Cryptography.SHA256 s256 = new System.Security.Cryptography.SHA256Managed(); byte[] byte1; byte1 = s256.ComputeHash(Encoding.Default.GetBytes(str)); s256.Clear(); return Convert.ToBase64String(byte1); } /// &lt;summary> /// SHA384加密，不可逆转 /// &lt;/summary> /// &lt;param name=\"str\">string str:被加密的字符串&lt;/param> /// &lt;returns>返回加密后的字符串&lt;/returns> private string SHA384Encrypt(string str) { System.Security.Cryptography.SHA384 s384 = new System.Security.Cryptography.SHA384Managed(); byte[] byte1; byte1 = s384.ComputeHash(Encoding.Default.GetBytes(str)); s384.Clear(); return Convert.ToBase64String(byte1); } /// &lt;summary> /// SHA512加密，不可逆转 /// &lt;/summary> /// &lt;param name=\"str\">string str:被加密的字符串&lt;/param> /// &lt;returns>返回加密后的字符串&lt;/returns> private string SHA512Encrypt(string str) { System.Security.Cryptography.SHA512 s512 = new System.Security.Cryptography.SHA512Managed(); byte[] byte1; byte1 = s512.ComputeHash(Encoding.Default.GetBytes(str)); s512.Clear(); return Convert.ToBase64String(byte1); } //默认密钥向量 private byte[] Keys = { 0xEF, 0xAB, 0x56, 0x78, 0x90, 0x34, 0xCD, 0x12 }; /// &lt;summary> /// DES加密字符串 /// &lt;/summary> /// &lt;param name=\"encryptString\">待加密的字符串&lt;/param> /// &lt;param name=\"encryptKey\">加密密钥,要求为8位&lt;/param> /// &lt;returns>加密成功返回加密后的字符串，失败返回源串&lt;/returns> public string EncryptDES(string encryptString, string encryptKey) { try { byte[] rgbKey = Encoding.UTF8.GetBytes(encryptKey.Substring(0, 8)); byte[] rgbIV = Keys; byte[] inputByteArray = Encoding.UTF8.GetBytes(encryptString); DESCryptoServiceProvider dCSP = new DESCryptoServiceProvider(); MemoryStream mStream = new MemoryStream(); CryptoStream cStream = new CryptoStream(mStream, dCSP.CreateEncryptor(rgbKey, rgbIV), CryptoStreamMode.Write); cStream.Write(inputByteArray, 0, inputByteArray.Length); cStream.FlushFinalBlock(); return Convert.ToBase64String(mStream.ToArray()); } catch { return encryptString; } } /// &lt;summary> /// DES解密字符串 /// &lt;/summary> /// &lt;param name=\"decryptString\">待解密的字符串&lt;/param> /// &lt;param name=\"decryptKey\">解密密钥,要求为8位,和加密密钥相同&lt;/param> /// &lt;returns>解密成功返回解密后的字符串，失败返源串&lt;/returns> public string DecryptDES(string decryptString, string decryptKey) { try { byte[] rgbKey = Encoding.UTF8.GetBytes(decryptKey.Substring(0, 8)); byte[] rgbIV = Keys; byte[] inputByteArray = Convert.FromBase64String(decryptString); DESCryptoServiceProvider DCSP = new DESCryptoServiceProvider(); MemoryStream mStream = new MemoryStream(); CryptoStream cStream = new CryptoStream(mStream, DCSP.CreateDecryptor(rgbKey, rgbIV), CryptoStreamMode.Write); cStream.Write(inputByteArray, 0, inputByteArray.Length); cStream.FlushFinalBlock(); return Encoding.UTF8.GetString(mStream.ToArray()); } catch { return decryptString; } } }","path":"2017/05/18/str-encryption/","date":"05-18","excerpt":""},{"title":"C#中的泛型","text":"概念msdn中对泛型的描述：泛型是 2.0 版 C# 语言和公共语言运行库 (CLR) 中的一个新功能。泛型将类型参数的概念引入 .NET Framework，类型参数使得设计如下类和方法成为可能：这些类和方法将一个或多个类型的指定推迟到客户端代码声明并实例化该类或方法的时候。例如，通过使用泛型类型参数 T，您可以编写其他客户端代码能够使用的单个类，而不致引入运行时强制转换或装箱操作的成本或风险。 泛型是.NET Framework中定义的一个语法糖，将类型指定推迟。 泛型类在类名后指定即可创建泛型类，示例代码如下: public class Person&lt;T> { private T _t; public T t { get { return _t; } set { _t = value; } } public string Name { get { return _name; } set { _name = value; } } private string _name; public void Show() { Console.WriteLine(typeof(T)); Console.WriteLine(\"My name is \"+_name); } } 在控制台应用程序中调用: static void Main(string[] args) { //示例1 Person&lt;Program> p = new Person&lt;Program>(); p.Name = \"Tom\"; p.Show(); //示例2 Person&lt;int> pi = new Person&lt;int>(); pi.Name = \"Taffy\"; pi.Show(); Console.Read(); } 输出结果如下: ConsoleApplication2.Program My name is Tom System.Int32 My name is Taffy 注意：在声明泛型类型T的时候，并不一定要叫T,且可以有多个泛型类型，如： Person&lt;T t,TFirst tf,TLast tl> 泛型接口和泛型类类似 泛型方法给方法名后指定则可以声明泛型方法，可在参数、方法体和返回值中使用，示例如下： public class Person { public string Name { get { return _name; } set { _name = value; } } private string _name; public void Show&lt;T>(T t) { Console.WriteLine(typeof(T)); Console.WriteLine(t); Console.WriteLine(\"My name is {0}\\n\", _name); } } 调用方式: static void Main(string[] args) { Person p = new Person(); p.Name = \"Tom\"; p.Show&lt;int>(52); Console.Read(); } 输出结果如下: System.Int32 52 My name is Tom 泛型委托public delegate void Del&lt;T>(T item); public static void Notify(int i) { } Del&lt;int> m2 = Notify; 预定义的泛型委托:Func,Action,Predicate, 其中，Func一般用来处理有返回值的情况，Action处理无返回值的情况，Predicate一般用作判断条件。 Predicate的示例用法如下： class Program { bool IsGreaterThan50(int i) { if (i > 50) return true; else return false; } static void Main(string[] args) { Program p=new Program(); List&lt;int> lstInt = new List&lt;int>(); lstInt.Add(50); lstInt.Add(80); lstInt.Add(90); Predicate&lt;int> pred = p.IsGreaterThan50; int i = lstInt.Find(pred); // 找到匹配的第一个元素，此处为50 Console.WriteLine(\"大于50的第一个元素为{0}\",i); List&lt;int> all = lstInt.FindAll(pred); for (int j = 0; j &lt; all.Count(); j++) { Console.WriteLine(\"大于50的数组中元素为{0}\", all[j]); // 找出所有匹配条件的 } Console.ReadLine(); } } 参考链接 泛型约束在泛型类名或泛型方法名后指定 where T:约束条件 ，可给泛型类型添加约束，约束条件如下: where T : struct -类型T必须是值类型 where T : class -类型T必须是引用类型 where T : Ifoo -类型T必须实现接口Ifoo where T : foo -类型T必须继承自 foo where T : new() -类型T必须有一个无参构造函数 where T : U -指定泛型类型T必须派生于U。 约束可设置多个，以逗号隔开 default关键字在泛型类和泛型方法中产生的一个问题是，在预先未知以下情况时，如何将默认值分配给参数化类型 T： T 是引用类型还是值类型。 如果 T 为值类型，则它是数值还是结构。 给定参数化类型 T 的一个变量 t，只有当 T 为引用类型时，语句 t = null 才有效；只有当 T 为数值类型而不是结构时，语句 t = 0 才能正常使用。解决方案是使用 default 关键字，此关键字对于引用类型会返回空，对于数值类型会返回零。对于结构，此关键字将返回初始化为零或空的每个结构成员，具体取决于这些结构是值类型还是引用类型。 public class GenericList&lt;T> { private class Node { //... public Node Next; public T Data; } private Node head; //... public T GetNext() { T temp = default(T); Node current = head; if (current != null) { temp = current.Data; current = current.Next; } return temp; } } 协变和逆变协变如果某个返回的类型可以由其派生类型替换，那么这个类型就是支持协变的。在C#4.0之前是不支持的。 通俗点说就是，左边泛型类型可用父类，右边可用子类. 协变的泛型参数只能作为接口成员或泛型委托的返回值。 实现方式：在泛型形参前面加上out关键字即可 示例代码: interface IPerson&lt;out T> { } class Person&lt;T>:IPerson&lt;T> { } class BaseClass { } class SonClass:BaseClass { } 效果如下: IPerson&lt;BaseClass> person = new Person&lt;SonClass>(); 逆变如果某个参数类型可以由其基类替换，那么这个类型就是支持逆变的。 即：左边的泛型类型可以是子类，右边是父类。 逆变的泛型参数只能作为接口成员的传入参数 在泛型形参前面加上in关键字即可, 示例代码: interface IPerson&lt;in T> { } class Person&lt;T>:IPerson&lt;T> { } class BaseClass { } class SonClass:BaseClass { } 效果如下: IPerson&lt;SonClass> person = new Person&lt;BaseClass>();+ 协变和逆变只可以用于泛型接口和泛型委托，只能用于引用类型的转换，当方法的参数使用了ref或out关键字时将禁止协变和逆变。 泛型的一些实际应用泛型用作缓存public class GenericCache&lt;T> { static T instance; public static T Instance { get { return instance; } set { instance = value; } } } 原理 这运用了C#的一些基础知识:定义为静态的任何东西，永远不可能被回收，除非你自己将其设置为null，将引用去掉了，才可能被GC回收，如果遇到奇怪的现象，请检查代码其它地方。 缺点 无法清除缓存，一个类型只能有一个缓存，不过可以定义为集合。 泛型单例public class Singleton&lt;T> where T : new() { /// &lt;summary> /// 单例实例 /// &lt;/summary> private static T instance; /// &lt;summary> /// 线程锁 /// &lt;/summary> private static object obj = new object(); /// &lt;summary> /// 静态单例 /// &lt;/summary> public static T Instance { get { if (instance == null) { lock (obj) { if (instance == null) { instance = new T(); } } } return instance; } } } 当其他类继承这个类时，便自动拥有了父类的单例属性。 缺点： 子类的无参构造方法必须是公共的，意味着子类可以被实例化，无法强制让其使用单例。","path":"2017/05/18/fanxing/","date":"05-18","excerpt":""},{"title":"Oracle触发器及包创建","text":"示例代码如下: create table myTable ( id integer constraint pk_myTable primary key, userName varchar2(20) not null, userPwd varchar2(80) not null ) /********创建序列**********/ create sequence seq_Num start with 1 increment by 1 nomaxvalue nocache; /**创建触发器***/ create or replace trigger tri_Identity before insert on ytf.mytable for each row when (new.id is null) --触发条件(for each row 行触发器) begin select seq_Num.Nextval into:new.id from dual; end; insert into myTable(userName,userPwd) values('张三','123456'); insert into myTable(userName,userPwd) values('李四','123456'); insert into myTable(userName,userPwd) values('王五','123456'); insert into myTable(userName,userPwd) values('赵六','123456'); commit; select * from myTable; /****创建触发器***/ create or replace trigger tri_test before insert or update or delete on ytf.mytable begin case when inserting then dbms_output.put_line('这是添加操作'); when updating then dbms_output.put_line('这是修改操作'); when deleting then raise_application_error('-20001','不允许删除'); end case; end; insert into ytf.mytable(userName,userpwd) values ('田七','123456'); commit; update ytf.mytable m set m.userpwd='52565656' where m.id=2; commit; delete ytf.mytable m where m.id=3; commit; select * from ytf.mytable; /*****创建包头*****/ create or replace package pkg_test is procedure proc_test(ff integer,tt out varchar2); function func_test(fu integer) return varchar2; end pkg_test; /******创建包体********/ create or replace package body pkg_test is procedure proc_test(ff integer,tt out varchar2) is begin select m.username into tt from ytf.mytable m where m.id=ff; end; function func_test(fu integer) return varchar2 is temp varchar2(20); begin select m.username into temp from ytf.mytable m where m.id=fu; return temp; end; end pkg_test; --测试 select pkg_test.func_test(1) from dual ;","path":"2017/05/16/oracletrigger/","date":"05-16","excerpt":""},{"title":"浅谈lock关键字","text":"作用标志某个语句模块为临界区，当一个线程进入临界区后，会阻止另一个线程访问该语句模块。？进入等待队列直到被通知等待资源被释放。 实现实质上是对Monitor.Enter与Monitor.Exit方法的封装。线程通过获得对象锁来得到对象的访问权力，当一个线程拥有对象锁时，其它线程就会被阻止。 建议定义一个private成员来实现对象锁，或者是private static 对象变量来保护所有实例对共有数据的访问。 示例： private object X=new object(); lock（X） { //需要锁定的代码.... } X是任意一种引用类型，它在这儿起的作用就是任何线程执行到lock（X）时候，X需要独享才能运行下面的代码,若假定现在有3个线程A,B,C都执行到了lock（X）而ABC因为此时都占有X，这时ABC就要停下来排个队，一个一个使用X，从而起到在下面的代码块内只有一个线程在运行（因为此时只有一个线程独享X，其余两个在排队），所以这个X必须是所有要执行临界区域代码进程必须共有的一个资源，从而起到抑制线程的作用。参考 线程死锁产生原因产生死锁的原因主要是因为系统资源不足。进程运行推进的顺序不合适。资源分配不当等。如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。 产生死锁的四个必要条件 互斥条件:一个资源每次只能被一个进程使用。此时若有其他进程请求该资源，则请求进程只能等待。 请求与保持条件:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁 如何避免死锁加锁顺序（线程按照一定的顺序加锁）如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。如果一个线程需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。 加锁时限线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁 死锁检测","path":"2017/05/15/lock/","date":"05-15","excerpt":""},{"title":"C#多线程","text":"多线程基础进程的概念当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源。而一个进程又是由多个线程所组成的。 线程的概念线程是程序中的一个执行流，每个线程都有自己的专有寄存器(栈指针、程序计数器等)，但代码区是共享的，即不同的线程可以执行同样的函数。 多线程的概念多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。 多线程的好处可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率。 多线程的不利方面 线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； 多线程需要协调和管理，所以需要CPU时间跟踪线程； 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题； 线程太多会导致控制太复杂，最终可能造成很多Bug； 何时使用多线程多线程程序一般被用来在后台执行耗时的任务。主线程保持运行，并且工作线程做它的后台工作。对于Windows Forms程序来说，如果主线程试图执行冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应。由于这个原因，应该在工作线程中运行一个耗时任务时添加一个工作线程，即使在主线程上有一个有好的提示“处理中…”，以防止工作无法继续。这就避免了程序出现由操作系统提示的“没有相应”，来诱使用户强制结束程序的进程而导致错误。模式对话框还允许实现“取消”功能，允许继续接收事件，而实际的任务已被工作线程完成。BackgroundWorker恰好可以辅助完成这一功能。 在没有用户界面的程序里，比如说Windows Service， 多线程在当一个任务有潜在的耗时，因为它在等待另台电脑的响应（比如一个应用服务器，数据库服务器，或者一个客户端）的实现特别有意义。用工作线程完成任务意味着主线程可以立即做其它的事情。 另一个多线程的用途是在方法中完成一个复杂的计算工作。这个方法会在多核的电脑上运行的更快，如果工作量被多个线程分开的话（使用Environment.ProcessorCount属性来侦测处理芯片的数量）。 一个C#程序称为多线程的可以通过2种方式：明确地创建和运行多线程，或者使用.NET framework的暗中使用了多线程的特性——比如BackgroundWorker类, 线程池，threading timer，远程服务器，或Web Services或ASP.NET程序。在后面的情况，人们别无选择，必须使用多线程；一个单线程的ASP.NET web server不是太酷，即使有这样的事情；幸运的是，应用服务器中多线程是相当普遍的；唯一值得关心的是提供适当锁机制的静态变量问题。 何时避免使用多线程多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂，拥有多线程本身并不复杂，复杂是的线程的交互作用，这带来了无论是否交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的bug。因此，要么多线程的交互设计简单一些，要么就根本不使用多线程。除非你有强烈的重写和调试欲望。 当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。 使用Parallel类Parallel类是对线程的一个很好的抽象，位于System.Threading.Tasks名称空间中，提供了数据和任务的并行性。 Parallel类定义了并行的for和foreach的静态方法。对于C#的for和foreach语句而言，循环从一个线程中运行。Parallel使用多个任务，因此使用多个线程来完成这个作业。 Parallel.For() 循环static void Main(string[] args) { Stopwatch watch = new Stopwatch(); watch.Start(); //并行循环代码 ParallelLoopResult result = Parallel.For(0,10,i=> { Thread.Sleep(10); Console.WriteLine(i); }); watch.Stop(); if (result.IsCompleted) { Console.WriteLine(\"Parallel.For已完成,耗时:\" + watch.ElapsedMilliseconds+\"毫秒\"); } watch.Restart(); /********************************************************/ //普通循环代码 for (int i = 0; i &lt; 10; i++) { Thread.Sleep(10); Console.WriteLine(i); } watch.Stop(); Console.WriteLine(\"for已完成,耗时:\" + watch.ElapsedMilliseconds + \"毫秒\"); Console.ReadKey(); } 输出结果如下: 8 6 2 4 0 7 1 3 5 9 Parallel.For已完成,耗时:45毫秒 0 1 2 3 4 5 6 7 8 9 for已完成,耗时:132毫秒 由于Parallel.For是并行循环，所以输出结果是无序的。当Thread.Sleep中的值越大时，并行循环与for的耗时差距越大,在不加Thread.Sleep时,for循环比并行循环耗时更少。 使用Parallel.Invoke()并行调用多个方法static void Main(string[] args) { // // 摘要: // 尽可能并行执行提供的每个操作。 // // 参数: // actions: // 要执行的 System.Action 数组。 // // 异常: // T:System.ArgumentNullException: // actions 参数为 null。 // // T:System.AggregateException: // 当 actions 数组中的任何操作引发异常时引发的异常。 // // T:System.ArgumentException: // actions数组包含 null 个元素。 //public static void Invoke(params Action[] actions); Parallel.Invoke(Fone, Ftwo); } static void Fone() { for (int i = 0; i &lt; 3; i++) { Console.WriteLine(i); } } static void Ftwo() { for (int i = 4; i &lt; 10; i++) { Console.WriteLine(i); } } 输出结果如下： 0 4 5 6 7 8 9 1 2 使用Thread类创建不带参数线程Thread类可以创建和控制线程，Thread类的构造函数重载为接受ThreadStart和ParameterizedThreadStart类型的委托参数。下面我们用一个例子来解释怎样用Thread类来创建一个简单的线程: static void Main(string[] args) { #region Thread无参数举例 Thread th = new Thread(ThreadChild); th.Start(); Console.WriteLine(\"Main Thread Start!\"); #endregion } static void ThreadChild() { Console.WriteLine(\"Child Thread Start!\"); } 输出结果如下 Main Thread Start! Child Thread Start! 程序运行的结果不能保证哪个先输出，因为线程是由操作系统调度，每次哪个线程在前面可以不同 创建带参数的线程上面的例子演示了怎样用Thread类来创建一个不带传参的线程，下面我门来创建一个带传入参数的线程。给线程传递参数，有两种方式: 一种是使用带ParameterizedThreadStart委托参数的Thread的构造函数 。 一种是定义一个自定义类。首先我们使用ParameterizedThreadStart委托来创建有传入参数的类。 使用ParameterizedThreadStart，线程的入口（线程调用的方法）必须有一个Object类型的参数，使用Object我们首先想到的就是类型不安全。而且在执行线程的时候多半有装箱拆箱操作。我们先用这种方式来创建一个带传入参数的线程： static void Main(string[] args) { #region 使用parameterizedThreadStart委托执行带参数的委托 Thread th2 = new Thread(Thread_param); th2.Start(20); #endregion } static void Thread_param(object msg) { int message = (int)msg; Console.WriteLine(\"Result:{0}\",message); } 输出结果： Result:20 上面创建的线程是类型不安全的，那用什么样的方式执行带传入参数的线程的方法是类型安全的呢，答案就是创建一个自定义类，在类中定义一个作为传入参数的字段，将线程的主方法定义为一个类的实例方法。然而使用这种方法就可以使用泛型来解决使用ParameterizedThreadStart的类型不安全: class Program { static void Main(string[] args) { #region 使用自定义类实现带参数的线程 MyThread&lt;string> mythread = new MyThread&lt;string>(\"Thread_child\"); Thread th3 = new Thread(mythread.ThreadChild); th3.Start(); #endregion } } class MyThread&lt;T> { private T data; public MyThread(T data) { this.data = data; } public void ThreadChild() { Console.WriteLine(\"Child Thread Start! Result:{0}\",data); } } 输出结果: Child Thread Start! Result:Thread_child 关于后台线程前台线程的概念： 只要有一个前台线程在运行，应用程序的进程就在运行。如果有多个前台线程在运行，而Main()方法（主线程）结束了，应用程序的进程就仍然是激活的，直到所有前台线程完成其任务为止。 后台线程的概念： 和前台线程相反。当主线程结束后，应用程序的进程就终止了，在所有前台线程结束后，后台线程就会被终止。 Thread类默认创建的是前台线程，所以我们前面创建的线程全部都是前台线程。 在编码的时候我们可以设置Thread类的IsBackground的属性来确定该线程是前台线程还是后台线程。当IsBackground设置为False的时候，为前台线程，设置为Ture的时候为后台线程，下面我们举例来说明前台线程和后台线程的区别。首先我们创建一个前台线程: static void Main(string[] args) { Thread th_pre = new Thread(Thread_pre) {Name=\"Thread_pre\",IsBackground=flase};; th_pre.Start(); Console.WriteLine(\"主线程执行完成！\"); } static void Thread_pre() { Console.WriteLine(\"子线程开始执行！\"); Thread.Sleep(3000); Console.WriteLine(\"子线程执行完成！\"); } 输出结果： 主线程执行完成！ 子线程开始执行！ 子线程执行完成！ 从上面的运行结果可以看到，当主线程执行完成后，应用程序终止前就会子线程执行完成。 后台线程： static void Main(string[] args) { Thread th_back = new Thread(Thread_back) { Name=\"Thread_back\",IsBackground=true }; th_back.Start(); Console.WriteLine(\"主线程执行完成！\"); } static void Thread_back() { Console.WriteLine(\"子线程开始执行！\"); Thread.Sleep(3000); Console.WriteLine(\"子线程执行完成！\"); } 输出结果： 主线程执行完成！ 子线程开始执行！ 从运行结果可以看出，当主线程结束后，进程就终止了，后台线程也被终止，所以没有后台线程结束的输出信息 控制线程我们使用Thread创建线程后，我们需要对线程进行控制。 1、 使用Start()方法使线程处于Running状态，线程开始执行。 2、 使用Join（）方法使线程处于WaitSleepJoin状态，在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止或经过了指定时 间为止。 3、 使用Sleep()方法，也会使线程处于WaitSleepJoin状态，在经历Sleep()方法定义的时间段后，线程就会被再次唤醒。、 4、 使用Abort()方法，会使线程处于ResetAbort()状态，线程在接到这个命令的时候，会抛出一个ThradAbordException类型的异常。 class Program { static void Main(string[] args) { Console.WriteLine(\"mainThread Start!\"); Thread th = new Thread(newThread); th.Start();//将当前实例的状态更改为 ThreadState.Running。 Console.WriteLine(\"newThread State:{0}\",th.ThreadState); th.Join(100);//在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止或经过了指定时间为止。 Console.WriteLine(\"newThread State:{0}\", th.ThreadState); th.Abort();//在调用此方法的线程上引发 ThreadAbortException，以开始终止此线程的过程。 调用此方法通常会终止线程。 Console.WriteLine(\"newThread State:{0}\", th.ThreadState); } static void newThread() { Console.WriteLine(\"newThread Start!\"); Thread.Sleep(10000); Console.WriteLine(\"newThread Complete!\"); } } 参考链接 使用线程池创建线程线程池使用ThreadPool类的QueueUserWorkItem方法创建线程，此方法可传递一个委托： /// &lt;summary> /// 一个比较耗时耗资源的私有方法 /// &lt;/summary> /// &lt;param name=\"name\">&lt;/param> private void DoSomethingLong(string name) { Console.WriteLine($\"****************DoSomethingLong Start {name} {Thread.CurrentThread.ManagedThreadId} {DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss fff\")}***************\"); long lResult = 0; for (int i = 0; i &lt; 2000000000; i++) { lResult += i; } //Thread.Sleep(2000); Console.WriteLine($\"****************DoSomethingLong End {name} {Thread.CurrentThread.ManagedThreadId} {DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss fff\")}***************\"); } ThreadPool.QueueUserWorkItem(t => { this.DoSomethingLong(\"btnThreadPool_Click\");//耗时操作 }); 异步编程模型（APM）异步编程模型 (APM)是.NET1.0的时候就已经推出的古老异步编程模式，此模式基于IAsyncResult接口实现。 BeginInvoke:开始异步执行委托。EndInvoke:获取异步执行结果。 使用BeginInvoke异步执行无返回值委托示例： Action myNoParAction = new Action(() => { Console.WriteLine(\"无参数委托方法体\");}); ; myNoParAction.BeginInvoke(t => { Console.WriteLine(\"这是回调\"); Console.WriteLine(t.AsyncState); }, \"这是回调参数\"); Console.WriteLine(\"主线程***********\"); 输出结果为： 主线程*********** 无参数委托方法体 这是回调 这是回调参数 异步执行带参数的委托： Action&lt;string> myAction = new Action&lt;string>(t => { Console.WriteLine(\"委托方法体\"); Console.WriteLine(t); }); ; myAction.BeginInvoke(\"参数来了\", t => { Console.WriteLine(\"这是回调\"); Console.WriteLine(t.AsyncState); }, null); Console.WriteLine(\"主线程*************\"); 输出结果为： 主线程************* 委托方法体 参数来了 这是回调 回调方法的参数使用AsyncState来接收，无参数则为null。 使用EndInvoke获取异步执行的返回结果示例如下： Func&lt;string> myAction = new Func&lt;string>(() => { Console.WriteLine(\"委托方法体\"); return \"这是委托返回值\"; }); ; IAsyncResult asyncResult = myAction.BeginInvoke(t => { Console.WriteLine(\"这是回调\"); Console.WriteLine(t.AsyncState); }, null); string result = myAction.EndInvoke(asyncRes 输出结果为： 委托方法体 这是回调 这是委托返回值 主线程************* 从返回结果可以看出，在调用EndInvoke时会等待异步操作完成，阻塞主线程。 基于任务的异步模式（TAP）任务的创建示例代码如下: static void Main(string[] args) { //创建方式1 TaskFactory tf = new TaskFactory(); tf.StartNew(TaskMethod ,\"使用new TaskFactory()创建\"); //创建方式2 Task.Factory.StartNew(TaskMethod, \"使用Task.Factory创建\"); //创建方式3 Task task = new Task(TaskMethod, \"使用new Task创建\"); task.Start(); Console.ReadKey(); } //线程锁 static object tasklock = new object(); static void TaskMethod(object title) { lock (tasklock) { Console.WriteLine(title.ToString()); Console.WriteLine(\"Task Id :{0},Thread:{1}\", Task.CurrentId==null?\"no task\":Task.CurrentId.ToString(), Thread.CurrentThread.ManagedThreadId); Console.WriteLine(\"是否属于线程池:{0}\\n\", Thread.CurrentThread.IsThreadPoolThread); } } 输出结果如下: 使用Task.Factory创建 Task Id :1,Thread:5 是否属于线程池:True 使用new TaskFactory()创建 Task Id :2,Thread:4 是否属于线程池:True 使用new Task创建 Task Id :3,Thread:3 是否属于线程池:True 以上示例中的三种方式均可创建异步任务,并且都在线程池中运行。 任务等待和回调的异步任务 WaitAll等待集合中所有任务执行完后继续。 WaitAny等待集合中任一任务执行完成。 ContinueWhenAny任意一个任务完成后要执行的异步任务。 ContinueWhenAll所有任务完成后要执行的异步任务。 1、2会阻塞主线程，3、4不会 示例代码如下： static void Main(string[] args) { //任务集合 List&lt;Task> taskList = new List&lt;Task>(); //创建5个任务 for (int i = 0; i &lt; 5; i++) { string name = string.Format(\"btnTask_Click_\" + i); Task task = Task.Factory.StartNew(() => DoSomethingLong(name)); taskList.Add(task); } //taskList中任意一个任务完成后执行的任务 并将自身加入集合 taskList.Add(Task.Factory.ContinueWhenAny(taskList.ToArray(), t => { Console.WriteLine(t.IsCompleted); Console.WriteLine(\"ContinueWhenAny\" + Thread.CurrentThread.ManagedThreadId); })); //taskList中所有任务完成任务完成后执行的任务 并将自身加入集合 taskList.Add(Task.Factory.ContinueWhenAll(taskList.ToArray(), tList => { Console.WriteLine(tList[0].IsCompleted); Console.WriteLine(\"ContinueWhenAll\" + Thread.CurrentThread.ManagedThreadId); })); //回调形式的，全部任务完成后执行的后续动作 Console.WriteLine(\"before WaitAny\"); Task.WaitAny(taskList.ToArray());//当前线程等待某个任务的完成 Console.WriteLine(\"after WaitAny\"); Console.WriteLine(\"before WaitAll\"); Task.WaitAll(taskList.ToArray());//当前线程等待全部任务的完成 Console.WriteLine(\"after WaitAll\"); Console.Read(); } /// &lt;summary> /// 一个比较耗时耗资源的私有方法 /// &lt;/summary> /// &lt;param name=\"name\">&lt;/param> private static void DoSomethingLong(string name) { Console.WriteLine(\"****************DoSomethingLong Start \" + name + Thread.CurrentThread.ManagedThreadId + DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss fff\") + \"***************\"); long lResult = 0; for (int i = 0; i &lt; 2000000000; i++) { lResult += i; } //Thread.Sleep(2000); Console.WriteLine(\"****************DoSomethingLong End \" + name + Thread.CurrentThread.ManagedThreadId + DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss fff\") + \"***************\"); } 同步任务使用Task类的实例方法RunSynchronously()可以让任务同步运行，示例代码: static void Main(string[] args) { Task task = new Task(TaskMethod, \"使用new Task创建\"); // // 摘要: // 对当前的 System.Threading.Tasks.TaskScheduler 同步运行 System.Threading.Tasks.Task。 // // 异常: // T:System.ObjectDisposedException: // 已释放 System.Threading.Tasks.Task 实例。 // // T:System.InvalidOperationException: // System.Threading.Tasks.Task 未处于有效状态，无法启动。它可能已启动、已执行或已取消，或者可能已经以不支持直接计划的方式创建。 task.RunSynchronously(); Console.WriteLine(\"Hello\"); Console.ReadKey(); } //线程锁 static object tasklock = new object(); static void TaskMethod(object title) { lock (tasklock) { Console.WriteLine(title.ToString()); Console.WriteLine(\"Task Id :{0},Thread:{1}\", Task.CurrentId==null?\"no task\":Task.CurrentId.ToString(), Thread.CurrentThread.ManagedThreadId); Console.WriteLine(\"是否属于线程池:{0}\\n\", Thread.CurrentThread.IsThreadPoolThread); } } 输出结果如下: 使用new Task创建 Task Id :1,Thread:1 是否属于线程池:False Hello 对长时间运行的任务使用单独线程如果任务的代码需要长时间运行，就应该使用TaskCreationOptions.LongRunning告诉任务调度器创建一个新线程来运行此任务，而不是使用线程池中的线程。因为在线程池中，任务调度器可能会在创建其他任务时等待当前任务完成。示例如下： static void Main(string[] args) { // // 摘要: // 指定任务将是长时间运行的、粗粒度的操作，涉及比细化的系统更少、更大的组件。它会向 System.Threading.Tasks.TaskScheduler // 提示，过度订阅可能是合理的。您可以通过过度订阅创建比可用硬件线程数更多的线程。 Task task = new Task(TaskMethod, \"使用new Task创建\", TaskCreationOptions.LongRunning); task.Start(); Console.WriteLine(\"Hello\"); Console.WriteLine(\"Task Id :{0},Thread:{1}\\n\", Task.CurrentId == null ? \"no task\" : Task.CurrentId.ToString(), Thread.CurrentThread.ManagedThreadId); Console.ReadKey(); } static void TaskMethod(object title) { Thread.Sleep(1000); Console.WriteLine(title.ToString()); Console.WriteLine(\"Task Id :{0},Thread:{1}\", Task.CurrentId == null ? \"no task\" : Task.CurrentId.ToString(), Thread.CurrentThread.ManagedThreadId); Console.WriteLine(\"是否属于线程池:{0}\\n\", Thread.CurrentThread.IsThreadPoolThread); } 输出结果如下： Hello Task Id :no task,Thread:1 使用new Task创建 Task Id :1,Thread:3 是否属于线程池:False 创建具有返回值的异步任务使用泛型Task可创建具有返回值的异步任务，示例代码如下: static void Main(string[] args) { // // 摘要: // 使用指定的函数和状态初始化新的 System.Threading.Tasks.Task`1。 // // 参数: // function: // 表示要在任务中执行的代码的委托。在完成此函数后，该任务的 System.Threading.Tasks.Task`1.Result 属性将设置为返回此函数的结果值。 // // state: // 一个表示由该操作使用的数据的对象。 // // 异常: // T:System.ArgumentNullException: // function 参数为 null。 Task&lt;string> task = new Task&lt;string>(TaskMethod,\"来自Main的参数\"); task.Start(); task.Wait();//等待任务执行完成 Console.WriteLine(task.Result); Console.WriteLine(\"执行完成\"); Console.ReadKey(); } static string TaskMethod(object title) { Thread.Sleep(2000); Console.WriteLine(title.ToString()); Console.WriteLine(\"Task Id :{0},Thread:{1}\", Task.CurrentId == null ? \"no task\" : Task.CurrentId.ToString(), Thread.CurrentThread.ManagedThreadId); Console.WriteLine(\"是否属于线程池:{0}\\n\", Thread.CurrentThread.IsThreadPoolThread); return \"来自TaskMethod的返回值\"; } 输出结果为: 来自Main的参数 Task Id :1,Thread:3 是否属于线程池:True 来自TaskMethod的返回值 执行完成 等待任务执行完成的方法: //等待当前 System.Threading.Tasks.Task 完成执行过程。 public void Wait(); //等待传入的所有任务完成 public static void WaitAll(params Task[] tasks); //等待传入的任意一个任务完成 public static int WaitAny(params Task[] tasks) 在获取任务的返回值时，如果任务尚未执行完成，则Result属性将被禁用并会等待任务执行完成，所以示例中不加task.Wait()执行结果也一样。 延续的任务在任务上调用ContinueWith()方法来启动当前任务完成后的任务。示例如下： static void Main(string[] args) { Task t = new Task(One); Task t1= t.ContinueWith(Two); Task t2 = t1.ContinueWith(Two); Task t3 = t2.ContinueWith(Two); t.Start(); Console.Read(); } static void One() { Console.WriteLine(\"TaskID:{0}\" , Task.CurrentId); Console.WriteLine(\"this is One\\n\"); } static void Two(Task t) { Console.WriteLine(\"t Id:{0}\", t.Id); Console.WriteLine(\"TaskID:{0}\",Task.CurrentId); Console.WriteLine(\"this is Two\\n\"); } 输出结果如下： TaskID:1 this is One t Id:1 TaskID:2 this is Two t Id:2 TaskID:3 this is Two t Id:3 TaskID:4 this is Two 使用ContinueWith()方法时，无论前面一个任务是如何结束的，哪怕是发生异常，也会在结束时启动下一个任务，使用TaskContinuationOptions中的枚举值来指定如何启动延续任务，TaskContinuationOptions中指定延续任务启动条件的值如下: // // 摘要: // Default = \"Continue on any, no task options, run asynchronously\" 指定应使用默认行为。默认情况下，完成前面的任务之后将安排运行延续任务，而不考虑前面任务的最终 // System.Threading.Tasks.TaskStatus。 None = 0, // // 摘要: // 提示 System.Threading.Tasks.TaskScheduler 以一种尽可能公平的方式安排任务，这意味着较早安排的任务将更可能较早运行，而较晚安排运行的任务将更可能较晚运行。 PreferFairness = 1, // // 摘要: // 指定某个任务将是运行时间长、粗粒度的操作。它会向 System.Threading.Tasks.TaskScheduler 提示，过度订阅可能是合理的。 LongRunning = 2, // // 摘要: // 指定将任务附加到任务层次结构中的某个父级。 AttachedToParent = 4, // // 摘要: // 如果尝试附有子任务到创建的任务，指定 System.InvalidOperationException 将被引发。 DenyChildAttach = 8, // // 摘要: // 防止环境计划程序被视为已创建任务的当前计划程序。这意味着像 StartNew 或 ContinueWith 创建任务的执行操作将被视为 System.Threading.Tasks.TaskScheduler.Default // 当前计划程序。 HideScheduler = 16, // // 摘要: // 在延续取消的情况下，防止延续的完成直到完成先前的任务。 LazyCancellation = 32, // // 摘要: // 指定不应在延续任务前面的任务已完成运行的情况下安排延续任务。此选项对多任务延续无效。 NotOnRanToCompletion = 65536, // // 摘要: // 指定不应在延续任务前面的任务引发了未处理异常的情况下安排延续任务。此选项对多任务延续无效。 NotOnFaulted = 131072, // // 摘要: // 指定只应在延续任务前面的任务已取消的情况下安排延续任务。此选项对多任务延续无效。 OnlyOnCanceled = 196608, // // 摘要: // 指定不应在延续任务前面的任务已取消的情况下安排延续任务。此选项对多任务延续无效。 NotOnCanceled = 262144, // // 摘要: // 指定只有在延续任务前面的任务引发了未处理异常的情况下才应安排延续任务。此选项对多任务延续无效。 OnlyOnFaulted = 327680, // // 摘要: // 指定只应在延续任务前面的任务已完成运行的情况下才安排延续任务。此选项对多任务延续无效。 OnlyOnRanToCompletion = 393216, // // 摘要: // 指定应同步执行延续任务。指定此选项后，延续任务将在导致前面的任务转换为其最终状态的相同线程上运行。如果在创建延续任务时已经完成前面的任务，则延续任务将在创建此延续任务的线程上运行。只应同步执行运行时间非常短的延续任务。 ExecuteSynchronously = 524288 任务的层次结构（父/子任务）在一个任务的内部启动另一个任务时，任务便会形成一种层次结构，如果父任务在子任务之前结束，父任务的状态为:WaitingForChildrenToComplete,可在子任务创建时使用TaskCreationOptions指定父子任务如何运行。 线程等待、取消和异常处理线程取消和异常处理线程间都是通过共有变量：都能访问局部变量/全局变量/数据库的一个值/硬盘文件来通信。线程不能被外部停止，只能自身停止自身；或者在任务启动前停止，会抛出AggregateException异常的 步骤： 使用CancellationTokenSource类的实例作为公共变量 CancellationTokenSource类的Cancel方法指示线程取消。 IsCancellationRequested属性判断是否被取消。 示例代码如下： TaskFactory taskFactory = new TaskFactory(); List&lt;Task> taskList = new List&lt;Task>(); CancellationTokenSource cts = new CancellationTokenSource(); for (int i = 0; i &lt; 40; i++) { string name = string.Format(\"btnThreadCore_Click{0}\", i); Action&lt;object> act = t => { try { //if (cts.IsCancellationRequested) //{ // Console.WriteLine(\"{0} 取消一个任务的执行\", t); //} Thread.Sleep(2000); if (t.ToString().Equals(\"btnThreadCore_Click11\")) { throw new Exception(string.Format(\"{0} 执行失败\", t)); } if (t.ToString().Equals(\"btnThreadCore_Click12\")) { throw new Exception(string.Format(\"{0} 执行失败\", t)); } if (cts.IsCancellationRequested)//检查信号量 { Console.WriteLine(\"{0} 放弃执行\", t); } else { Console.WriteLine(\"{0} 执行成功\", t); } } catch (Exception ex) { cts.Cancel();//表示修改了信号量 让大家取消执行 Console.WriteLine(ex.Message); } }; taskList.Add(taskFactory.StartNew(act, name, cts.Token));//没有启动的任务 在Cancel后放弃启动 } Task.WaitAll(taskList.ToArray()); 输出结果为： btnThreadCore_Click1 执行成功 btnThreadCore_Click0 执行成功 btnThreadCore_Click3 执行成功 btnThreadCore_Click2 执行成功 btnThreadCore_Click4 执行成功 btnThreadCore_Click5 执行成功 btnThreadCore_Click7 执行成功 btnThreadCore_Click6 执行成功 btnThreadCore_Click8 执行成功 btnThreadCore_Click9 执行成功 btnThreadCore_Click10 执行成功 btnThreadCore_Click11 执行失败 btnThreadCore_Click13 放弃执行 btnThreadCore_Click12 执行失败 btnThreadCore_Click14 放弃执行 btnThreadCore_Click15 放弃执行 btnThreadCore_Click16 放弃执行 btnThreadCore_Click17 放弃执行 btnThreadCore_Click18 放弃执行 btnThreadCore_Click19 放弃执行 这段代码在执行到WaitAll时会抛出AggregateException异常。 这就引出了多线程中的异常处理问题，在多线程的代码块中所有抛出的异常都不会被主线程截获到，只有在任务WaitAll时才会抛出异常，所以应该在异步任务中使用try-catch语句块记录日志，在WaitAll外处理异常。 线程等待：给Thread、ThreadPool封装异步回调方法封装示例如下: /// &lt;summary> /// 无返回值，支持回调 /// &lt;/summary> /// &lt;param name=\"action\">&lt;/param> /// &lt;param name=\"callBack\">&lt;/param> public static void CallBack(Action action, Action callBack) { // 摘要: // 用一个指示是否将初始状态设置为终止的布尔值初始化 System.Threading.ManualResetEvent 类的新实例。 // // 参数: // initialState: // 如果为 true，则将初始状态设置为终止；如果为 false，则将初始状态设置为非终止。 ManualResetEvent mre = new ManualResetEvent(false); WaitCallback act = state => { //执行主方法 action.Invoke(); //主方法执行完 可以执行回调方法了 mre.Set(); //回调方法的线程 WaitCallback call = t => { //等待收到Set信号 mre.WaitOne(); //执行回调方法 callBack.Invoke(); }; ThreadPool.QueueUserWorkItem(call); }; ThreadPool.QueueUserWorkItem(act); } 调用： CallBack(() => { Console.WriteLine(\"异步方法\"); }, () => { Thread.Sleep(2000); Console.WriteLine(\"回调方法\"); }); Console.WriteLine(\"主线程\"); 输出结果为： 主线程 异步方法 回调方法 对Thread的封装如下: /// &lt;summary> /// 无返回值，支持回调 /// &lt;/summary> /// &lt;param name=\"action\">&lt;/param> /// &lt;param name=\"callBack\">&lt;/param> public static void CallBack(Action action, Action callBack) { // 摘要: // 用一个指示是否将初始状态设置为终止的布尔值初始化 System.Threading.ManualResetEvent 类的新实例。 // // 参数: // initialState: // 如果为 true，则将初始状态设置为终止；如果为 false，则将初始状态设置为非终止。 ManualResetEvent mre = new ManualResetEvent(false); ThreadStart act = () => { //执行主方法 action.Invoke(); //主方法执行完 可以执行回调方法了 mre.Set(); //回调方法的线程 ThreadStart call = () => { //等待收到Set信号 mre.WaitOne(); //执行回调方法 callBack.Invoke(); }; new Thread(call).Start(); }; new Thread(act).Start(); } 调用方式和线程池一样。","path":"2017/05/15/task_async/","date":"05-15","excerpt":""},{"title":"反射的简单使用","text":"反射的用途 使用 Assembly 定义和加载程序集，加载在程序集清单中列出的模块，以及从此程序集中查找类型并创建该类型的实例。`javaAssembly ass = Assembly.Load(“程序集完全限定名”); Assembly ass = Assembly.LoadFile(“程序集绝对路径”); 2. 使用 Module 了解如下的类似信息:包含模块的程序集以及模块中的类等。您还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。 3. 使用 ConstructorInfo 了解如下的类似信息:构造函数的名称、参数、访问修饰符(如 public 或 private)和实现详细信息(如 abstract 或 virtual)等。 4. 使用 Type 的 GetConstructors 或 GetConstructor 方法来调用特定的构造函数。 5. 使用 MethodInfo 来了解如下的类似信息:方法的名称、返回类型、参数、访问修饰符(如 public 或 private)和实现详细信 息(如 abstract 或 virtual)等。使用 Type 的 GetMethods 或 GetMethod 方法来调用特定的方法。 6. 使用 FieldInfo 来了解如下的类似信息:字段的名称、访问修饰符(如 public 或 private)和实现详细信息(如 static)等;并获取或设置字段值。 7. 使用 EventInfo 来了解如下的类似信息:事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等;并添加或移除事件处理程序。 8. 使用 PropertyInfo 来了解如下的类似信息:属性的名称、数据类型、声明类型、反射类型和只读或可写状态等;并获取或设置属性值。 9. 使用 ParameterInfo 来了解如下的类似信息:参数的名称、数据类型、参数是输入参数还是输出参数，以及参数在方法签名中的位置等。 ### 反射获取属性 关键代码如下: ```java static void Main(string[] args) { Type type = typeof(Person); object person = Activator.CreateInstance(type);//创建对象 //GetProperties() // 摘要: // 返回当前 System.Type 的所有公共属性。 // // 返回结果: // 表示当前 System.Type 的所有公共属性的 System.Reflection.PropertyInfo 对象数组。- 或 -如果当前 System.Type // 没有公共属性，则为 System.Reflection.PropertyInfo 类型的空数组。 foreach (var prop in type.GetProperties()) { if (prop.Name.Equals(&quot;name&quot;)) { // // 摘要: // 设置指定对象的属性值。 // // 参数: // obj: // 将设置其属性值的对象。 // // value: // 新的属性值。 prop.SetValue(person,&quot;李四&quot;); } if (prop.Name.Equals(&quot;age&quot;)) { prop.SetValue(person,12); } Console.WriteLine(&quot;属性名为:&quot;+prop.Name+&quot;值为:&quot;+prop.GetValue(person)); } Console.ReadKey(); } Person类的代码如下: public class Person { public string name { get; set; } public int age { get; set; } public void Show() { Console.WriteLine(\"My name is \"+name); } public void Show(string par) { Console.WriteLine(\"Show方法的重载\"); } private void privateShow() { Console.WriteLine(\"This is privateShow\"); } public void GenericShow&lt;T>(T t) { Console.WriteLine(\"This is GenericShow \"+t.ToString()); } } 输出结果为: 属性名为:name值为:李四 属性名为:age值为:12 反射加载泛型类使用反射加载泛型类时必须在后面加上”`1”,示例如下： 用于反射加载的程序集：MyReflection.dll,在此dll中定义了一个泛型类： namespace MyReflection { public class DbHelper&lt;T> { public DbHelper(){} } } 加载泛型类示例： Assembly ass = Assembly.Load(\"MyReflection\"); Type type= ass.GetType(\"MyReflection.DbHelper`1\"); Console.WriteLine(type.Name); 输出结果为: DbHelper`1 当需要创建泛型类型的实例时则需要使用MakeGenericMethod指定泛型的类型 反射调用方法调用普通实例方法关键代码如下: var show= type.GetMethod(\"Show\"); show.Invoke(person,null); 输出结果为: My name is 李四 调用私有实例方法Assembly ass = Assembly.Load(\"MyReflection\"); Type type= ass.GetType(\"MyReflection.Person\"); var person = Activator.CreateInstance(type); var method = type.GetMethod(\"privateShow\",BindingFlags.Instance| BindingFlags.NonPublic); Console.WriteLine(method.Invoke(person,null)); 输出结果为: This is privateShow 调用私有构造方法Activator.CreateInstance(type,true) 调用重载方法Assembly ass = Assembly.Load(\"MyReflection\"); Type type= ass.GetType(\"MyReflection.Person\"); var person = Activator.CreateInstance(type); var method1 = type.GetMethod(\"Show\",new Type[] { }); var method2 = type.GetMethod(\"Show\", new Type[] { typeof(string) }); Console.WriteLine(method1.Invoke(person,null)); Console.WriteLine(method2.Invoke(person,new object[] { \"d\"})); 输出结果为: My name is Show方法的重载 即调用有重载的方法时，必须指定方法的参数列表对应的Type数组。即使是无参也必须指定，不能写null。 调用泛型方法Assembly ass = Assembly.Load(\"MyReflection\"); Type type= ass.GetType(\"MyReflection.Person\"); var person = Activator.CreateInstance(type); var method = type.GetMethod(\"GenericShow\"); method = method.MakeGenericMethod(typeof(string)); Console.WriteLine(method.Invoke(person, new object[] { \"哈哈哈\" })); 输出结果为: This is GenericShow 哈哈哈 即调用泛型方法需要使用Method的MakeGenericMethod指定泛型的类型。 调用静态方法Assembly ass = Assembly.Load(\"MyReflection\"); Type type= ass.GetType(\"MyReflection.Person\"); var method = type.GetMethod(\"staticShow\"); Console.WriteLine(method.Invoke(null,null) ); 输出结果为: This is staticShow 调用静态方法就是在Invoke时将类型实例指定为null即可。 反射的优缺点优点： 反射提高了程序的灵活性和扩展性。 降低耦合性，提高自适应能力。 它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。 使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。","path":"2017/05/14/reflection/","date":"05-14","excerpt":""},{"title":"Http请求头参数","text":"Http协议请求头参数1Accept-LanguageAccept-Language: zh-cn,zh;q=0.5 意思：浏览器支持的语言分别是中文和简体中文，优先支持简体中文。 详解： Accept-Language表示浏览器所支持的语言类型； zh-cn表示简体中文；zh 表示中文； q是权重系数，范围 0 =&lt; q &lt;= 1，q 值越大，请求越倾向于获得其“;”之前的类型表示的内容，若没有指定 q 值，则默认为1，若被赋值为0，则用于提醒服务器哪些是浏览器不接受的内容类型。 2.Accept-CharsetAccept-Charset: GB2312,utf-8;q=0.7,*;q=0.7 意思：浏览器支持的字符编码分别是 GB2312、utf-8 和任意字符，优先顺序是 GB2312、utf-8、*。 详解： Accept-Charset告诉 Web 服务器，浏览器可以接受哪些字符编码； GB2312是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312 编码通行于中国大陆；新加坡等地也采用此编码。 utf-8是 Unicode 的一种变长字符编码又称万国码，由 Ken Thompson 于1992年创建，现在已经标准化为 RFC 3629。 表示任意字符编码，虽然 q 都是等于 0.7，但明确指定的 GB2312,utf-8 比 具有更高的优先级。 3.AcceptAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 意思：浏览器支持的 MIME 类型分别是 text/html、application/xhtml+xml、application/xml 和 /，优先顺序是它们从左到右的排列顺序。 详解： Accept表示浏览器支持的 MIME 类型； MIME的英文全称是 Multipurpose Internet Mail Extensions（多功能 Internet 邮件扩充服务），它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。 text/html,application/xhtml+xml,application/xml 都是 MIME 类型，也可以称为媒体类型和内容类型，斜杠前面的是 type（类型），斜杠后面的是 subtype（子类型）；type 指定大的范围，subtype 是 type 中范围更明确的类型，即大类中的小类。 Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； text/html表示 html 文档； Application：用于传输应用程序数据或者二进制数据； application/xhtml+xml表示 xhtml 文档； application/xml表示 xml 文档。 application/json表示 json 文档。 4.Accept-EncodingAccept-Encoding: gzip, deflate 意思：浏览器支持的压缩编码是 gzip 和 deflate。 详解： Accept-Encoding表示浏览器有能力解码的编码类型； gzip是 GNU zip 的缩写，它是一个 GNU 自由软件的文件压缩程序，也经常用来表示 gzip 这种文件格式。 deflate是同时使用了 LZ77 算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。 5.User-AgentUser-Agent: Mozilla/5.0 (compatible;域名) 意思：使用的用户代理是 Mozilla/5.0 (compatible; 域名)。 详解： User-Agent（用户代理），简称 UA，它是一个特殊字符串头，使得服务器能够识别客户端使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。 Mozilla/5.0：Mozilla 是浏览器名，版本是 5.0； compatible（兼容的）表示平台是兼容模式； 6.Host Host: 域名 Host表示请求的服务器网址； 7.ConnectionConnection: Keep-Alive Connection表示客户端与服务连接类型； Keep-Alive表示持久连接； 除协议的请求头外，还可以添加自定义请求头 原文地址","path":"2017/05/14/httprequestheader/","date":"05-14","excerpt":""},{"title":"HttpClient类的使用","text":"使用HttpClient异步调用Web服务简单的调用示例代码如下： static void Main(string[] args) { GetData(); Console.WriteLine(\"调用了GetData\"); Console.ReadKey(); } public static async void GetData() { HttpClient httpClient = new HttpClient(); HttpResponseMessage response = null; //异步发送Get请求，此地址为微软示例Web服务 response = await httpClient.GetAsync(\"http://services.odata.org/Northwind/Northwind.svc/Regions\"); if (response.IsSuccessStatusCode) { //输出响应状态 Console.WriteLine(\"Response Status Code:\" + response.StatusCode + \" \" + response.ReasonPhrase); //获取响应结果 string responseBodyAsText = response.Content.ReadAsStringAsync().Result; Console.WriteLine(\"Received payload of \" + responseBodyAsText.Length + \" characters\"); } } 输出结果如下： 调用了GetData Response Status Code:OK OK Received payload of 3379 characters 因为HttpClient类使用GetAsync方法调用，且使用了await关键字，所以Main方法可以在GetAsync方法调用Web服务的同时执行完毕。因此Main方法输出到屏幕上的消息先显示。 HttpClient对象是线程安全的，所以一个HttpClient对象就可以用于处理多个请求。HttpClient的每个实例都维护它自己的线程池. 请求和响应头前面的示例中，发出请求没有设置或改变任何标题，HttpClient的DefaultRequestHeaders属性允许设置或改变标题。 另一篇文章列举了部分常用Http请求头参数：Http请求头参数 static void Main(string[] args) { GetData(); Console.WriteLine(\"调用了GetData\"); Console.ReadKey(); } private static async void GetData() { HttpClient httpClient = new HttpClient(); //设置请求头 httpClient.DefaultRequestHeaders.Add(\"Accept\",\"application/json;odata=verbose\"); HttpResponseMessage response = null; //异步发送Get请求，此地址为微软示例Web服务 response = await httpClient.GetAsync(\"http://services.odata.org/Northwind/Northwind.svc/Regions\"); if (response.IsSuccessStatusCode) { //输出响应状态 Console.WriteLine(\"Response Status Code:\" + response.StatusCode + \" \" + response.ReasonPhrase); //获取响应结果 string responseBodyAsText = response.Content.ReadAsStringAsync().Result; Console.WriteLine(\"Received payload of \" + responseBodyAsText.Length + \" characters\"); Console.WriteLine(\"请求头如下:\"); EnumerateHeaders(httpClient.DefaultRequestHeaders); Console.WriteLine(\"响应头如下:\"); EnumerateHeaders(response.Headers); } } private static void EnumerateHeaders(HttpHeaders headers) { foreach (var header in headers) { var value = \"\"; foreach (var val in header.Value) { value = val + \" \"; } Console.WriteLine(\"Header:\" + header.Key + \" Value:\" + value); } } HttpContent表示 HTTP 实体正文和内容标头的基类。 响应中的Conten属性返回一个HttpContent对象。前面的例子中使用ReadAsStringAsync方法来获取其内容。 HttpMessageHandler","path":"2017/05/14/httpclient/","date":"05-14","excerpt":""},{"title":"dynamic类型","text":"使用规则忽略编译时类型检查dynamic类型允许编写忽略编译期间的类型检查代码。编译器假定，给dynamic类型的对象的任何操作都是有效的。如果该操作无效，则在代码运行之前不会检测该错误。示例如下： class Program { static void Main(string[] args) { var varPerson = new Person(); dynamic dynamicPerson = new Person(); varPerson.GetStr(\"hello\"); // 错误 CS1501 “GetStr”方法没有采用 1 个参数的重载 dynamicPerson.GetStr(\"hello\");//无异常 } } class Person { public string GetStr() { return \"Hello World\"; } } 运行期间改变类型与var关键字不同,定义为dynamic的对象可以在运行期间改变其类型。例如：不能把int类型强制转换为Person对象，如果对象是动态对象，就可以把它从int变成Person类型。示例如下: class Program { static void Main(string[] args) { dynamic dyn; dyn = 100; Console.WriteLine(dyn.GetType()); Console.WriteLine(dyn); dyn = new Person(); Console.WriteLine(dyn.GetType()); Console.WriteLine(dyn.GetStr()); } } class Person { public string GetStr() { return \"Hello World\"; } } 输出结果如下： System.Int32 100 ConsoleApplication2.Person Hello World ASP.NET MVC中的ViewBag即是dynamic类型","path":"2017/05/13/dynamic/","date":"05-13","excerpt":""},{"title":"ASP.NET断点续传大文件","text":"转载而来，但忘了从哪转的了 IE的自带下载功能中没有断点续传功能，要实现断点续传功能，需要用到HTTP协议中鲜为人知的几个响应头和请求头。一. 两个必要响应头Accept-Ranges、ETag 客户端每次提交下载请求时，服务端都要添加这两个响应头，以保证客户端和服务端将此下载识别为可以断点续传的下载：Accept-Ranges：告知下载客户端这是一个可以恢复续传的下载，存放本次下载的开始字节位置、文件的字节大小；ETag：保存文件的唯一标识（我在用的文件名+文件最后修改时间，以便续传请求时对文件进行验证）；Last-Modified：可选响应头，存放服务端文件的最后修改时间，用于验证 二. 一个重要请求头RangeRange：首次下载时，Range头为null，此时服务端的响应头中必须添加响应头Accept-Ranges、ETag； 续传请求时，其值表示客户端已经收到的字节数，即本次下载的开始字节位置，服务端依据这个 值从相应位置读取数据发送到客户端。 三. 用于验证的请求头If-Range、 当响应头中包含有Accept-Ranges、ETag时，续传请求时，将包含这些请求头：If-Range：对应响应头ETag的值；Unless-Modified-Since：对应响应头Last-Modified的值。 续传请求时，为了保证客户端与服务端的文件的一致性和正确性，有必要对文件进行验证，验证需要自己写验证代码，就根据解析这两个请求头的值，将客户端已下载的部分与服务端的文件进行对比，如果不吻合，则从头开始下载，如果吻合，则断点续传。 四. 速度限制 程序中加入了速度限制，用于对客户端进行权限控制的流量限制。 五. 其它注意事项 如：文件名乱码的问题、文件名中空格变加号、强制客户端显示下载对话框等，详见源码注释： //// &lt;summary> /// 下载文件，支持大文件、续传、速度限制。支持续传的响应头Accept-Ranges、ETag，请求头Range 。 /// Accept-Ranges：响应头，向客户端指明，此进程支持可恢复下载.实现后台智能传输服务（BITS），值为：bytes； /// ETag：响应头，用于对客户端的初始（200）响应，以及来自客户端的恢复请求， /// 必须为每个文件提供一个唯一的ETag值（可由文件名和文件最后被修改的日期组成），这使客户端软件能够验证它们已经下载的字节块是否仍然是最新的。 /// Range：续传的起始位置，即已经下载到客户端的字节数，值如：bytes=1474560- 。 /// 另外：UrlEncode编码后会把文件名中的空格转换中+（+转换为%2b），但是浏览器是不能理解加号为空格的，所以在浏览器下载得到的文件，空格就变成了加号； /// 解决办法：UrlEncode 之后, 将 \"+\" 替换成 \"%20\"，因为浏览器将%20转换为空格 /// &lt;/summary> /// &lt;param name=\"httpContext\">当前请求的HttpContext&lt;/param> /// &lt;param name=\"filePath\">下载文件的物理路径，含路径、文件名&lt;/param> /// &lt;param name=\"speed\">下载速度：每秒允许下载的字节数&lt;/param> /// &lt;returns>true下载成功，false下载失败&lt;/returns> public static bool DownloadFile(HttpContext httpContext, string filePath, long speed) { bool ret = true; try { --验证：HttpMethod，请求的文件是否存在#region--验证：HttpMethod，请求的文件是否存在 switch (httpContext.Request.HttpMethod.ToUpper()) { //目前只支持GET和HEAD方法 case \"GET\": case \"HEAD\": break; default: httpContext.Response.StatusCode = 501; return false; } if (!File.Exists(filePath)) { httpContext.Response.StatusCode = 404; return false; } #endregion 定义局部变量#region 定义局部变量 long startBytes = 0; int packSize = 1024 * 10; //分块读取，每块10K bytes string fileName = Path.GetFileName(filePath); FileStream myFile = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite); BinaryReader br = new BinaryReader(myFile); long fileLength = myFile.Length; int sleep = (int)Math.Ceiling(1000.0 * packSize / speed);//毫秒数：读取下一数据块的时间间隔 string lastUpdateTiemStr = File.GetLastWriteTimeUtc(filePath).ToString(\"r\"); string eTag = HttpUtility.UrlEncode(fileName, Encoding.UTF8) + lastUpdateTiemStr;//便于恢复下载时提取请求头; #endregion --验证：文件是否太大，是否是续传，且在上次被请求的日期之后是否被修改过--------------#region--验证：文件是否太大，是否是续传，且在上次被请求的日期之后是否被修改过-------------- if (myFile.Length > Int32.MaxValue) {//-------文件太大了------- httpContext.Response.StatusCode = 413;//请求实体太大 return false; } if (httpContext.Request.Headers[\"If-Range\"] != null)//对应响应头ETag：文件名+文件最后修改时间 { //----------上次被请求的日期之后被修改过-------------- if (httpContext.Request.Headers[\"If-Range\"].Replace(\"\\\"\", \"\") != eTag) {//文件修改过 httpContext.Response.StatusCode = 412;//预处理失败 return false; } } #endregion try { -------添加重要响应头、解析请求头、相关验证-------------------#region -------添加重要响应头、解析请求头、相关验证------------------- httpContext.Response.Clear(); httpContext.Response.Buffer = false; httpContext.Response.AddHeader(\"Content-MD5\", GetMD5Hash(myFile));//用于验证文件 httpContext.Response.AddHeader(\"Accept-Ranges\", \"bytes\");//重要：续传必须 httpContext.Response.AppendHeader(\"ETag\", \"\\\"\" + eTag + \"\\\"\");//重要：续传必须 httpContext.Response.AppendHeader(\"Last-Modified\", lastUpdateTiemStr);//把最后修改日期写入响应 httpContext.Response.ContentType = \"application/octet-stream\";//MIME类型：匹配任意文件类型 httpContext.Response.AddHeader(\"Content-Disposition\", \"attachment;filename=\" + HttpUtility.UrlEncode(fileName, Encoding.UTF8).Replace(\"+\", \"%20\")); httpContext.Response.AddHeader(\"Content-Length\", (fileLength - startBytes).ToString()); httpContext.Response.AddHeader(\"Connection\", \"Keep-Alive\"); httpContext.Response.ContentEncoding = Encoding.UTF8; if (httpContext.Request.Headers[\"Range\"] != null) {//------如果是续传请求，则获取续传的起始位置，即已经下载到客户端的字节数------ httpContext.Response.StatusCode = 206;//重要：续传必须，表示局部范围响应。初始下载时默认为200 string[] range = httpContext.Request.Headers[\"Range\"].Split(new char[] { '=', '-' });//\"bytes=1474560-\" startBytes = Convert.ToInt64(range[1]);//已经下载的字节数，即本次下载的开始位置 if (startBytes &lt; 0 || startBytes >= fileLength) {//无效的起始位置 return false; } } if (startBytes > 0) {//------如果是续传请求，告诉客户端本次的开始字节数，总长度，以便客户端将续传数据追加到startBytes位置后---------- httpContext.Response.AddHeader(\"Content-Range\", string.Format(\" bytes {0}-{1}/{2}\", startBytes, fileLength - 1, fileLength)); } #endregion -------向客户端发送数据块-------------------#region -------向客户端发送数据块------------------- br.BaseStream.Seek(startBytes, SeekOrigin.Begin); int maxCount = (int)Math.Ceiling((fileLength - startBytes + 0.0) / packSize);//分块下载，剩余部分可分成的块数 for (int i = 0; i &lt; maxCount &amp;&amp; httpContext.Response.IsClientConnected; i++) {//客户端中断连接，则暂停 httpContext.Response.BinaryWrite(br.ReadBytes(packSize)); httpContext.Response.Flush(); if (sleep > 1) Thread.Sleep(sleep); } #endregion } catch { ret = false; } finally { br.Close(); myFile.Close(); } } catch { ret = false; } return ret; } httpContext.Response.Flush(); //此句可以省略... //调用惯例: Page.Response.Clear(); bool success = ResponseFile(Page.Request, Page.Response, \"filename\", @\"C:\\download.date\", 1024000); if(!success) Response.Write(\"下载文件出错!\"); Page.Response.End();","path":"2017/05/12/aspdownbigfile/","date":"05-12","excerpt":""},{"title":"从富文本(HTML字符串)中获取图片","text":"示例代码如下: &lt;!--从富文本(HTML字符串)中获取图片--> &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> &lt;html xmlns=\"http://www.w3.org/1999/xhtml\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>test&lt;/title> &lt;script type=\"text/javascript\"> var str = '&lt;p>hehehe&lt;/p>&lt;img src=\"a.jpg\"/>&lt;hr>&lt;img src=\"b.jpg\"/>&lt;img src=\"c.jpg\"/>'; function Getarticleimg() { var reg =/\\&lt;img[^\\>]*[\\/]?\\>/ig; var result = str.match(reg); if(result) { for (i = 0; i &lt; result.length; i++) { result[i].replace( /src=(\\\"|\\')?([^\\\"\\>]*)(\\\"|\\')?( |>|\\/)/ig, function( $1,$2,$3,$4 ){ result[i] = $3; } ); } return result; } else { return \"文章中没有找到图片！请您上传图片。\"; } //--> } &lt;/script> &lt;/head> &lt;body> &lt;a href=\"javascript:Getarticleimg()\">点击测试&lt;/a> &lt;/body> &lt;/html>","path":"2017/05/12/gethtmlimg/","date":"05-12","excerpt":""},{"title":"WinForm启动时自动以管理员身份运行","text":"关键部分代码如下: /// &lt;summary> /// 应用程序的主入口点。 /// &lt;/summary> [STAThread] static void Main(string[] args) { //获得当前windows登录用户标识 System.Security.Principal.WindowsIdentity identity = System.Security.Principal.WindowsIdentity.GetCurrent(); //创建Windows用户主题 Application.EnableVisualStyles(); System.Security.Principal.WindowsPrincipal principal = new System.Security.Principal.WindowsPrincipal(identity); //判断登录用户是否为管理员 if (principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator)) { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Loign()); } else { //创建启动对象 System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo(); //设置运行文件 startInfo.FileName = System.Windows.Forms.Application.ExecutablePath; //设置启动参数 startInfo.Arguments = String.Join(\" \",args); startInfo.Verb = \"runas\"; //不是管理员则启动UAC System.Diagnostics.Process.Start(startInfo); System.Windows.Forms.Application.Exit(); } }","path":"2017/05/12/identityrun/","date":"05-12","excerpt":""},{"title":"使用operator进行运算符重载","text":"使用operator关键字 运算符重载的声明方式与方法相同，但operator关键字告诉编译器，它实际上是一个自定义的运算符重载,后面是相关运算符的实际符号。 C#要求所有的运算符重载都声明为public和static,这表示它们与它们的类或结构相关联，而不是与某个特定实例相关联，所以运算符重载的代码体不能访问非静态类成员，也不能访问this标识符。 下面实现了一个重载自定义类型Point的’+’运算符和’*’运算符： class Program { static void Main(string[] args) { Point p1 = new Point(1.0,2.0); Point p2 = new Point(4.0,5.0); var pSum = p1 + p2; Console.WriteLine(pSum.X+\",\"+pSum.Y); var p = p1 * 2; Console.WriteLine(p.X+\",\"+p.Y); } } /// /// 定义Point类 /// class Point { public Point() { } public Point(double x,double y) { this._x = x; this._y = y; } private double _x; public double X { get { return _x; } set { _x = value; } } private double _y; public double Y { get { return _y; } set { _y = value; } } /// /// 将两个Point值相加 /// /// /// /// public static Point operator +(Point lhs,Point rhs) { return new Point(lhs.X+rhs.X,lhs.Y+rhs.Y); } /// /// 将Point扩大rhs倍 /// /// /// /// public static Point operator *(Point lhs,int rhs) { return new Point(lhs.X*Math.Abs(rhs),lhs.Y*Math.Abs(rhs)); } } C#不允许重载”=”运算符，但如果重载了”+”运算符，编译器就会自动使用“+”运算符的重载来执行“+=”运算符的操作，其他运算符类似。","path":"2017/05/11/operator/","date":"05-11","excerpt":""},{"title":"程序集和应用程序域","text":"程序集的概念程序集是.NET应用程序的部署单元。.NET应用程序包含一个或者多个程序集。通常扩展名是EXE或者DLL的.NET可执行程序称为程序集。 程序集的结构程序集由描述它的程序集元数据、描述导出类型和方法的类型元数据、MSIL代码和资源组成。所有这些部分都在一个文件中，或者分布在几个文件中。 程序集清单 是元数据的一部分，描述了程序集和引用它所需要的所有信息。由以下部分组成 标识(名称，版本，文化和公钥) 属于该程序集的一个文件列表。 被引用程序集的列表 一组许可请求，即运行这个程序集需要的许可。 导出的类型 程序集的特性在AssemblyInfo.cs中。System.Reflection名称空间定义的特性列表如下:|Method | 含义 || :———: | :———–: ||AssemblyCompany | 指定公司名 || AssemblyConfiguration| 指定构建信息，例如调试或零售信息|| AssemblyCopyright and AssemblyTrademark | 包含版权和商标信息 || AssemblyDefaultAlias | 为程序集指定别名 || AssemblyDescription | 描述程序集或产品|| AssemblyProduct | 描述程序所属的产品名称|| AssemblyTitle | 为程序集提供一个友好的名称|| AssemblyCulture | 定义程序集文化 || AssemblyInfomationalVersion | 版本信息,不用于版本检查|| AssemblyVersion| 程序集版本号 || AssemblyFileVersion|文件版本，显示在Windows属性窗口中，对.NET行为无影响 | 应用程序域在.NET之前的技术中，进程作为独立的边界来使用，每个进程都有其私有的虚拟内存；运行在一个进程中的应用程序不能写入另一个应用程序的内存，也不会因为这种方式破坏其他应用程序。该进程用作应用程序之间的一个独立而安全的边界。在.NET体系结构中，应用程序有一个新的边界：应用程序域。 使用.NET建立的可执行程序 *.exe，并没有直接承载到进程当中，而是承载到应用程序域（AppDomain）当中。应用程序域是.NET引入的一个新概念，它比进程所占用的资源要少，可以被看作是一个轻量级的进程。在一个进程中可以包含多个应用程序域，一个应用程序域可以装载一个可执行程序（*.exe）或者多个程序集（*.dll）。这样可以使应用程序域之间实现深度隔离，即使进程中的某个应用程序域出现错误，也不会影响其他应用程序域的正常运作。 通过CreateDomain方法可以建立一个新的应用程序域。下面的例子将使用CreateDomain建立一个应用程序域，并使用Load方法加载程序集Model.dll。最后使用GetAssemblies方法，列举此应用程序域中的所有程序集。 static void Main(string[] args) { var appDomain = AppDomain.CreateDomain(\"NewAppDomain\"); appDomain.Load(\"Model\"); foreach (var assembly in appDomain.GetAssemblies()) Console.WriteLine(string.Format(\"{0}\\n----------------------------\", assembly.FullName)); Console.ReadKey(); } 注意：当加载程序集后，就无法把它从AppDomain中卸载，只能把整个AppDomain卸载。 当需要在AppDomain加载可执行程序时，可以使用ExecuteAssembly方法。 AppDomain.ExecuteAssembly(\"Example.exe\"); 卸载AppDomain通过Unload方法可以卸载AppDomain，在AppDomain卸载时将会触发DomainUnload事件。 在AppDomain中建立程序集中指定类的对象使用CreateInstance方法，能建立程序集中指定类的对像。但使用此方法将返回一个ObjectHandle对象，若要将此值转化为原类型，可调用Unwrap方法。 namespace Test { public class Program { static void Main(string[] args) { var person=(Person)AppDomain.CurrentDomain .CreateInstance(\"Model\",\"Model.Person\").Unwrap(); person.ID = 1; person.Name = \"Leslie\"; person.Age = 29; Console.WriteLine(string.Format(\"{0}'s age is {1}!\",person.Name,person.Age)); Console.ReadKey(); } } } namespace Model { public class Person { public int ID { get; set; } public string Name { get; set; } public int Age { get; set; } } } 共享程序集即GAC(全局程序集缓存)","path":"2017/05/10/assemblies/","date":"05-10","excerpt":""},{"title":"使用yield语句创建枚举器","text":"创建枚举器yield return 语句返回集合的一个元素，并移动到下一个元素上。yield break可停止迭代 class Program { static void Main(string[] args) { TestCollection c = new TestCollection(); c.Add(\"Hello\"); c.Add(\"World\"); foreach (var item in c) { Console.Write(item); } } } /// &lt;summary> /// 自定义集合类 /// &lt;/summary> class TestCollection { List&lt;string> list = new List&lt;string>(); public void Add(string s) { list.Add(s); } public IEnumerator&lt;string> GetEnumerator() { foreach (var item in list) { yield return item; } } } 类支持的默认迭代是定义为返回IEnumerator的GetEnumerator方法。自定义命名的迭代返回IEnumerable(如：将数组逆序迭代) yield return语句返回一个枚举器class Program { static void Main(string[] args) { TestCollection c = new TestCollection(); IEnumerator enumerator = c.Cross(); while (enumerator.MoveNext()) { enumerator = enumerator.Current as IEnumerator;//将enumerator的值设为当前的枚举器，用于下一次循环 } } } /// &lt;summary> /// 自定义集合类 /// &lt;/summary> class TestCollection { private IEnumerator cross; private IEnumerator circle; private int move = 0; private int maxmove = 9; public TestCollection() { cross = Cross(); circle = Circle(); } //定义两个IEnumerator的方法，各自返回对方的枚举器 public IEnumerator Cross() { while (true) { Console.WriteLine(\"Corross, move {0}\",move); if (++move>=maxmove) { yield break; } yield return circle; } } public IEnumerator Circle() { while (true) { Console.WriteLine(\"Circle, move {0}\",move); if (++move>=maxmove) { yield break; } yield return cross; } } } 结果:交替输出1-8","path":"2017/05/10/yield/","date":"05-10","excerpt":""}]}